<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RealF.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Clados</a> &gt; <a href="index.source.html" class="el_package">org.interworldtransport.cladosF</a> &gt; <span class="el_source">RealF.java</span></div><h1>RealF.java</h1><pre class="source lang-java linenums">/*
 * &lt;h2&gt;Copyright&lt;/h2&gt; Â© 2025 Alfred Differ&lt;br&gt;
 * ------------------------------------------------------------------------ &lt;br&gt;
 * ---org.interworldtransport.cladosF.RealF&lt;br&gt;
 * -------------------------------------------------------------------- &lt;br&gt;
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version. 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.&lt;br&gt;&lt;br&gt;
 * 
 * Use of this code or executable objects derived from it by the Licensee 
 * states their willingness to accept the terms of the license. &lt;br&gt; &lt;br&gt;
 * 
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.&lt;br&gt; &lt;br&gt;
 * 
 * ------------------------------------------------------------------------ &lt;br&gt;
 * ---org.interworldtransport.cladosF.RealF&lt;br&gt;
 * ------------------------------------------------------------------------ &lt;br&gt;
 */
package org.interworldtransport.cladosF;

import org.interworldtransport.cladosFExceptions.*;

/**
 * This class implements the concept of a Real Field from mathematics. Field
 * objects within the cladosF package are used as 'numbers' in the definition of
 * an algebra. All Clados objects use DivFieldElements and RealF is one
 * possibility.
 * &lt;br&gt;&lt;br&gt;
 * There is no doubt that the overhead related to this class is a waste of
 * resources. However, it allows one to plug fields into the algebra classes
 * without having to maintain many different types of monads and nyads. If Java
 * came with primitive types for complex and quaternion fields, and other
 * primitives implemented a 'Field' interface, I wouldn't bother writing this
 * object or any of the other descendants of DivFieldF.
 * &lt;br&gt;&lt;br&gt;
 * Applications requiring speed should use the monads and nyads that implement
 * numbers as primitives. Those classes are marked as such within the library.
 * &lt;br&gt;&lt;br&gt;
 * Ideally, this would extend java.lang.Float and implement an interface called
 * DivFieldF. That can't be done, though, because Float is final.
 * &lt;br&gt;&lt;br&gt;
 * @version 2.0
 * @author Dr Alfred W Differ
 */
public class RealF extends ProtoN implements Field, Normalizable {
	/**
	 * Static add method that creates a new RealF with the sum pF1 + pF2.
	 * &lt;br&gt;
	 * @param pF1 RealF
	 * @param pF2 RealF
	 * @throws FieldBinaryException This exception is thrown when there is a field
	 *                              mismatch
	 * @return RealF
	 */
	public static RealF add(RealF pF1, RealF pF2) throws FieldBinaryException {
<span class="pc bpc" id="L62" title="2 of 8 branches missed.">		if (RealF.isTypeMatch(pF1, pF2) &amp;&amp; !RealF.isNaN(pF1) &amp;&amp; !RealF.isNaN(pF2) &amp;&amp; !RealF.isInfinite(pF1)</span>
<span class="fc bfc" id="L63" title="All 2 branches covered.">				&amp;&amp; !RealF.isInfinite(pF2))</span>
<span class="fc" id="L64">			return RealF.create(pF1.getCardinal(), pF1.getReal() + pF2.getReal());</span>
<span class="fc" id="L65">		throw (new FieldBinaryException(pF1, &quot;Static Addition error found&quot;, pF2));</span>
	}

	/**
	 * Static method that creates a new RealF with the conjugate of the parameter.
	 * Since the conjugate of a real number is the real number, this method is
	 * functionally identical to #copy.
	 * &lt;br&gt;
	 * @param pF RealF
	 * @return RealF
	 */
	public static RealF conjugate(RealF pF) {
<span class="fc" id="L77">		return RealF.copyOf(pF);</span>
	}

	/**
	 * This static method takes a list of RealF objects and returns one RealF that
	 * has a value that is equal to the square root of the sum of the SQModulus of
	 * each entry on the list. Because these are real numbers, though, we get away
	 * with simply summing the moduli instead. It does not perform a cardinal safety
	 * check and will throw the exception if that test fails.
	 * &lt;br&gt;
	 * @param pL RealF[]
	 * @throws FieldBinaryException This exception is thrown when sqMagnitude fails
	 *                              with the RealF array
	 * @return RealF
	 */
	public final static RealF copySumModulus(RealF[] pL) throws FieldBinaryException {
<span class="pc bpc" id="L93" title="1 of 2 branches missed.">		if (pL.length == 0)	throw new IllegalArgumentException(&quot;Can't form Modulus Sum from empty array.&quot;);</span>
<span class="fc" id="L94">		RealF tR = RealF.copyZERO(pL[0]);</span>
<span class="fc bfc" id="L95" title="All 2 branches covered.">		for (RealF point : pL)</span>
<span class="fc" id="L96">			tR.add((RealF.copyONE(point).scale(point.sqModulus())));</span>
<span class="fc" id="L97">		tR.setReal((float) Math.sqrt(tR.getReal()));</span>
<span class="fc" id="L98">		return tR;</span>
	}

	/**
	 * This static method takes a list of RealF objects and returns one RealF that
	 * has a value that is equal to the sum of the SQModulus of each entry on the
	 * list. It does not perform a cardinal safety check and will throw the
	 * exception if that test fails.
	 * &lt;br&gt;
	 * @param pL RealF[]
	 * @throws FieldBinaryException This exception occurs when there is a field
	 *                              mismatch. It should never happen but the
	 *                              implementation uses multiplication, thus it is
	 *                              technically possible.
	 * @return RealF
	 */
	public final static RealF copySumSQModulus(RealF[] pL) throws FieldBinaryException {
<span class="pc bpc" id="L115" title="1 of 2 branches missed.">		if (pL.length == 0)	throw new IllegalArgumentException(&quot;Can't form SQ Modulus Sum from empty array.&quot;);</span>
<span class="fc" id="L116">		RealF tR = RealF.copyZERO(pL[0]);</span>
<span class="fc bfc" id="L117" title="All 2 branches covered.">		for (RealF point : pL)</span>
<span class="fc" id="L118">			tR.add((RealF.copyONE(point).scale(point.sqModulus())));</span>
<span class="fc" id="L119">		return tR;</span>
	}

	/**
	 * Static method that creates a new RealF with a copy of the parameter. This
	 * copy reuses the cardinal reference to ensure it will pass a type match test.
	 * &lt;br&gt;
	 * @param pF RealF
	 * @return RealF
	 */
	public static RealF copyOf(RealF pF) {
<span class="fc" id="L130">		return new RealF(pF);</span>
	}

	/**
	 * Static zero construction method with copied cardinal
	 * &lt;br&gt;
	 * @param pR RealF
	 * @return RealF
	 */
	public static RealF copyONE(ProtoN pR) {
<span class="fc" id="L140">		return RealF.create(pR.getCardinal(), 1.0f);</span>
	}

	/**
	 * Static zero construction method with copied cardinal
	 * &lt;br&gt;
	 * @param pR RealF
	 * @return RealF
	 */
	public static RealF copyZERO(ProtoN pR) {
<span class="fc" id="L150">		return RealF.create(pR.getCardinal(), 0.0f);</span>
	}

	/**
	 * Static method that creates a new RealF with a copy of the parameter. This
	 * copy does not reuse a cardinal reference so it is likely to fail type
	 * mismatch tests.
	 * &lt;br&gt;
	 * @param pR float
	 * @return RealF
	 */
	public static RealF create(float pR) {
<span class="fc" id="L162">		return new RealF(pR);</span>
	}

	/**
	 * Static method that creates a new RealF with a float and a Cardinal. This
	 * copy DOES reuse the cardinal so it is likely to pass type mismatch tests.
	 * &lt;br&gt;
	 * @param pCard Cardinal
	 * @param pR float
	 * @return RealF
	 */
	public static RealF create(Cardinal pCard, float pR) {
<span class="fc" id="L174">		return new RealF(pCard, pR);</span>
	}

	/**
	 * Static divide method that creates a new RealF with the product pF1 / pF2.
	 * &lt;br&gt;
	 * @param pF1 RealF
	 * @param pF2 RealF
	 * @throws FieldBinaryException This exception is thrown when there is a field
	 *                              mismatch.
	 * @return RealF
	 */
	public static RealF divide(RealF pF1, RealF pF2) throws FieldBinaryException {
<span class="pc bpc" id="L187" title="1 of 8 branches missed.">		if (RealF.isTypeMatch(pF1, pF2) &amp;&amp; !RealF.isZero(pF2) &amp;&amp; !RealF.isNaN(pF1) &amp;&amp; !RealF.isNaN(pF2)</span>
<span class="pc bpc" id="L188" title="1 of 4 branches missed.">				&amp;&amp; !RealF.isInfinite(pF1) &amp;&amp; !RealF.isInfinite(pF2))</span>
<span class="fc" id="L189">			return RealF.create(pF1.getCardinal(), pF1.getReal() / pF2.getReal());</span>

<span class="fc" id="L191">		throw (new FieldBinaryException(pF1, &quot;Static Division error found&quot;, pF2));</span>

	}

	/**
	 * Check for the equality of this object with that of the argument. This checks
	 * for exact equality using no tolerances. The FieldObject types must match
	 * first.
	 * &lt;br&gt;
	 * @param pE RealF
	 * @param pF RealF
	 * @return boolean &lt;i&gt;true&lt;/i&gt; if both components are the same; &lt;i&gt;false&lt;/i&gt;,
	 *         otherwise.
	 */
	public static boolean isEqual(RealF pE, RealF pF) {
<span class="fc bfc" id="L206" title="All 4 branches covered.">		return ProtoN.isTypeMatch(pE, pF) &amp;&amp; pE.getReal() == pF.getReal();</span>

	}

	/**
	 * This method checks to see if the value is infinite.
	 * &lt;br&gt;
	 * @param pF RealF
	 * @return boolean
	 */
	public static boolean isInfinite(RealF pF) {
<span class="fc" id="L217">		return Float.isInfinite(pF.getReal());</span>
	}

	/**
	 * This method checks to see if the value is not a number at all. NAN
	 * &lt;br&gt;
	 * @param pF RealF
	 * @return boolean
	 */
	public static boolean isNaN(RealF pF) {
<span class="fc" id="L227">		return Float.isNaN(pF.getReal());</span>
	}

	/**
	 * This method checks to see if the number is exactly zero.
	 * &lt;br&gt;
	 * @param pF RealF
	 * @return boolean
	 */
	public static boolean isZero(RealF pF) {
<span class="fc bfc" id="L237" title="All 2 branches covered.">		return (pF.getReal() == 0.0F);</span>
	}

	/**
	 * Static multiply method that creates a new RealF with the product pF1 * pF2.
	 * product.
	 * &lt;br&gt;
	 * @param pF1 RealF
	 * @param pF2 RealF
	 * @throws FieldBinaryException This exception is thrown when there is a field
	 *                              mismatch.
	 * @return RealF
	 */
	public static RealF multiply(RealF pF1, RealF pF2) throws FieldBinaryException {
<span class="pc bpc" id="L251" title="2 of 8 branches missed.">		if (RealF.isTypeMatch(pF1, pF2) &amp;&amp; !RealF.isNaN(pF1) &amp;&amp; !RealF.isNaN(pF2) &amp;&amp; !RealF.isInfinite(pF1)</span>
<span class="fc bfc" id="L252" title="All 2 branches covered.">				&amp;&amp; !RealF.isInfinite(pF2))</span>
<span class="fc" id="L253">			return RealF.create(pF1.getCardinal(), pF1.getReal() * pF2.getReal());</span>

<span class="fc" id="L255">		throw (new FieldBinaryException(pF1, &quot;Static Multiplication error found&quot;, pF2));</span>
	}

	/**
	 * Static one construction method
	 * &lt;br&gt;
	 * @param pS String
	 * @return RealF
	 */
	public static RealF newONE(String pS) {
<span class="fc" id="L265">		return RealF.create(Cardinal.generate(pS), 1.0F);</span>
	}

	/**
	 * Static zero construction method
	 * &lt;br&gt;
	 * @param pS String
	 * @return RealF
	 */
	public static RealF newZERO(String pS) {
<span class="fc" id="L275">		return RealF.create(Cardinal.generate(pS), 0.0f);</span>
	}

	/**
	 * Static one construction method
	 * &lt;br&gt;
	 * @param pC Cardinal
	 * @return RealF
	 */
	public static RealF newONE(Cardinal pC) {
<span class="fc" id="L285">		return RealF.create(pC, 1.0f);</span>
	}

	/**
	 * Static zero construction method
	 * &lt;br&gt;
	 * @param pC Cardinal
	 * @return RealF
	 */
	public static RealF newZERO(Cardinal pC) {
<span class="fc" id="L295">		return RealF.create(pC, 0.0f);</span>
	}

	/**
	 * Static subtract method that creates a new RealF with the difference pF1-pF2.
	 * &lt;br&gt;
	 * @param pF1 RealF
	 * @param pF2 RealF
	 * @throws FieldBinaryException This exception is thrown when there is a field
	 *                              mismatch.
	 * @return RealF
	 */
	public static RealF subtract(RealF pF1, RealF pF2) throws FieldBinaryException {
<span class="pc bpc" id="L308" title="2 of 8 branches missed.">		if (RealF.isTypeMatch(pF1, pF2) &amp;&amp; !RealF.isNaN(pF1) &amp;&amp; !RealF.isNaN(pF2) &amp;&amp; !RealF.isInfinite(pF1)</span>
<span class="fc bfc" id="L309" title="All 2 branches covered.">				&amp;&amp; !RealF.isInfinite(pF2))</span>
<span class="fc" id="L310">			return RealF.create(pF1.getCardinal(), pF1.getReal() - pF2.getReal());</span>

<span class="fc" id="L312">		throw (new FieldBinaryException(pF1, &quot;Static Subtraction error found&quot;, pF2));</span>
	}

	/**
	 * These are the actual java primitives within the ProtoN child that as as
	 * 'the number.'
	 */
	protected float[] vals;

	/**
	 * Basic Constructor with no values to initialize.
	 */
	public RealF() {
<span class="fc" id="L325">		super(Cardinal.generate(CladosField.REALF));</span>
<span class="fc" id="L326">		vals = new float[1];</span>
<span class="fc" id="L327">		setReal(0.0F);</span>

<span class="fc" id="L329">	}</span>

	/**
	 * Basic Constructor with only the cardinal to initialize.
	 * &lt;br&gt;
	 * @param pT Cardinal
	 */
	public RealF(Cardinal pT) {
<span class="fc" id="L337">		super(pT);</span>
<span class="fc" id="L338">		vals = new float[1];</span>
<span class="fc" id="L339">		setReal(0.0F);</span>

<span class="fc" id="L341">	}</span>

	/**
	 * Basic Constructor with everything to initialize.
	 * &lt;br&gt;
	 * @param pT Cardinal
	 * @param pR float
	 */
	public RealF(Cardinal pT, float pR) {
<span class="fc" id="L350">		super(pT);</span>
<span class="fc" id="L351">		vals = new float[1];</span>
<span class="fc" id="L352">		setReal(pR);</span>

<span class="fc" id="L354">	}</span>

	/**
	 * Basic Constructor with only the number to initialize.
	 * &lt;br&gt;
	 * @param pR float
	 */
	public RealF(float pR) {
<span class="fc" id="L362">		super(Cardinal.generate(CladosField.REALF));</span>
<span class="fc" id="L363">		vals = new float[1];</span>
<span class="fc" id="L364">		setReal(pR);</span>

<span class="fc" id="L366">	}</span>

	/**
	 * Copy Constructor that reuses the cardinal reference.
	 * &lt;br&gt;
	 * @param pR RealF
	 */
	public RealF(RealF pR) {
<span class="fc" id="L374">		super(pR.getCardinal());</span>
<span class="fc" id="L375">		vals = new float[1];</span>
<span class="fc" id="L376">		setReal(pR.getReal());</span>

<span class="fc" id="L378">	}</span>

	/**
	 * Copy Constructor that reuses the cardinal reference while allowing the value
	 * to be set.
	 * &lt;br&gt;
	 * @param pR RealF
	 * @param pF float
	 */
	public RealF(ProtoN pR, float pF) {
<span class="fc" id="L388">		super(pR.getCardinal());</span>
<span class="fc" id="L389">		vals = new float[1];</span>
<span class="fc" id="L390">		setReal(pF);</span>

<span class="fc" id="L392">	}</span>

	/**
	 * This method adds real numbers together and changes this object to be the
	 * result.
	 * &lt;br&gt;
	 * @param pF Field
	 * @throws FieldBinaryException This exception occurs when a field mismatch
	 *                              happens
	 * @return RealF
	 */
	@Override
	public RealF add(Field pF) throws FieldBinaryException {
<span class="pc bpc" id="L405" title="1 of 6 branches missed.">		if (!ProtoN.isTypeMatch(this, (ProtoN) pF) || RealF.isNaN(this) || RealF.isNaN((RealF) pF)</span>
<span class="pc bpc" id="L406" title="1 of 4 branches missed.">				|| RealF.isInfinite(this) || RealF.isInfinite((RealF) pF))</span>
<span class="fc" id="L407">			throw (new FieldBinaryException(this, &quot;Addition failed type match or size test&quot;, (ProtoN) pF));</span>

<span class="fc" id="L409">		setReal(getReal() + ((RealF) pF).getReal());</span>
<span class="fc" id="L410">		return this;</span>
	}

	/**
	 * This is the self-altering conjugate method. This object changes when all of
	 * its imaginary members are set to their additive inverses.
	 * &lt;br&gt;
	 * @return RealF
	 */
	@Override
	public RealF conjugate() {

<span class="fc" id="L422">		return this;</span>
	}

	/**
	 * This method divides real numbers and changes this object to be the result.
	 * &lt;br&gt;
	 * @param pF Field
	 * @throws FieldBinaryException This exception occurs when field mismatches or
	 *                              division by zero happens
	 * @return RealF
	 */
	@Override
	public RealF divide(Field pF) throws FieldBinaryException {
<span class="pc bpc" id="L435" title="1 of 6 branches missed.">		if (!ProtoN.isTypeMatch(this, (ProtoN) pF) || RealF.isNaN(this) || RealF.isNaN((RealF) pF)</span>
<span class="pc bpc" id="L436" title="1 of 4 branches missed.">				|| RealF.isInfinite(this) || RealF.isInfinite((RealF) pF))</span>
<span class="fc" id="L437">			throw (new FieldBinaryException(this, &quot;Divide failed type match or size test&quot;, (ProtoN) pF));</span>
<span class="fc bfc" id="L438" title="All 2 branches covered.">		if (RealF.isZero((RealF) pF))</span>
<span class="fc" id="L439">			throw (new FieldBinaryException(this, &quot;Divide by Zero detected&quot;, (ProtoN) pF));</span>

<span class="fc" id="L441">		setReal(getReal() / ((RealF) pF).getReal());</span>
<span class="fc" id="L442">		return this;</span>
	}

	/**
	 * This is the square root of the SQ Modulus. It is smarter to calculate
	 * SQModulus first.
	 * &lt;br&gt;
	 * @return Float
	 */
	@Override
	public Float modulus() {
<span class="fc" id="L453">		return Float.valueOf((float) Math.sqrt(sqModulus().floatValue()));</span>
	}

	/**
	 * Get the real numeric value from the value array
	 * &lt;br&gt;
	 * @return float
	 */
	public float getReal() {
<span class="fc" id="L462">		return vals[0];</span>
	}

	/**
	 * This function delivers the sum of the squares of the numeric values. Many
	 * times it is the modulus squared that is actually needed so it makes sense to
	 * calculate this before the modulus itself.
	 * &lt;br&gt;
	 * @return Float
	 */
	@Override
	public Float sqModulus() {
<span class="fc" id="L474">		float tR = 0f;</span>
<span class="fc bfc" id="L475" title="All 2 branches covered.">		for (float point : vals)</span>
<span class="fc" id="L476">			tR += point * point;</span>
<span class="fc" id="L477">		return Float.valueOf(tR);</span>
	}

	/**
	 * This method inverts real numbers.
	 * &lt;br&gt;
	 * @throws FieldException This exception is thrown if someone tries to invert a
	 *                        ZERO.
	 * @return RealF
	 */
	@Override
	public RealF invert() throws FieldException {
<span class="fc bfc" id="L489" title="All 2 branches covered.">		if (RealF.isZero(this))</span>
<span class="fc" id="L490">			throw new FieldException(this, &quot;Can't invert a zero RealF&quot;);</span>

<span class="fc" id="L492">		setReal(1.0F / getReal());</span>
<span class="fc" id="L493">		return this;</span>
	}

	/**
	 * This method multiplies real numbers and changes this object to be the result.
	 * &lt;br&gt;
	 * @param pF Field
	 * @throws FieldBinaryException This exception occurs when field mismatches happen
	 * @return RealF
	 */
	@Override
	public RealF multiply(Field pF) throws FieldBinaryException {
<span class="pc bpc" id="L505" title="1 of 6 branches missed.">		if (!ProtoN.isTypeMatch(this, (ProtoN) pF) || RealF.isNaN(this) || RealF.isNaN((RealF) pF)</span>
<span class="pc bpc" id="L506" title="1 of 4 branches missed.">				|| RealF.isInfinite(this) || RealF.isInfinite((RealF) pF))</span>
<span class="fc" id="L507">			throw (new FieldBinaryException(this, &quot;Multiply failed type match or size test&quot;, (ProtoN) pF));</span>

<span class="fc" id="L509">		setReal(getReal() * ((RealF) pF).getReal());</span>
<span class="fc" id="L510">		return this;</span>
	}

	/**
	 * Scale method multiplies the modulus by the scale
	 * &lt;br&gt;
	 * @param pS Number
	 * @return RealF
	 */
	@Override
	public RealF scale(Number pS) {
<span class="fc" id="L521">		setReal(pS.floatValue() * getReal());</span>

<span class="fc" id="L523">		return this;</span>
	}

	/**
	 * Set the real numeric value
	 * &lt;br&gt;
	 * @param preal float
	 */
	public void setReal(float preal) {
<span class="fc" id="L532">		vals[0] = preal;</span>
<span class="fc" id="L533">	}</span>

	/**
	 * This method subtracts real numbers and changes this object to be the result.
	 * &lt;br&gt;
	 * @param pF Field
	 * @throws FieldBinaryException This exception occurs when field mismatches
	 *                              happen
	 * @return RealF
	 */
	@Override
	public RealF subtract(Field pF) throws FieldBinaryException {
<span class="pc bpc" id="L545" title="1 of 6 branches missed.">		if (!ProtoN.isTypeMatch(this, (ProtoN) pF) || RealF.isNaN(this) || RealF.isNaN((RealF) pF)</span>
<span class="pc bpc" id="L546" title="1 of 4 branches missed.">				|| RealF.isInfinite(this) || RealF.isInfinite((RealF) pF))</span>
<span class="fc" id="L547">			throw (new FieldBinaryException(this, &quot;Subtraction failed type match or size test&quot;, (ProtoN) pF));</span>

<span class="fc" id="L549">		setReal(getReal() - ((RealF) pF).getReal());</span>
<span class="fc" id="L550">		return this;</span>
	}

	/**
	 * Return a string representation of the real value.
	 * &lt;br&gt;
	 * @return String
	 */
	@Override
	public String toString() {
<span class="fc" id="L560">		return (getReal() + &quot;FR&quot;);</span>
	}

	/**
	 * Return a string representation of the real value.
	 * &lt;br&gt;
	 * @param pN RealF to be exported as XML.
	 * @return String
	 */
	public final static String toXMLString(RealF pN) {
<span class="fc" id="L570">		return (&quot;&lt;RealF cardinal=\&quot;&quot; + pN.getCardinalString() + &quot;\&quot; realvalue=\&quot;&quot; + pN.getReal() + &quot;\&quot; /&gt;&quot;);</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>