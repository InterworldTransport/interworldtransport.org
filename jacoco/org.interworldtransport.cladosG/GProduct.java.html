<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GProduct.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Clados</a> &gt; <a href="index.source.html" class="el_package">org.interworldtransport.cladosG</a> &gt; <span class="el_source">GProduct.java</span></div><h1>GProduct.java</h1><pre class="source lang-java linenums">/*
 * &lt;h2&gt;Copyright&lt;/h2&gt; Â© 2025 Alfred Differ&lt;br&gt;
 * ------------------------------------------------------------------------ &lt;br&gt;
 * ---org.interworldtransport.cladosG.GProduct&lt;br&gt;
 * -------------------------------------------------------------------- &lt;br&gt;
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version. 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.&lt;br&gt;&lt;br&gt;
 * 
 * Use of this code or executable objects derived from it by the Licensee 
 * states their willingness to accept the terms of the license. &lt;br&gt; &lt;br&gt;
 * 
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.&lt;br&gt; &lt;br&gt;
 * 
 * ------------------------------------------------------------------------ &lt;br&gt;
 * ---org.interworldtransport.cladosG.GProduct&lt;br&gt;
 * ------------------------------------------------------------------------ &lt;br&gt;
 */
package org.interworldtransport.cladosG;

import java.util.Arrays;
import java.util.Optional;
import java.util.stream.IntStream;

import org.interworldtransport.cladosGExceptions.BadSignatureException;

/**
 * This class defines a geometric product on an associated basis within a Clifford Algebra. The flat space on which 
 * multiplication is defined is assumed to be locally tangent to a manifold, but the difference in product results 
 * form one tangent space to another are NOT tracked here. Only the structure of the geometric product on a canonical 
 * basis is. Other distinctions are kept in the algebra objects that reference a GProduct.
 * &lt;br&gt;&lt;br&gt;
 * A GProduct object actually assumes it is OK to perform a requested operation and will throw an exception if it 
 * discovers later that it isn't. This is true most everywhere except in the constructor where input is examined first.
 * &lt;br&gt;&lt;br&gt;
 * Most errors can be avoided by using GBuilder to construct this object. However, it shouldn't be necessary to 
 * construct a GProduct directly. Best practice is to create an algebra and let it construct its product.
 * &lt;br&gt;&lt;br&gt;
 * The implemented interface is currently all the methods available in this class. That will change in the future as 
 * helper methods are built here that need not be exposed elsewhere.
 * &lt;br&gt;&lt;br&gt;
 * @version 2.0
 * @author Dr Alfred W Differ
 */
public class GProduct implements CliffordProduct, Comparable&lt;GProduct&gt; {

	/**
	 * This basis holds a representation of all the elements that can be built from the generators to span the 
	 * algebra's vector space. It is the object that Ken Greider called the Eddington Basis.
	 */
	private final Basis canonBasis;

	/**
	 * This array holds the geometric multiplication table for a Clifford algebra using the associated basis. 
	 * The array contains numbers that represent the blade # one would produce with a product of blades (row) 
	 * and (column) of result.
	 * &lt;br&gt;&lt;br&gt;
	 * Negative results in the array imply the resulting blade is scaled by -1.
	 */
	private final int[][] result;

	/**
	 * This string holds the signature information describing the squares of all geometry generators present on 
	 * the multiplication table.
	 * &lt;br&gt;&lt;br&gt;
	 * The term 'signature' is currently overloaded with meanings. The one being used here is a long form aggregate 
	 * of '+', '-', and '0' characters encoding the squares of an algebra's generators. The short form that reports 
	 * the count for each character as a list of three integers is NOT in use here. That means this signature string 
	 * has the details one expects in a quadratic form after generators have been assigned roles in a basis.
	 */
	private final String signature;

	/**
	 * This array is an integer representation of the signature string. Generators with positive squares are one (1), 
	 * negative squares are minus one (-1), and degenerate ones as (0). The order of the array ALWAYS matches the order
	 * of the generators in the basis.
	 * &lt;br&gt;&lt;br&gt;
	 * This array is kept to increase the speed of product calculations.
	 */
	private final byte[] nSignature;

	/**
	 * Main constructor of GProduct with signature information passed in. It figures out the rest of what it needs.
	 * &lt;br&gt;&lt;br&gt;
	 * @param pSig String form of the signature. Looks like &quot;-+++0&quot;.
	 * @throws BadSignatureException   Thrown when an invalid signature is found
	 */
	public GProduct(String pSig) throws BadSignatureException {
<span class="fc" id="L95">		this(Optional.ofNullable(null), pSig);</span>
<span class="fc" id="L96">	}</span>

	/**
	 * A re-use constructor of GProduct with signature and Basis passed in. It figures out the rest of what it needs.
	 * &lt;br&gt;
	 * The size of the signature string used to be checked using a static method on Basis, but that was duplicating the 
	 * effort performed by CliffordProduct when it checks the validity of the string. Size and characters ARE checked.
	 * &lt;br&gt;
	 * @param pSig String form of the signature. Looks like &quot;-+++0&quot;.
	 * @param pB   Optional Basis to re-use in constructing this product.
	 * @throws BadSignatureException   Thrown when an invalid signature is found
	 */
<span class="fc" id="L108">	public GProduct(Optional&lt;Basis&gt; pB, String pSig) throws BadSignatureException {</span>
<span class="fc bfc" id="L109" title="All 2 branches covered.">		if (!CliffordProduct.validateSignature(pSig))	throw new BadSignatureException(this, &quot;Valid signature required.&quot;);</span>
<span class="fc" id="L110">		signature = pSig;</span>
<span class="fc bfc" id="L111" title="All 2 branches covered.">		nSignature = (pSig.length() == 0) ? new byte[1] : new byte[pSig.length()];				//initialize nSignature[]</span>
<span class="fc" id="L112">		IntStream.range(0, pSig.length()).forEach(i -&gt; {</span>
<span class="pc bpc" id="L113" title="1 of 4 branches missed.">															switch (pSig.charAt(i)){</span>
<span class="fc" id="L114">																case '+' -&gt; nSignature[i] = 1;</span>
<span class="fc" id="L115">																case '0' -&gt; nSignature[i] = 0;</span>
<span class="fc" id="L116">																case '-' -&gt; nSignature[i] = -1;</span>
																}
<span class="fc" id="L118">															});						</span>
<span class="fc bfc" id="L119" title="All 2 branches covered.">		canonBasis = (pB.isPresent()) 	? pB.get() 												//Get A Basis. </span>
<span class="fc" id="L120">										: GBuilder.createBasis((byte) pSig.length());			//Create it if necessary.</span>
<span class="fc" id="L121">		result = new int[getBladeCount()][getBladeCount()];										//Initialize the Cayley Table</span>
<span class="fc" id="L122">		canonBasis.bladeStream().parallel().forEach(bladeLeft -&gt; {								//streaming the row blades</span>
<span class="fc" id="L123">									int row = canonBasis.find(bladeLeft) - 1;					//discover the blade's basis index</span>
<span class="fc" id="L124">									canonBasis.bladeStream().parallel().forEach(bladeRight -&gt; {	//streaming the column blades</span>
<span class="fc" id="L125">													int col = canonBasis.find(bladeRight) - 1;	//discover the blade's basis index</span>
<span class="fc" id="L126">		/* Compute result blade */					Blade bMult = BladeDuet.simplify(bladeLeft, bladeRight, nSignature);</span>
<span class="fc bfc" id="L127" title="All 2 branches covered.">		/* Time to fill the Cayley Table */						result[row][col] = ((int) bMult.sign() != 0)</span>
<span class="fc" id="L128">		/* Discover result blade's basis index &amp; fix sign */	? (int) bMult.sign() * (int) canonBasis.find(bMult)</span>
<span class="fc" id="L129">		/* Result sign was zero */								: 0;							//Degenerate generator paired up</span>
<span class="fc" id="L130">													});											//0 &amp; 1 indicate a scalar blade</span>
<span class="fc" id="L131">									});</span>
<span class="fc" id="L132">	}</span>

	@Override
	public boolean equals(Object obj) {
<span class="fc bfc" id="L136" title="All 2 branches covered.">		if (this == obj)					return true;</span>
<span class="pc bpc" id="L137" title="1 of 2 branches missed.">		if (obj == null)					return false;</span>
<span class="pc bpc" id="L138" title="1 of 2 branches missed.">		if (getClass() != obj.getClass())	return false;</span>
<span class="fc bfc" id="L139" title="All 2 branches covered.">		if (!canonBasis.equals(((GProduct) obj).getBasis()))	return false;</span>
<span class="pc bpc" id="L140" title="1 of 2 branches missed.">		if (!signature.equals(((GProduct) obj).signature))		return false;		</span>
<span class="nc" id="L141">		return true;</span>
	}

	/**
	 * Return a measure of whether blades pj and pk anticommute. Return a 1 if they
	 * anticommute. Return a 0 otherwise.
	 * &lt;br&gt;
	 * @param pRow int
	 * @param pCol int
	 * @return int
	 */
	@Override
	public final int getACommuteSign(int pRow, int pCol) {
<span class="fc bfc" id="L154" title="All 2 branches covered.">		return (result[pRow][pCol] == result[pCol][pRow]) ? 0 : 1;</span>
	}

	/**
	 * Basic Get method for the Basis generated by the signature of this GProduct.
	 * &lt;br&gt;
	 * @return Basis
	 */
	@Override
	public final Basis getBasis() {
<span class="fc" id="L164">		return canonBasis;</span>
	}

	/**
	 * Get the linear dimension of the vector space that uses the associated Basis.
	 * &lt;br&gt;&lt;br&gt;
	 * @return int byte integer of the number of blades in the basis.
	 */
	@Override
	public final int getBladeCount() {
<span class="fc" id="L174">		return canonBasis.getBladeCount();</span>
	}

	/**
	 * Return a measure of whether blades pj and pk commute. Return a 1 if they
	 * commute. Return a 0 otherwise.
	 * &lt;br&gt;&lt;br&gt;
	 * @param pRow int
	 * @param pCol int
	 * @return int +1 if the blades at the row and column commute. 0 otherwise.
	 */
	@Override
	public final int getCommuteSign(int pRow, int pCol) {
<span class="fc bfc" id="L187" title="All 2 branches covered.">		return (result[pRow][pCol] == result[pCol][pRow]) ? 1 : 0;</span>
	}

	/**
	 * This method takes the offered blade and hunts through the Cayley table to find another one such that the offered one 
	 * left multiplied by the other produces the +pscalar blade.
	 * &lt;br&gt;&lt;br&gt;
	 * This method is a brute force search
	 * &lt;br&gt;&lt;br&gt;
	 * @param pB1 Blade for which a complement blade is sought
	 * @return Blade that is the complement of the input blade
	 */
	public final Blade getComplementLeft(Blade pB1) {
<span class="fc" id="L200">		int row = canonBasis.find(pB1) - 1;			//pB1 determines row to hunt through</span>
<span class="fc" id="L201">		int hunt = getBladeCount() - 1;				//index of the pscalar blade... always at the end of the basis.</span>
		
<span class="fc" id="L203">		Optional&lt;Blade&gt; maybeThis = canonBasis	.bladeStream().parallel()</span>
<span class="fc bfc" id="L204" title="All 2 branches covered.">												.filter(b -&gt; Math.abs(result[row][canonBasis.find(b)-1]) - 1 == hunt)</span>
<span class="fc" id="L205">												.findAny();		//THIS IS A BLADE IN THE BASIS. Alter it at your peril.</span>
<span class="fc" id="L206">		byte sign = (byte) getSign(pB1, canonBasis.getPScalarBlade());</span>
<span class="pc bpc" id="L207" title="1 of 4 branches missed.">		if (maybeThis.isPresent())	return maybeThis.get().setSign((sign == 0) ? 1 : sign);</span>
<span class="nc" id="L208">		else						return null;</span>
	}

	/**
	 * This method takes the offered blade and hunts through the Cayley table to find another one such that the offered one 
	 * right multiplied by the other produces the +pscalar blade.
	 * &lt;br&gt;&lt;br&gt;
	 * This method is a brute force search
	 * &lt;br&gt;&lt;br&gt;
	 * @param pB1 Blade for which a complement blade is sought
	 * @return Blade that is the complement of the input blade
	 */
	public final Blade getComplementRight(Blade pB1) {
<span class="fc" id="L221">		int col = canonBasis.find(pB1) - 1;			//pB1 determines column to hunt down</span>
<span class="fc" id="L222">		int hunt = getBladeCount() - 1;				//index of the pscalar blade... always at the end of the basis.</span>

<span class="fc" id="L224">		Optional&lt;Blade&gt; maybeThis = canonBasis	.bladeStream().parallel()</span>
<span class="fc bfc" id="L225" title="All 2 branches covered.">												.filter(b -&gt; Math.abs(result[canonBasis.find(b)-1][col]) - 1 == hunt)</span>
<span class="fc" id="L226">												.findAny();		//THIS IS A BLADE IN THE BASIS. Alter it at your peril.</span>
<span class="fc" id="L227">		byte sign = (byte) getSign(canonBasis.getPScalarBlade(), pB1);</span>
<span class="pc bpc" id="L228" title="2 of 4 branches missed.">		if (maybeThis.isPresent())	return maybeThis.get().setSign((sign == 0) ? 1 : sign);</span>
<span class="nc" id="L229">		else						return null;</span>
	}

	/**
	 * Get the grade count of the algebra that uses this GProduct.
	 * &lt;br&gt;&lt;br&gt;
	 * @return byte integer of the number of grades in the basis.
	 */
	@Override
	public final byte getGradeCount() {
<span class="fc" id="L239">		return canonBasis.getGradeCount();</span>
	}

	/**
	 * Get start and end index from the GradeRange array for grade pGrade.
	 * &lt;br&gt;
	 * There is currently no protection on this method. If someone asks for a grade
	 * that isn't in range, they WILL get -1 in the cells.
	 * &lt;br&gt;
	 * @param pGrade byte primitive = grade for which the range is needed
	 * @return int[] start and end indexes returned as a int[] array
	 */
	@Override
	public final int[] getGradeRange(byte pGrade) {
<span class="fc" id="L253">		int[] tR = new int[2];</span>
<span class="fc" id="L254">		tR[0] = (int) canonBasis.getGradeStart(pGrade);</span>
<span class="fc bfc" id="L255" title="All 2 branches covered.">		tR[1] = (int) ((pGrade == canonBasis.getGradeCount() - 1) // is this MaxGrade? If so, top=bottom</span>
<span class="fc" id="L256">				? tR[0]</span>
<span class="fc" id="L257">				: (canonBasis.getGradeStart((byte) (pGrade + 1)) - 1));</span>
<span class="fc" id="L258">		return tR;</span>
	}

	@Override
	public final int[] getPScalarRange() {
<span class="fc" id="L263">		int[] tR = new int[2];</span>
<span class="fc" id="L264">		tR[0] = canonBasis.getPScalarStart();</span>
<span class="fc" id="L265">		tR[1] = tR[0];</span>
<span class="fc" id="L266">		return tR;</span>
	}

	/**
	 * Return row of result array. Meant for alternate multiplication methods.
	 * &lt;br&gt;
	 * @param pRow int row of the Cayley table requested.
	 * @return int[] integer array that is the requested row of the Cayley table.
	 */
	public final int[] getResult(int pRow) {
<span class="fc" id="L276">		return result[pRow];</span>
	}

	/**
	 * Return an element in the geometric multiplication result table.
	 * &lt;br&gt;
	 * @param pRow int
	 * @param pCol int
	 * @return int
	 */
	@Override
	public final int getResult(int pRow, int pCol) {
<span class="fc" id="L288">		return result[pRow][pCol];</span>
	}

	/**
	 * This method takes two blades, finds their index values in the basis, and then retrieves
	 * the index value of their product from the Cayley table. With the result index, it return the 
	 * basis blade at that location.
	 * &lt;br&gt;&lt;br&gt;
	 * One could just multiply the two blades using BladeDuet.simplify() and get the blade returned.
	 * That's how the Cayley table was constructed in the first place.
	 * &lt;br&gt;&lt;br&gt;
	 * @param pRow 	Blade acting as the row entry for the Cayley table result
	 * @param pCol	Blade acting as the column entry for the Cayley table result
	 * @return Blade representing the result found in the Cayley table. If none found, null is returned.
	 */
	public final Blade getResult(Blade pRow, Blade pCol) {
<span class="pc bpc" id="L304" title="1 of 2 branches missed.">		if (canonBasis.hasBlade(pRow) &amp; canonBasis.hasBlade(pCol)) {</span>
<span class="fc" id="L305">			int p = canonBasis.find(pRow) - 1;</span>
<span class="fc" id="L306">			int q = canonBasis.find(pCol) - 1;	</span>
<span class="fc bfc" id="L307" title="All 2 branches covered.">			return canonBasis.getSingleBlade(	(getResult(p, q)==0) ? 0 : Math.abs(getResult(p, q)) - 1	);	</span>
		}		
<span class="nc" id="L309">		return null;</span>
	}

	/**
	 * Return the sign of an element in the geometric multiplication result table.
	 * &lt;br&gt;
	 * @param pRow int
	 * @param pCol int
	 * @return int
	 */
	@Override
	public final int getSign(int pRow, int pCol) {
<span class="fc bfc" id="L321" title="All 4 branches covered.">		return (result[pRow][pCol] &lt; 0) ? -1 : (result[pRow][pCol] &gt; 0) ? 1 : 0;</span>
	}

	/**
	 * This method takes two blades, finds their index values in the basis, and then retrieves
	 * the sign variation at that location in the Cayley table. 
	 * &lt;br&gt;&lt;br&gt;
	 * @param pRow 	Blade acting as the row entry for the Cayley table result
	 * @param pCol	Blade acting as the column entry for the Cayley table result
	 * @return int representing the sign of the result found in the Cayley table. If none found, 0 is returned.
	 */
	public final int getSign(Blade pRow, Blade pCol) {
<span class="pc bpc" id="L333" title="1 of 2 branches missed.">		if (canonBasis.hasBlade(pRow) &amp; canonBasis.hasBlade(pCol)) {</span>
<span class="fc" id="L334">			int p = canonBasis.find(pRow) - 1;</span>
<span class="fc" id="L335">			int q = canonBasis.find(pCol) - 1;	</span>
<span class="fc" id="L336">			return getSign(p, q);</span>
		}		
<span class="nc" id="L338">		return 0;</span>
	}

	/**
	 * Return the signature of the generating geometry. This lists the squares of the generators in their 
	 * numeric order.
	 * &lt;br&gt;&lt;br&gt;
	 * @return String that is the actual signature of the GProduct.
	 */
	@Override
	public final String signature() {
<span class="fc" id="L349">		return signature;</span>
	}

	/**
	 * This method returns a copy of the byte array that is the signature of this GProduct.
	 * &lt;br&gt;&lt;br&gt;
	 * @return byte array copy of the numeric signature of the GProduct
	 */
	public final byte[] nsignature() {
<span class="nc" id="L358">		return Arrays.copyOf(nSignature, nSignature.length);</span>
	}

	/**
	 * I may need to come up with a better idea here. String comparisons might not be how 
	 * we should compare GP's. They should probably be size first and then string comparisons
	 * that are restricted to p, q, r measures.
	 * @param pIn GProduct the other GP to compare to this one
	 * @return int comparison of the two GProducts
	 */
	@Override
	public int compareTo(GProduct pIn) {
<span class="nc" id="L370">		return signature().compareTo(pIn.signature());</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>