<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GProduct.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Clados</a> &gt; <a href="index.source.html" class="el_package">org.interworldtransport.cladosG</a> &gt; <span class="el_source">GProduct.java</span></div><h1>GProduct.java</h1><pre class="source lang-java linenums">/*
 * &lt;h2&gt;Copyright&lt;/h2&gt; Â© 2025 Alfred Differ&lt;br&gt;
 * ------------------------------------------------------------------------ &lt;br&gt;
 * ---org.interworldtransport.cladosG.GProduct&lt;br&gt;
 * -------------------------------------------------------------------- &lt;br&gt;
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version. 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.&lt;br&gt;&lt;br&gt;
 * 
 * Use of this code or executable objects derived from it by the Licensee 
 * states their willingness to accept the terms of the license. &lt;br&gt; &lt;br&gt;
 * 
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.&lt;br&gt; &lt;br&gt;
 * 
 * ------------------------------------------------------------------------ &lt;br&gt;
 * ---org.interworldtransport.cladosG.GProduct&lt;br&gt;
 * ------------------------------------------------------------------------ &lt;br&gt;
 */
package org.interworldtransport.cladosG;

import java.util.Optional;

import org.interworldtransport.cladosGExceptions.BadSignatureException;

/**
 * This class defines a geometric product on an associated basis within a
 * Clifford Algebra. The flat space on which multiplication is defined is
 * assumed to be locally tangent to a manifold, but the difference in product
 * results form one tangent space to another are NOT tracked here. Only the
 * structure of the geometric product on a canonical basis is. Other
 * distinctions are kept in the algebra objects that reference a GProduct.
 * &lt;br&gt;&lt;br&gt;
 * A GProduct object actually assumes it is OK to perform a requested operation
 * and will throw an exception if it discovers later that it isn't. This is true
 * most everywhere except in the constructor where input is examined first.
 * &lt;br&gt;&lt;br&gt;
 * Most errors can be avoided by using GBuilder to construct this object.
 * However, it shouldn't be necessary to construct a GProduct directly. Best
 * practice is to create an algebra and let it construct its product.
 * &lt;br&gt;&lt;br&gt;
 * The implemented interface is currently all the methods available in this
 * class. That will change in the future as helper methods are built here that
 * need not be exposed elsewhere.
 * &lt;br&gt;&lt;br&gt;
 * @version 2.0
 * @author Dr Alfred W Differ
 */
public class GProduct implements CliffordProduct, Comparable&lt;GProduct&gt; {

	/**
	 * This basis holds a representation of all the elements that can be built from
	 * the generators to span the algebra's vector space. It is the object that Ken
	 * Greider called the Eddington Basis.
	 */
	private final Basis canonBasis;

	/**
	 * This array holds the geometric multiplication table for a Clifford algebra
	 * using the associated basis. The array contains numbers that represent the
	 * blade # one would produce with a product of blades (row) and (column) of
	 * result.
	 * &lt;br&gt;
	 * Negative results in the array imply the resulting blade is scaled by -1.
	 */
	private final int[][] result;

	/**
	 * This string holds the signature information describing the squares of all
	 * geometry generators present on the multiplication table.
	 * &lt;br&gt;
	 * The term 'signature' is currently overloaded with meanings. The one being 
	 * used here is a long form aggregate of '+', '-', and '0' bytes encoding the
	 * squares of an algebra's generators. The short form that adds up the number
	 * for each byte and presents a list of three integers is NOT in use here. 
	 * That means this signature string has the details one expects in a quadratic
	 * form after generators have been assigned roles in a basis.
	 */
	private final String signature;

	/**
	 * This array is an integer representation of the signature string. Generators
	 * with positive squares are one (1), negative squares are minus one (-1), 
	 * and degenerate ones as (0). The order of the array ALWAYS matches the order
	 * of the generators in the basis.
	 * &lt;br&gt;
	 * This array is kept to increase the speed of product calculations.
	 */
	private final byte[] nSignature;

	/**
	 * Main constructor of GProduct with signature information passed in. It
	 * figures out the rest of what it needs.
	 * &lt;br&gt;
	 * @param pSig String form of the signature. Looks like &quot;-+++0&quot;.
	 * @throws BadSignatureException   Thrown when an invalid signature is found
	 */
	public GProduct(String pSig) throws BadSignatureException {
<span class="fc" id="L104">		this(Optional.ofNullable(null), pSig);</span>
<span class="fc" id="L105">	}</span>

	/**
	 * A re-use constructor of GProduct with signature and Basis passed in. It
	 * figures out the rest of what it needs.
	 * &lt;br&gt;
	 * The size of the signature string used to be checked using a static method
	 * on Basis, but that was duplicating the effort performed by CliffordProduct
	 * when it checks the validity of the string. Size and characters ARE checked.
	 * &lt;br&gt;
	 * @param pSig String form of the signature. Looks like &quot;-+++0&quot;.
	 * @param pB   Optional Basis to re-use in constructing this product.
	 * @throws BadSignatureException   Thrown when an invalid signature is found
	 */
<span class="fc" id="L119">	public GProduct(Optional&lt;Basis&gt; pB, String pSig) throws BadSignatureException {</span>
<span class="fc bfc" id="L120" title="All 2 branches covered.">		if (!CliffordProduct.validateSignature(pSig))</span>
<span class="fc" id="L121">			throw new BadSignatureException(this, &quot;Valid signature required.&quot;);</span>
		// ------Init signature
<span class="fc bfc" id="L123" title="All 2 branches covered.">		nSignature = (pSig.length() == 0) ? new byte[1] : new byte[pSig.length()];</span>
<span class="fc" id="L124">		int m = 0;</span>
<span class="fc bfc" id="L125" title="All 2 branches covered.">		for (char b : pSig.toCharArray()) {</span>
<span class="pc bpc" id="L126" title="1 of 4 branches missed.">			switch (b) {</span>
<span class="fc" id="L127">			case '+' -&gt; nSignature[m] = 1;</span>
<span class="fc" id="L128">			case '0' -&gt; nSignature[m] = 0;</span>
<span class="fc" id="L129">			case '-' -&gt; nSignature[m] = -1;</span>
			}
<span class="fc" id="L131">			m++;</span>
		}
<span class="fc" id="L133">		signature = pSig;</span>
		// ------Get Basis
<span class="fc bfc" id="L135" title="All 2 branches covered.">		canonBasis = (pB.isPresent()) ? pB.get() : GBuilder.createBasis((byte) pSig.length());</span>
		// ------Build Product Table
<span class="fc" id="L137">		result = new int[getBladeCount()][getBladeCount()];</span>
<span class="fc" id="L138">		canonBasis.bladeStream().parallel().forEach(bladeLeft -&gt; {</span>
<span class="fc" id="L139">			int row = canonBasis.find(bladeLeft) - 1;</span>
<span class="fc" id="L140">			canonBasis.bladeStream().forEach(bladeRight -&gt; {</span>
<span class="fc" id="L141">				int col = canonBasis.find(bladeRight) - 1;</span>
<span class="fc" id="L142">				Blade bMult = BladeDuet.simplify(bladeLeft, bladeRight, nSignature);</span>
<span class="fc bfc" id="L143" title="All 2 branches covered.">				result[row][col] = ((int) bMult.sign() != 0) ? </span>
<span class="fc" id="L144">							(int) bMult.sign() * (int) canonBasis.find(bMult)</span>
							: 
<span class="fc" id="L146">							0;		//This case happens when the two blades share a generator that is degenerate.</span>
<span class="fc" id="L147">			});</span>
<span class="fc" id="L148">		});</span>
<span class="fc" id="L149">	}</span>

	/**
	 * Return a measure of whether blades pj and pk anticommute. Return a 1 if they
	 * anticommute. Return a 0 otherwise.
	 * &lt;br&gt;
	 * @param pRow int
	 * @param pCol int
	 * @return int
	 */
	@Override
	public final int getACommuteSign(int pRow, int pCol) {
<span class="fc bfc" id="L161" title="All 2 branches covered.">		return (result[pRow][pCol] == result[pCol][pRow]) ? 0 : 1;</span>
	}

	/**
	 * Basic Get method for the Basis generated by the signature of this GProduct.
	 * &lt;br&gt;
	 * @return Basis
	 */
	@Override
	public final Basis getBasis() {
<span class="fc" id="L171">		return canonBasis;</span>
	}

	/**
	 * Get the linear dimension of the vector space that uses the associated Basis.
	 * &lt;br&gt;
	 * @return int
	 */
	@Override
	public final int getBladeCount() {
<span class="fc" id="L181">		return canonBasis.getBladeCount();</span>
	}

	/**
	 * Return a measure of whether blades pj and pk commute. Return a 1 if they
	 * commute. Return a 0 otherwise.
	 * &lt;br&gt;
	 * @param pRow int
	 * @param pCol int
	 * @return int
	 */
	@Override
	public final int getCommuteSign(int pRow, int pCol) {
<span class="fc bfc" id="L194" title="All 2 branches covered.">		return (result[pRow][pCol] == result[pCol][pRow]) ? 1 : 0;</span>
	}

	/**
	 * Get the grade count of the algebra that uses this GProduct.
	 * &lt;br&gt;
	 * @return byte
	 */
	@Override
	public final byte getGradeCount() {
<span class="fc" id="L204">		return canonBasis.getGradeCount();</span>
	}

	/**
	 * Get start and end index from the GradeRange array for grade pGrade.
	 * &lt;br&gt;
	 * There is currently no protection on this method. If someone asks for a grade
	 * that isn't in range, they WILL get -1 in the cells.
	 * &lt;br&gt;
	 * @param pGrade byte primitive = grade for which the range is needed
	 * @return int[] start and end indexes returned as a int[] array
	 */
	@Override
	public final int[] getGradeRange(byte pGrade) {
<span class="fc" id="L218">		int[] tR = new int[2];</span>
<span class="fc" id="L219">		tR[0] = (int) canonBasis.getGradeStart(pGrade);</span>
<span class="fc bfc" id="L220" title="All 2 branches covered.">		tR[1] = (int) ((pGrade == canonBasis.getGradeCount() - 1) // is this MaxGrade? If so, top=bottom</span>
<span class="fc" id="L221">				? tR[0]</span>
<span class="fc" id="L222">				: (canonBasis.getGradeStart((byte) (pGrade + 1)) - 1));</span>
<span class="fc" id="L223">		return tR;</span>
	}

	@Override
	public final int[] getPScalarRange() {
<span class="fc" id="L228">		int[] tR = new int[2];</span>
<span class="fc" id="L229">		tR[0] = canonBasis.getPScalarStart();</span>
<span class="fc" id="L230">		tR[1] = tR[0];</span>
<span class="fc" id="L231">		return tR;</span>
	}

	/**
	 * Return row of result array. Meant for alternate multiplication methods.
	 * &lt;br&gt;
	 * @param pRow int
	 * @return int[][]
	 */
	public final int[] getResult(int pRow) {
<span class="fc" id="L241">		return result[pRow];</span>
	}

	/**
	 * Return an element in the geometric multiplication result table.
	 * &lt;br&gt;
	 * @param pRow int
	 * @param pCol int
	 * @return int
	 */
	@Override
	public final int getResult(int pRow, int pCol) {
<span class="fc" id="L253">		return result[pRow][pCol];</span>
	}

	/**
	 * This method takes two blades, finds their index values in the basis, and then retrieves
	 * the index value of their product from the Cayley table. With the result index, it return the 
	 * basis blade at that location.
	 * &lt;br&gt;&lt;br&gt;
	 * One could just multiply the two blades using BladeDuet.simplify() and get the blade returned.
	 * That's how the Cayley table was constructed in the first place.
	 * &lt;br&gt;&lt;br&gt;
	 * @param pRow 	Blade acting as the row entry for the Cayley table result
	 * @param pCol	Blade acting as the column entry for the Cayley table result
	 * @return Blade representing the result found in the Cayley table. If none found, null is returned.
	 */
	public final Blade getResult(Blade pRow, Blade pCol) {
<span class="pc bpc" id="L269" title="1 of 2 branches missed.">		if (canonBasis.hasBlade(pRow) &amp; canonBasis.hasBlade(pCol)) {</span>
<span class="fc" id="L270">			int p = canonBasis.find(pRow) - 1;</span>
<span class="fc" id="L271">			int q = canonBasis.find(pCol) - 1;	</span>
<span class="fc bfc" id="L272" title="All 2 branches covered.">			return canonBasis.getSingleBlade(	(getResult(p, q)==0) ? 0 : Math.abs(getResult(p, q)) - 1	);	</span>
		}		
<span class="nc" id="L274">		return null;</span>
	}

	/**
	 * Return the sign of an element in the geometric multiplication result table.
	 * &lt;br&gt;
	 * @param pRow int
	 * @param pCol int
	 * @return int
	 */
	@Override
	public final int getSign(int pRow, int pCol) {
<span class="fc bfc" id="L286" title="All 4 branches covered.">		return (result[pRow][pCol] &lt; 0) ? -1 : (result[pRow][pCol] &gt; 0) ? 1 : 0;</span>
	}

	/**
	 * This method takes two blades, finds their index values in the basis, and then retrieves
	 * the sign variation at that location in the Cayley table. 
	 * &lt;br&gt;&lt;br&gt;
	 * @param pRow 	Blade acting as the row entry for the Cayley table result
	 * @param pCol	Blade acting as the column entry for the Cayley table result
	 * @return int representing the sign of the result found in the Cayley table. If none found, 0 is returned.
	 */
	public final int getSign(Blade pRow, Blade pCol) {
<span class="pc bpc" id="L298" title="1 of 2 branches missed.">		if (canonBasis.hasBlade(pRow) &amp; canonBasis.hasBlade(pCol)) {</span>
<span class="fc" id="L299">			int p = canonBasis.find(pRow) - 1;</span>
<span class="fc" id="L300">			int q = canonBasis.find(pCol) - 1;	</span>
<span class="fc" id="L301">			return getSign(p, q);</span>
			//return canonBasis.getSingleBlade(	(getResult(p, q)==0) ? 0 : Math.abs(getResult(p, q)) - 1	);	
		}		
<span class="nc" id="L304">		return 0;</span>
	}


	/**
	 * Return the signature of the generating geometry. This lists the squares of the
	 * generators in their numeric order.
	 * &lt;br&gt;
	 * @return String
	 */
	@Override
	public final String signature() {
<span class="fc" id="L316">		return signature;</span>
	}

	/**
	 * This method produces a printable and parseable string that represents the
	 * Basis in a human readable form.
	 * &lt;br&gt;
	 * @param pG A geometric product to be exported to XML
	 * @param indent A string to use for XML element intentation. Not required.
	 * @return String This is the XML string export of an object.
	 */
	public final static String toXMLString(GProduct pG, String indent) {
<span class="pc bpc" id="L328" title="1 of 2 branches missed.">		if (indent == null)			indent = &quot;\t\t\t\t\t&quot;;</span>
<span class="fc" id="L329">		StringBuilder rB = new StringBuilder(indent + &quot;&lt;GProduct signature=\&quot;&quot;+pG.signature()+&quot;\&quot;&gt;\n&quot;);</span>
<span class="fc" id="L330">		rB	.append(Basis.toXMLString(pG.getBasis(), indent + &quot;\t&quot;));</span>
<span class="fc" id="L331">		rB	.append(indent)</span>
<span class="fc" id="L332">			.append(&quot;\t&lt;CayleyTable rows=\&quot;&quot;)</span>
<span class="fc" id="L333">			.append(pG.getBladeCount())</span>
<span class="fc" id="L334">			.append(&quot;\&quot;&gt;\n&quot;);</span>
<span class="fc bfc" id="L335" title="All 2 branches covered.">		for (int k = 0; k &lt; pG.getBladeCount(); k++) {		// Appending rows of the Cayley table</span>
<span class="fc" id="L336">			rB	.append(indent)</span>
<span class="fc" id="L337">				.append(&quot;\t\t&lt;row id=\&quot;&quot;)</span>
<span class="fc" id="L338">				.append(k)</span>
<span class="fc" id="L339">				.append(&quot;\&quot; cells=\&quot;&quot;);</span>
<span class="fc bfc" id="L340" title="All 2 branches covered.">			for (int m = 0; m &lt; pG.getBladeCount(); m++)</span>
<span class="fc" id="L341">				rB	.append(pG.getResult(k, m))</span>
<span class="fc" id="L342">					.append(&quot;,&quot;);</span>
<span class="fc" id="L343">			rB.deleteCharAt(rB.length() - 1);</span>
<span class="fc" id="L344">			rB.append(&quot;\&quot; /&gt;\n&quot;);</span>
		}
<span class="fc" id="L346">		rB.append(indent + &quot;\t&lt;/CayleyTable&gt;\n&quot;);</span>
<span class="fc" id="L347">		rB.append(indent + &quot;&lt;/GProduct&gt;\n&quot;);</span>
<span class="fc" id="L348">		return rB.toString();</span>
	}

	/**
	 * I may need to come up with a better idea here. String comparisons might not be how 
	 * we should compare GP's. They should probably be size first and then string comparisons
	 * that are restricted to p, q, r measures.
	 * @param pIn GProduct the other GP to compare to this one
	 * @return int comparison of the two GProducts
	 */
	@Override
	public int compareTo(GProduct pIn) {
<span class="nc" id="L360">		return signature().compareTo(pIn.signature());</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>