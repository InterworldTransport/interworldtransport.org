<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Monad.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Clados</a> &gt; <a href="index.source.html" class="el_package">org.interworldtransport.cladosG</a> &gt; <span class="el_source">Monad.java</span></div><h1>Monad.java</h1><pre class="source lang-java linenums">/*
 * &lt;h2&gt;Copyright&lt;/h2&gt; Â© 2025 Alfred Differ&lt;br&gt;
 * ------------------------------------------------------------------------ &lt;br&gt;
 * ---org.interworldtransport.cladosG.Monad&lt;br&gt;
 * -------------------------------------------------------------------- &lt;br&gt;
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version. 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.&lt;br&gt;&lt;br&gt;
 * 
 * Use of this code or executable objects derived from it by the Licensee 
 * states their willingness to accept the terms of the license. &lt;br&gt; &lt;br&gt;
 * 
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.&lt;br&gt; &lt;br&gt;
 * 
 * ------------------------------------------------------------------------ &lt;br&gt;
 * ---org.interworldtransport.cladosG.Monad&lt;br&gt;
 * ------------------------------------------------------------------------ &lt;br&gt;
 */
package org.interworldtransport.cladosG;

import java.util.Optional;
import java.util.stream.IntStream;
import java.util.stream.Stream;

import static org.interworldtransport.cladosG.CladosConstant.*;

import org.interworldtransport.cladosF.FBuilder;		//Number builder
import org.interworldtransport.cladosF.FListBuilder;	//List of numbers builder
import org.interworldtransport.cladosF.CladosField;		//Numeric modes enumerated
import org.interworldtransport.cladosF.ComplexD;		//Complex doubles
import org.interworldtransport.cladosF.ComplexF;		//Complex floats
import org.interworldtransport.cladosF.RealD;			//Real doubles
import org.interworldtransport.cladosF.RealF;			//Real floats
import org.interworldtransport.cladosF.ProtoN;			//Unitized Number parent
import org.interworldtransport.cladosF.Field;			//Contract specifying division field
import org.interworldtransport.cladosF.Normalizable;	//Contract for modulus construction
														//Numbers obeying both contracts
														//are used as monad weights.

import org.interworldtransport.cladosFExceptions.FieldBinaryException;
import org.interworldtransport.cladosFExceptions.FieldException;
import org.interworldtransport.cladosGExceptions.BadSignatureException;
import org.interworldtransport.cladosGExceptions.CladosMonadException;
import org.interworldtransport.cladosGExceptions.GeneratorRangeException;

/**
 * A CladosG Monad is better known as a multivector to anyone with experience
 * with geometric algebras. Think of them as vectors, but with higher ranked
 * elements also represented. There is more to it than that, but that is the
 * nutshell version.
 * &lt;br&gt;&lt;br&gt;
 * Caution | To the software community, 'vector' is generally understood to be a
 * dynamic array data structure. To a physicist, it is a thing that belongs to a
 * vector space and follows extra rules regarding allowed transformations. It's
 * 'thing' nature is much more important than how it acts as a data structure.
 * &lt;br&gt;&lt;br&gt;
 * The 'allowed' transformations are operations that do not change the 'thing'
 * nature of the object represented. For example, a meter stick is what it is no
 * matter how a coordinate system used to represent it is rotated. A
 * representation of the meter stick would have to be identifiable as the same
 * thing after a rotation, meaning many apparently different sets of data in the
 * structure are actually the same thing.
 * &lt;br&gt;&lt;br&gt;
 * A 'multivector' can represent 'things' that are of higher geometric rank than
 * lines. A monad has a data structure inside to support both coordinates and
 * reference information. 'Allowed' transformations on the reference frame
 * should cause the coefficients to shift the correct way leaving the monad as
 * it was from an external perspective. That's HOW a monad represents a thing.
 * It is expected to be invariant under 'allowed' transformations of the
 * contained data.
 * &lt;br&gt;&lt;br&gt;
 * Why 'monad' instead of 'multivector'? Try typing it yourself a few thousand
 * times and you'll understand. The name doesn't actually matter, but it is from
 * an old tradition when physicists wrote linear transformations as dyads. Two
 * vectors were written side by side, but no simplifying action could be taken.
 * The dyad was described as an operator, so the vectors were applied to another
 * operand rather than each other. Few textbooks do that anymore (we have matrix
 * algebra now) and the name has fallen into dis-use. It is revived here because
 * we need something short and useful. A 'dyad' will be two monads in a list
 * which is generalized in another CladosG class called nyad.
 * &lt;br&gt;&lt;br&gt;
 * Doesn't 'monad' conflict with mathemetician's usage in Category Theory and
 * with Functional Programming advocates bringing that mathematics to the real
 * world? Yes. What the functional programmers are doing is terribly important,
 * so don't confuse their monad with what a physicist needs. This shouldn't be
 * too hard. Y'all have been doing it for 'vector' for a few decades. You'd
 * rather something else? 'Unad'? Make your case by helping out.
 * &lt;br&gt;&lt;br&gt;
 * NOTE | Regarding suppressed unchecked type casting warnings, they are
 * restricted to the casting that happens in FBuilder and
 * CladosFListBuilder classes mostly. This happens when we copy number objects
 * to avoid mutability using a generic copyOf() method. As long as the
 * coefficients in a monad are valid ProtoN children implementing Field
 * and Normalizable, the copyOf() functions will work fine. There are two cases
 * where things can go awry, though.
 * &lt;br&gt;&lt;br&gt;
 * 1. It is probably possible for someone to mix ProtoN children in a
 * Scale object containing a mondad's coefficients. The copyOf() functions will
 * faithfully copy them as they are. The scale() methods and others will
 * faithfully pass them to a Scale object to be used as appropriate there. For
 * example, Scale's scale() method will try to use them as given. What
 * happens, though, is the inbound number gets multiplied against others AS THEY
 * UNDERSTAND MULTIPLICATION. Scaling a complex by a real will work all right
 * unless one thought the scaling was between two complex numbers. THAT'S why
 * Scale AND Monad implement Modal, but nothing is enforced yet.
 * &lt;br&gt;&lt;br&gt;
 * 2. If someone invents a new ProtoN child, there is a ton of work to do
 * as the builders and other enumerations have to be adapted. Any class
 * implementing Modal might have methods that switch on CladosField values.
 * So... be cautious about inventing new CladosF numbers. Lots of work will have
 * to be done.
 * &lt;br&gt;&lt;br&gt;
 * @version 2.0
 * @author Dr Alfred W Differ
 */
public class Monad implements Modal {
	/**
	 * Return a boolean if the grade being checked is non-zero in the Monad.
	 * &lt;br&gt;
	 * The grade key is checked using a bit of trickery with integer math.
	 * Divide the key by 10^grade and toss the remainder. If the result is odd
	 * the grade is present. If even, it isn't. The depends on the technique used
	 * to build the key in the first place.
	 * @param pM     Monad
	 * @param pGrade int
	 * @return boolean
	 */
	public static boolean hasGrade(Monad pM, int pGrade) {
<span class="fc bfc" id="L135" title="All 6 branches covered.">		if (pM.getGradeKey() == 1 &amp; pGrade == 0) 	//Monads have scalar parts</span>
<span class="fc" id="L136">			return true;							//if they have no other parts</span>
<span class="fc bfc" id="L137" title="All 2 branches covered.">		if (((long) (pM.getGradeKey()) / ((long) Math.pow(10, pGrade))) % 2 == 1)</span>
<span class="fc" id="L138">			return true;</span>

<span class="fc" id="L140">		return false;</span>
	}

	/**
	 * Return a boolean if the grade being checked is the grade of the Monad. False
	 * is returned otherwise.
	 * &lt;br&gt;
	 * The grade key is checked. A simple power of 10 is a single grade. No special 
	 * carve-out is needed for the scalar because 10^0 == 1.
	 * &lt;br&gt;
	 * @param pM     Monad
	 * @param pGrade int
	 * @return boolean
	 */
	public static boolean isGrade(Monad pM, int pGrade) {
<span class="fc bfc" id="L155" title="All 2 branches covered.">		if (Math.pow(10, pGrade) == pM.getGradeKey())</span>
<span class="fc" id="L156">			return true;</span>

<span class="fc" id="L158">		return false;</span>
	}

	/**
	 * Return true if more the monad is a ZERO scalar.
	 * &lt;br&gt;
	 * @param pM MonadComplexD This is the monad to be tested.
	 * @return boolean
	 */
	public static boolean isGZero(Monad pM) {
<span class="fc bfc" id="L168" title="All 2 branches covered.">		return (pM.getGradeKey() == 1 &amp; pM.getWeights().isScalarZero());</span>
	}

	/**
	 * Return true if the Monad an idempotent
	 * &lt;br&gt;
	 * @return boolean
	 * @param pM Monad
	 */
	public static boolean isIdempotent(Monad pM) {
<span class="fc bfc" id="L178" title="All 2 branches covered.">		if (isGZero(pM))</span>
<span class="fc" id="L179">			return true;</span>
<span class="fc" id="L180">		return (GBuilder.copyOfMonad(pM)).multiplyLeft(pM).isGEqual(pM);</span>
	}

	/**
	 * Return true if the Monad is a multiple of an idempotent
	 * &lt;br&gt;
	 * The strategy for this method is as follows.
	 * &lt;br&gt;
	 * 1. If the monad is an actual idempotent, return true. This is trivial case.
	 * 2. If not, find first non-zero coefficient of the square of the monad and...
	 * a) re-scale monad by inverse of that coefficient. Use copy to avoid change.
	 * b) test the re-scaled monad to see if it is idenpotent. If so, return true.
	 * 3. Return false.
	 * &lt;br&gt;
	 * Since the map internal to a Monad's Scale can accept any of the CladosF
	 * numbers as values, there is a cast to a 'generic' type within this method.
	 * This would normally cause warnings by the compiler since the generic named in
	 * the internal map IS a ProtoN child AND casting an unchecked type could
	 * fail at runtime.
	 * &lt;br&gt;
	 * That won't happen here when CladosF builders are used. They can't build
	 * anything that is NOT a ProtoN child. They can't even build a
	 * ProtoN instance directly. Therefore, only children can arrive as the
	 * value parameter of the 'put' function. Thus, there is no danger of a failed
	 * cast operation... until someone creates a new ProtoN child class and
	 * fails to update all builders.
	 * &lt;br&gt;
	 * @param pM  Monad
	 * @param &lt;T&gt; ProtoN number from CladosF with all interfaces this time.
	 * @return boolean
	 * @throws FieldException This exception is thrown when the method can't copy
	 *                        the field used by the monad to be checked.
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public static &lt;T extends ProtoN &amp; Field &amp; Normalizable&gt; boolean isScaledIdempotent(Monad pM)
			throws FieldException {
<span class="fc bfc" id="L216" title="All 2 branches covered.">		if (isIdempotent(pM))</span>
<span class="fc" id="L217">			return true;</span>
<span class="fc bfc" id="L218" title="All 2 branches covered.">		else if (Monad.isNilpotent(pM, 2))</span>
<span class="fc" id="L219">			return false;</span>

<span class="fc" id="L221">		Monad check1 = GBuilder.copyOfMonad(pM);</span>
<span class="fc" id="L222">		check1.multiplyLeft(check1);</span>
<span class="fc" id="L223">		Optional&lt;Blade&gt; first = check1.bladeStream().filter(blade -&gt; </span>
<span class="fc" id="L224">									check1.getWeights().isNotZeroAt(blade)).sequential().findFirst();</span>
<span class="pc bpc" id="L225" title="1 of 2 branches missed.">		if (first.isPresent())</span>
<span class="fc" id="L226">			return isIdempotent(GBuilder.copyOfMonad(pM)</span>
<span class="fc" id="L227">									.scale((T) FBuilder.copyOf(check1.getWeights().get(first.get()))</span>
<span class="fc" id="L228">										.invert()));</span>
<span class="nc" id="L229">		return false;</span>
	}

	/**
	 * Return true if the Monad is nilpotent at a particular integer power.
	 * &lt;br&gt;
	 * @return boolean
	 * @param pM     Monad The monad to be tested
	 * @param pPower int The integer power to test
	 */
	public static boolean isNilpotent(Monad pM, int pPower) {
<span class="fc bfc" id="L240" title="All 2 branches covered.">		if (isGZero(pM))</span>
<span class="fc" id="L241">			return true;</span>
<span class="fc" id="L242">		Monad check1 = GBuilder.copyOfMonad(pM);</span>
<span class="fc bfc" id="L243" title="All 2 branches covered.">		while (pPower &gt; 1) {</span>
<span class="fc" id="L244">			check1.multiplyLeft(pM);</span>
<span class="fc bfc" id="L245" title="All 2 branches covered.">			if (isGZero(check1))</span>
<span class="fc" id="L246">				return true;</span>
<span class="fc" id="L247">			pPower--;</span>
		}
<span class="fc" id="L249">		return false;</span>
	}

	/**
	 * Return true if more than one blade is present in the Monad. This method makes
	 * use of the grade key which is a sum of powers of 10, thus the base-10
	 * logarithm will be an integer for pure grade monads and a non-integer for
	 * multigrade monads.
	 * &lt;br&gt;
	 * @param pM This parameter offers the Monad being tested.
	 * @return boolean
	 */
	public static boolean isMultiGrade(Monad pM) {
<span class="pc bpc" id="L262" title="1 of 2 branches missed.">		if (pM.getGradeKey() == 0)	//Special case should never happen, </span>
<span class="nc" id="L263">			return false;			//but if it does it is fatal.</span>
<span class="fc" id="L264">		float temp = (float) Math.log10(pM.getGradeKey());</span>
<span class="fc bfc" id="L265" title="All 2 branches covered.">		if (Math.floor(temp) == temp)	//This avoids precision trap?</span>
<span class="fc" id="L266">			return false;</span>

<span class="fc" id="L268">		return true;</span>
	}

	/**
	 * Return true if the monads share the same algebra, modes, and cardinal/units.
	 * &lt;br&gt;
	 * A check is made on Algebra, Mode, and Scale Cardinals for equality. No check is made for equality 
	 * between the monad names, numeric weights, and the Cayley Table.
	 * &lt;br&gt;
	 * @param pM Monad to be tested
	 * @param pN Monad to be tested
	 * @return boolean True if they pass algebra and cardinal/unit match tests
	 */
	public static boolean isReferenceMatch(Monad pM, Monad pN) {
		
<span class="fc bfc" id="L283" title="All 2 branches covered.">		if (pM.getAlgebra() != pN.getAlgebra())		// The algebras must be the same object to match.</span>
<span class="fc" id="L284">			return false;							// If they are not, this test fails.</span>

<span class="fc" id="L286">		return Monad.isUnitMatch(pM, pN);			// The weights might share different cardinals or modes.</span>
													// If so, we'd be comparing apples to oranges.
	}

	/**
	 * Return true if one blade is present in the Monad. This method makes use of
	 * the grade key which is a sum of powers of 10, thus the base-10 logarithm will
	 * be an integer for pure grade monads and a non-integer for multigrade monads.
	 * &lt;br&gt;
	 * @param pM This parameter offers the Monad being tested.
	 * @return boolean
	 */
	public static boolean isUniGrade(Monad pM) {
<span class="pc bpc" id="L299" title="1 of 2 branches missed.">		if (pM.getGradeKey() == 0)	//Special case should never happen, </span>
<span class="nc" id="L300">			return false;			//but if it does it is fatal.</span>
<span class="fc" id="L301">		float temp = (float) Math.log10(pM.getGradeKey());</span>
<span class="fc bfc" id="L302" title="All 2 branches covered.">		if (Math.floor(temp) == temp)	//This avoids precision trap?</span>
<span class="fc" id="L303">			return true;</span>

<span class="fc" id="L305">		return false;</span>
	}

	/**
	 * Return true if the monads share the same Cardinal/units and Mode
	 * A check is made on Scale Cardinals for equality. No check is made for equality 
	 * between the monad names, numeric weights, and algebras.
	 * &lt;br&gt;
	 * @param pM Monad to be tested
	 * @param pN Monad to be tested
	 * @return boolean True if they pass cardinal/unit match test
	 */
	public static boolean isUnitMatch(Monad pM, Monad pN) {
<span class="pc bpc" id="L318" title="1 of 2 branches missed.">		if (pM.getMode() != pN.getMode() )			</span>
<span class="nc" id="L319">			return false;							// Modes must match to avoid FieldBinaryExceptions elsewhere.</span>
													// If they don't, this test fails.

<span class="fc" id="L322">		return pM.getWeights().getCardinal().equals(pN.getWeights().getCardinal());</span>
													// The weights might share different cardinals.
													// If so, we'd be comparing apples to oranges elsewhere.

		
			
	}

	/**
	 * Display XML string that represents the Monad
	 * &lt;br&gt;
	 * @param pM     MonadRealF This is the monad to be converted to XML.
	 * @param indent String of tab characters to assign with human readability
	 * @return String
	 */
	public final static String toXMLFullString(Monad pM, String indent) {
<span class="pc bpc" id="L338" title="1 of 2 branches missed.">		if (indent == null)</span>
<span class="nc" id="L339">			indent = &quot;\t\t\t&quot;;</span>
<span class="fc" id="L340">		StringBuilder rB = (new StringBuilder(indent + &quot;&lt;Monad &quot;))</span>
<span class="fc" id="L341">			.append(&quot;gradeKey=\&quot;&quot;)</span>
<span class="fc" id="L342">			.append(pM.getGradeKey())</span>
<span class="fc" id="L343">			.append(&quot;\&quot; &quot;)</span>
<span class="fc" id="L344">			.append(&quot;sparseFlag=\&quot;&quot;)</span>
<span class="fc" id="L345">			.append(pM.getSparseFlag())</span>
<span class="fc" id="L346">			.append(&quot;\&quot; &quot;)</span>
<span class="fc" id="L347">			.append(&quot;&gt;\n&quot;);</span>
<span class="fc" id="L348">		rB.append(indent + &quot;\t&lt;Name&gt;&quot;)</span>
<span class="fc" id="L349">			.append(pM.getName())</span>
<span class="fc" id="L350">			.append(&quot;&lt;/Name&gt;\n&quot;);</span>
<span class="fc" id="L351">		rB.append(Algebra.toXMLString(pM.getAlgebra(), indent + &quot;\t&quot;));</span>
<span class="fc" id="L352">		rB.append(indent)</span>
<span class="fc" id="L353">			.append(Scale.toXMLString(pM.scales, &quot;\t&quot;));</span>
<span class="fc" id="L354">		rB.append(indent + &quot;&lt;/Monad&gt;\n&quot;);</span>
<span class="fc" id="L355">		return rB.toString();</span>
	}

	/**
	 * Display XML string that represents the Monad
	 * &lt;br&gt;
	 * @param pM     Monad This is the monad to be converted to XML.
	 * @param indent String of tab characters to assign with human readability
	 * @return String
	 */
	public final static String toXMLString(Monad pM, String indent) {
<span class="pc bpc" id="L366" title="1 of 2 branches missed.">		if (indent == null)</span>
<span class="nc" id="L367">			indent = &quot;\t\t\t&quot;;</span>
<span class="fc" id="L368">		StringBuilder rB = new StringBuilder(indent + &quot;&lt;Monad &quot;);</span>
<span class="fc" id="L369">		rB.append(&quot;algebra=\&quot;&quot;)</span>
<span class="fc" id="L370">			.append(pM.getAlgebra().getAlgebraName())</span>
<span class="fc" id="L371">			.append(&quot;\&quot; &quot;);</span>
<span class="fc" id="L372">		rB.append(&quot;gradeKey=\&quot;&quot;)	</span>
<span class="fc" id="L373">			.append(pM.getGradeKey())</span>
<span class="fc" id="L374">			.append(&quot;\&quot; &quot;)</span>
<span class="fc" id="L375">			.append(&quot;sparseFlag=\&quot;&quot;)</span>
<span class="fc" id="L376">			.append(pM.getSparseFlag())</span>
<span class="fc" id="L377">			.append(&quot;\&quot; &quot;)</span>
<span class="fc" id="L378">			.append(&quot;&gt;\n&quot;);</span>
<span class="fc" id="L379">		rB.append(indent + &quot;\t&lt;Name&gt;&quot;)</span>
<span class="fc" id="L380">			.append(pM.getName())</span>
<span class="fc" id="L381">			.append(&quot;&lt;/Name&gt;\n&quot;);</span>
<span class="fc" id="L382">		rB.append(indent)</span>
<span class="fc" id="L383">			.append(Scale.toXMLString(pM.scales, &quot;\t&quot;));</span>
<span class="fc" id="L384">		rB.append(indent + &quot;&lt;/Monad&gt;\n&quot;);</span>
<span class="fc" id="L385">		return rB.toString();</span>
	}

	/**
	 * All clados objects are elements of some algebra. That algebra has a name.
	 */
	protected Algebra algebra;

	/*
	 * Grades found among the parts of this monad.
	 */
	private byte foundGrades;

	/**
	 * This long holds a key that shows which grades are present in the monad. The
	 * key is a sum over powers of 10 with the grade as the exponent.
	 */
	private long gradeKey;

	/**
	 * All objects of this class have a name independent of all other features.
	 */
	private String name;

	/**
	 * This is the new coefficient 'array'. It's size should always match
	 * bladeCount. It is keyed to the blades in a monad's basis. It is fundamentally
	 * an IdentityHashMap with some frosting.
	 */
	protected Scale&lt;? extends ProtoN&gt; scales;

	/**
	 * This boolean is a flag used internally by multiplication methods to make
	 * those methods a little more efficient. A sparse monad has mostly zero
	 * coefficients and is directed to multiply grade by grade instead of using the
	 * generic algorithm.
	 */
<span class="fc" id="L422">	protected boolean sparseFlag = true;</span>

	/**
	 * Simple copy constructor of Monad. Passed Monad will be copied in all details.
	 * This contructor is used most often to get around operations that alter a
	 * Monad when the developer does not wish it to be altered.
	 * &lt;br&gt;
	 * @param &lt;T&gt; CladosF number is a ProtoN child that implemnts Field and
	 *            Normalizable.
	 * @param pM  Monad
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L434">	public &lt;T extends ProtoN &amp; Field &amp; Normalizable&gt; Monad(Monad pM) {</span>
<span class="fc" id="L435">		setName(pM.getName());</span>
<span class="fc" id="L436">		setAlgebra(pM.getAlgebra());</span>
<span class="fc" id="L437">		scales = new Scale&lt;T&gt;((Scale&lt;T&gt;) pM.getWeights());</span>
<span class="fc" id="L438">		setGradeKey();</span>
<span class="fc" id="L439">	}</span>

	/**
	 * Main copy constructor of Monad. Passed Monad will be copied in all details
	 * except its name. This constructor is used most often as a starting point to
	 * generate new Monads based on an old one.
	 * &lt;br&gt;
	 * @param pName String
	 * @param pM    Monad
	 */
	public Monad(String pName, Monad pM) {
<span class="fc" id="L450">		this(pM);			//Defer to constructor #1</span>
<span class="fc" id="L451">		setName(pName);</span>
<span class="fc" id="L452">	}</span>

	/**
	 * Special constructor of Monad with most information passed in. This one will
	 * create the default 'Zero' Monad.
	 * &lt;br&gt;
	 * @param &lt;T&gt;          CladosF number is a ProtoN child that implemnts
	 *                     Field and Normalizable.
	 * @param pMonadName   String
	 * @param pAlgebraName String
	 * @param pFootName    String
	 * @param pSig         String
	 * @param pF           ProtoN Used to construct number
	 * @throws BadSignatureException   This exception is thrown if the signature
	 *                                 string offered is rejected.
	 * @throws CladosMonadException    This exception is thrown if there is an issue
	 *                                 with the coefficients offered. The issues
	 *                                 could involve null coefficients or a
	 *                                 coefficient array of the wrong size.
	 * @throws GeneratorRangeException This exception is thrown when the integer
	 *                                 number of generators for the basis is out of
	 *                                 the supported range. {0, 1, 2, ..., 14}
	 */
	public &lt;T extends ProtoN &amp; Field &amp; Normalizable&gt; Monad(	String pMonadName, 
															String pAlgebraName,
															String pFootName, 
															String pSig, 
															T pF)
			throws BadSignatureException, CladosMonadException, GeneratorRangeException {
<span class="fc" id="L481">		this(	pMonadName, </span>
				pAlgebraName,
<span class="fc" id="L483">				GBuilder.createFootLike(pFootName, pF), </span>
				pSig, 
				pF);		//Defer to constructor #4
<span class="fc" id="L486">	}</span>

	/**
	 * Special constructor of Monad with most information passed in. This one will
	 * create a default 'Zero' Monad while re-using the Foot of another.
	 * &lt;br&gt;
	 * @param &lt;T&gt;          CladosF number is a ProtoN child that implemnts
	 *                     Field and Normalizable.
	 * @param pMonadName   String
	 * @param pAlgebraName String
	 * @param pFoot        Foot
	 * @param pSig         String
	 * @param pF           T generic for a CladosF number
	 * @throws BadSignatureException   This exception is thrown if the signature
	 *                                 string offered is rejected.
	 * @throws CladosMonadException    This exception is thrown if there is an issue
	 *                                 with the coefficients offered. The issues
	 *                                 could involve null coefficients or a
	 *                                 coefficient array of the wrong size.
	 * @throws GeneratorRangeException This exception is thrown when the integer
	 *                                 number of generators for the basis is out of
	 *                                 the supported range. {0, 1, 2, ..., 15}
	 */
	public &lt;T extends ProtoN &amp; Field &amp; Normalizable&gt; Monad(	String pMonadName, 
															String pAlgebraName,
															Foot pFoot, 
															String pSig, 
															T pF)
<span class="fc" id="L514">			throws BadSignatureException, CladosMonadException, GeneratorRangeException {</span>
<span class="fc" id="L515">		setName(pMonadName);</span>
<span class="fc" id="L516">		setAlgebra(GBuilder.createAlgebraWithFoot(pFoot, pAlgebraName, pSig));</span>

<span class="pc bpc" id="L518" title="1 of 5 branches missed.">		switch (pF.getClass().getCanonicalName()){</span>
			case &quot;org.interworldtransport.cladosF.RealF&quot; -&gt; {
<span class="fc" id="L520">				scales = new Scale&lt;RealF&gt;(CladosField.REALF, this.getAlgebra().getGBasis(), pF.getCardinal()).zeroAll();</span>
<span class="fc" id="L521">				break;</span>
			}
			case &quot;org.interworldtransport.cladosF.RealD&quot; -&gt; {
<span class="fc" id="L524">				scales = new Scale&lt;RealD&gt;(CladosField.REALD, this.getAlgebra().getGBasis(), pF.getCardinal()).zeroAll();</span>
<span class="fc" id="L525">				break;</span>
			}
			case &quot;org.interworldtransport.cladosF.ComplexF&quot; -&gt; {
<span class="fc" id="L528">				scales = new Scale&lt;ComplexF&gt;(CladosField.COMPLEXF, this.getAlgebra().getGBasis(), pF.getCardinal()).zeroAll();</span>
<span class="fc" id="L529">				break;</span>
			}
			case &quot;org.interworldtransport.cladosF.ComplexD&quot; -&gt; {
<span class="fc" id="L532">				scales = new Scale&lt;ComplexD&gt;(CladosField.COMPLEXD, this.getAlgebra().getGBasis(), pF.getCardinal()).zeroAll();</span>
<span class="fc" id="L533">				break;</span>
			}
<span class="nc" id="L535">			default -&gt; throw new IllegalArgumentException(&quot;Offered Number must be a child of CladosF/ProtoN&quot;);</span>
		}
<span class="fc" id="L537">		setGradeKey();</span>
<span class="fc" id="L538">	}</span>

	/**
	 * Special constructor of Monad with most information passed in. 'Special Case'
	 * strings determine the coefficients automatically. 'Unit Scalar' and 'Unit
	 * PScalar' are recognized special cases. All unrecognized strings create a
	 * 'Zero' Monad by default.
	 * &lt;br&gt;
	 * @param &lt;T&gt;          CladosF number is a ProtoN child that implemnts
	 *                     Field and Normalizable.
	 * @param pMonadName   String
	 * @param pAlgebraName String
	 * @param pFootName    String
	 * @param pSig         String
	 * @param pF           T generic for a CladosF number
	 * @param pSpecial     String
	 * @throws BadSignatureException   This exception is thrown if the signature
	 *                                 string offered is rejected.
	 * @throws CladosMonadException    This exception is thrown if there is an issue
	 *                                 with the coefficients offered the default
	 *                                 constructor. The issues could involve null
	 *                                 coefficients or a coefficient array of the
	 *                                 wrong size.
	 * @throws GeneratorRangeException This exception is thrown when the integer
	 *                                 number of generators for the basis is out of
	 *                                 the supported range. {0, 1, 2, ..., 14}
	 */
	public &lt;T extends ProtoN &amp; Field &amp; Normalizable&gt; Monad(	String pMonadName, 
															String pAlgebraName,
															String pFootName, 
															String pSig, 
															T pF, 
															String pSpecial)
			throws BadSignatureException, CladosMonadException, GeneratorRangeException {
<span class="fc" id="L572">		this(	pMonadName, </span>
				pAlgebraName, 
<span class="fc" id="L574">				GBuilder.createFootLike(pFootName, pF), </span>
				pSig, 
				pF);	//Defer to Constructor #4
						// Default ZERO Monad is complete. 
						// Now handle the special cases.
<span class="fc bfc" id="L579" title="All 2 branches covered.">		if (MONAD_SPECIAL_CASES.contains(pSpecial)) {</span>
<span class="pc bpc" id="L580" title="1 of 5 branches missed.">			switch (getMode()) {</span>
				case COMPLEXD -&gt; {
<span class="pc bpc" id="L582" title="1 of 5 branches missed.">					switch (pSpecial) {</span>
						case &quot;Unit Scalar&quot; -&gt; {
<span class="fc" id="L584">							((ComplexD) scales.getScalar()).setReal(PLUS_ONE_F);</span>
<span class="fc" id="L585">							break;</span>
						}
						case &quot;Unit -Scalar&quot; -&gt; {
<span class="fc" id="L588">							((ComplexD) scales.getScalar()).setReal(MINUS_ONE_F);</span>
<span class="fc" id="L589">							break;</span>
						}
						case &quot;Unit PScalar&quot; -&gt; {
<span class="fc" id="L592">							((ComplexD) scales.getPScalar()).setReal(PLUS_ONE_F);</span>
<span class="fc" id="L593">							break;</span>
						}
						case &quot;Unit -PScalar&quot; -&gt; {
<span class="fc" id="L596">							((ComplexD) scales.getPScalar()).setReal(MINUS_ONE_F);</span>
							break;
						}
					}
<span class="fc" id="L600">					break;</span>
				}
				case COMPLEXF -&gt; {
<span class="pc bpc" id="L603" title="1 of 5 branches missed.">					switch (pSpecial) {</span>
						case &quot;Unit Scalar&quot; -&gt; {
<span class="fc" id="L605">							((ComplexF) scales.getScalar()).setReal(PLUS_ONE_F);</span>
<span class="fc" id="L606">							break;</span>
						}
						case &quot;Unit -Scalar&quot; -&gt; {
<span class="fc" id="L609">							((ComplexF) scales.getScalar()).setReal(MINUS_ONE_F);</span>
<span class="fc" id="L610">							break;</span>
						}
						case &quot;Unit PScalar&quot; -&gt; {
<span class="fc" id="L613">							((ComplexF) scales.getPScalar()).setReal(PLUS_ONE_F);</span>
<span class="fc" id="L614">							break;</span>
						}
						case &quot;Unit -PScalar&quot; -&gt; {
<span class="fc" id="L617">							((ComplexF) scales.getPScalar()).setReal(MINUS_ONE_F);</span>
							break;
						}
					}
<span class="fc" id="L621">				}</span>
				case REALD -&gt; {
<span class="pc bpc" id="L623" title="1 of 5 branches missed.">					switch (pSpecial) {</span>
						case &quot;Unit Scalar&quot; -&gt; {
<span class="fc" id="L625">							((RealD) scales.getScalar()).setReal(PLUS_ONE_F);</span>
<span class="fc" id="L626">							break;</span>
						}
						case &quot;Unit -Scalar&quot; -&gt; {
<span class="fc" id="L629">							((RealD) scales.getScalar()).setReal(MINUS_ONE_F);</span>
<span class="fc" id="L630">							break;</span>
						}
						case &quot;Unit PScalar&quot; -&gt; {
<span class="fc" id="L633">							((RealD) scales.getPScalar()).setReal(PLUS_ONE_F);</span>
<span class="fc" id="L634">							break;</span>
						}
						case &quot;Unit -PScalar&quot; -&gt; {
<span class="fc" id="L637">							((RealD) scales.getPScalar()).setReal(MINUS_ONE_F);</span>
							break;
						}
					}
<span class="fc" id="L641">				}</span>
				case REALF -&gt; {
<span class="pc bpc" id="L643" title="1 of 5 branches missed.">					switch (pSpecial) {</span>
						case &quot;Unit Scalar&quot; -&gt; {
<span class="fc" id="L645">							((RealF) scales.getScalar()).setReal(PLUS_ONE_F);</span>
<span class="fc" id="L646">							break;</span>
						}
						case &quot;Unit -Scalar&quot; -&gt; {
<span class="fc" id="L649">							((RealF) scales.getScalar()).setReal(MINUS_ONE_F);</span>
<span class="fc" id="L650">							break;</span>
						}
						case &quot;Unit PScalar&quot; -&gt; {
<span class="fc" id="L653">							((RealF) scales.getPScalar()).setReal(PLUS_ONE_F);</span>
<span class="fc" id="L654">							break;</span>
						}
						case &quot;Unit -PScalar&quot; -&gt; {
<span class="fc" id="L657">							((RealF) scales.getPScalar()).setReal(MINUS_ONE_F);</span>
							break;
						}
					}
				}
			}
		} // failure to find matching special case defaults to ZERO monad by doing nothing.
<span class="fc" id="L664">		setGradeKey();</span>
<span class="fc" id="L665">	}</span>

	/**
	 * Main constructor of Monad with all information passed in.
	 * &lt;br&gt;
	 * @param &lt;T&gt;          CladosF number is a ProtoN child that implemnts
	 *                     Field and Normalizable.
	 * @param pMonadName   String
	 * @param pAlgebraName String
	 * @param pFootName    String
	 * @param pSig         String
	 * @param pScale       Scale of CladosF numbers
	 * @throws BadSignatureException   This exception is thrown if the signature
	 *                                 string offered is rejected.
	 * @throws CladosMonadException    This exception is thrown if there is an issue
	 *                                 with the coefficients offered. The issues
	 *                                 could involve null coefficients or a
	 *                                 coefficient array of the wrong size.
	 * @throws GeneratorRangeException This exception is thrown when the integer
	 *                                 number of generators for the basis is out of
	 *                                 the supported range. {0, 1, 2, ..., 15}
	 */
	public &lt;T extends ProtoN &amp; Field &amp; Normalizable&gt; Monad(	String pMonadName, 
															String pAlgebraName,
															String pFootName, 
															String pSig, 
															Scale&lt;T&gt; pScale)
			throws BadSignatureException, CladosMonadException, GeneratorRangeException {

<span class="fc" id="L694">		this(	pMonadName, </span>
<span class="fc" id="L695">				GBuilder.createAlgebraWithFootGP(</span>
<span class="fc" id="L696">										GBuilder.createFoot(pFootName, pScale.getCardinal().getUnit()), </span>
<span class="fc" id="L697">										GBuilder.createGProduct(Optional.ofNullable(pScale.getBasis()), pSig),</span>
										pAlgebraName), 
				pScale);				//Defer to constructor #7 safely
										//because pScale's Basis was used building Algebra.
<span class="fc" id="L701">	}</span>

	/**
	 * Main constructor of Monad with pre-constructed objects not already part of another Monad.
	 * &lt;br&gt;
	 * This one is very important to GBuilder for ensuring reference matches occur correctly, but it
	 * does reject construction if the bases in Algebra and Scale do not match.
	 * &lt;br&gt;
	 * @param &lt;T&gt;        CladosF number is a ProtoN child that implemnts Field
	 *                   and Normalizable.
	 * @param pMonadName String
	 * @param pAlgebra   Algebra
	 * @param pScale     Scale of CladosF numbers
	 * @throws CladosMonadException This exception is thrown if there is an issue
	 *                              with the coefficients offered. The issues could
	 *                              involve null coefficients or a coefficient array
	 *                              of the wrong size.
	 */
	public &lt;T extends ProtoN &amp; Field &amp; Normalizable&gt; Monad(	String pMonadName, 
															Algebra pAlgebra, 
<span class="fc" id="L721">															Scale&lt;T&gt; pScale) throws CladosMonadException {</span>
<span class="pc bpc" id="L722" title="1 of 2 branches missed.">		if (pScale.getBasis() != pAlgebra.getGBasis())</span>
<span class="nc" id="L723">			throw new CladosMonadException(this, &quot;Scale basis must match exactly the basis in Algebra.&quot;);</span>

<span class="fc" id="L725">		setName(pMonadName);</span>
<span class="fc" id="L726">		setAlgebra(pAlgebra);</span>
<span class="fc" id="L727">		scales = new Scale&lt;T&gt;(pScale);</span>
<span class="fc" id="L728">		setGradeKey();</span>
<span class="fc" id="L729">	}</span>

	/**
	 * Monad Subtraction: (this + pM) The two monads must be reference matches and use the same ProtoN 
	 * child. The first check involves a reference match which will spot algebra mismatches. 
	 * The next step involves trying addition and possibly catching exceptions that result from Scales 
	 * containing mutable weights.
	 * &lt;br&gt;
	 * @param pM Monad to be added to this one
	 * @return Monad that is the result of the addition operation
	 */
	public Monad add(Monad pM) {
<span class="fc bfc" id="L741" title="All 2 branches covered.">		if (!Monad.isReferenceMatch(this, pM))</span>
<span class="fc" id="L742">			throw new IllegalArgumentException(&quot;Can't add monads when Algebras or Cardinals don't match.&quot;);</span>

<span class="fc" id="L744">		bladeStream().parallel().forEach(blade -&gt; {		//Monads are reference matches now</span>
			try {										//but their Scales don't realize that and we have
<span class="fc" id="L746">				scales.get(blade).add(pM.scales.get(blade));</span>
<span class="nc" id="L747">			} catch (FieldBinaryException e) {			//to check again because weights are mutable.</span>
<span class="nc" id="L748">				throw new IllegalArgumentException(&quot;Can't add when cardinals don't match.&quot;);</span>
<span class="fc" id="L749">			}</span>
<span class="fc" id="L750">		});</span>
<span class="fc" id="L751">		setGradeKey();</span>
<span class="fc" id="L752">		return this;</span>
	}

	/**
	 * This method returns the actual blades the underlying basis as a stream.
	 * &lt;br&gt;
	 * @return Stream of Blades in the underlying Basis
	 */
	public Stream&lt;Blade&gt; bladeStream() {
<span class="fc" id="L761">		return algebra.getGBasis().bladeStream();</span>
	}

	/**
	 * This method causes all coefficients of a monad to be conjugated.
	 * &lt;br&gt;
	 * @return Monad after operation.
	 */
	public Monad conjugate() {
<span class="fc" id="L770">		scales.conjugate();</span>
<span class="fc" id="L771">		return this;</span>
	}

	/**
	 * The Monad is turned into its Dual with left side multiplication by pscalar.
	 * &lt;br&gt;
	 * In metrics where one or more of the generators squares to zero, this isn't really
	 * a dual operation.
	 * &lt;br&gt;
	 * @param &lt;T&gt; CladosF number is a ProtoN child that implemnts Field and Normalizable.
	 * @return Monad after operation.
	 */
	public &lt;T extends ProtoN &amp; Field &amp; Normalizable&gt; Monad multiplyByPSLeft() {	
<span class="fc" id="L784">		this.multiplyLeft(GBuilder.pscalarOfMonad(this));</span>
<span class="fc" id="L785">		setGradeKey();</span>
<span class="fc" id="L786">		return this;</span>
	}

	/**
	 * The Monad is turned into its Dual with right side multiplication by pscalar.
	 * &lt;br&gt;
	 * In metrics where one or more of the generators squares to zero, this isn't really
	 * a dual operation.
	 * &lt;br&gt;
	 * @param &lt;T&gt;  ProtoN child number to create. Includes the Field and Normalizable interfaces too.
	 * @return Monad after operation.
	 */
	public &lt;T extends ProtoN &amp; Field &amp; Normalizable&gt; Monad multiplyByPSRight() {
<span class="fc" id="L799">		this.multiplyRight(GBuilder.pscalarOfMonad(this));</span>
<span class="fc" id="L800">		setGradeKey();</span>
<span class="fc" id="L801">		return this;</span>
	}

	/**
	 * This method returns the Algebra for this Monad.
	 * &lt;br&gt;
	 * @return Algebra
	 */
	public Algebra getAlgebra() {
<span class="fc" id="L810">		return algebra;</span>
	}

	/**
	 * Return the field Coefficients for this Monad. These coefficients are the
	 * multipliers making linear combinations of the basis elements.
	 * &lt;br&gt;
	 * Since the map internal to Scale can accept any of the CladosF numbers as
	 * values, there is a cast to a 'generic' type within this method. This would
	 * normally cause warnings by the compiler since the generic named in the
	 * internal map IS a ProtoN child AND casting an unchecked type could fail
	 * at runtime.
	 * &lt;br&gt;
	 * That won't happen here when CladosF builders are used. They can't build
	 * anything that is NOT a ProtoN child. They can't even build a
	 * ProtoN instance directly. Therefore, only children can arrive as the
	 * value parameter of the 'put' function. Thus, there is no danger of a failed
	 * cast operation... until someone creates a new ProtoN child class and
	 * fails to update all builders.
	 * &lt;br&gt;
	 * @param &lt;T&gt; ProtoN number from CladosF without the interfaces this time.
	 * @return ProtoN[]
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public &lt;T extends ProtoN&gt; T[] getCoeff() {
<span class="fc" id="L835">		return (T[]) scales.getWeights();</span>
	}

	/**
	 * Return a field Coefficient for this Monad. These coefficients are the
	 * multipliers making linear combinations of the basis elements.
	 * &lt;br&gt;
	 * Since the map internal to Scale can accept any of the CladosF numbers as
	 * values, there is a cast to a 'generic' type within this method. This would
	 * normally cause warnings by the compiler since the generic named in the
	 * internal map IS a ProtoN child AND casting an unchecked type could fail
	 * at runtime.
	 * &lt;br&gt;
	 * That won't happen here when CladosF builders are used. They can't build
	 * anything that is NOT a ProtoN child. They can't even build a
	 * ProtoN instance directly. Therefore, only children can arrive as the
	 * value parameter of the 'put' function. Thus, there is no danger of a failed
	 * cast operation... until someone creates a new ProtoN child class and
	 * fails to update all builders.
	 * &lt;br&gt;
	 * @param i   int This points at the coefficient at the equivalent tuple
	 *            location.
	 * @param &lt;T&gt; ProtoN number from CladosF without the interfaces this time.
	 * @return ProtoN
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public &lt;T extends ProtoN &amp; Field &amp; Normalizable&gt; T getCoeff(int i) {
<span class="fc bfc" id="L862" title="All 6 branches covered.">		if (i &gt;= 0 &amp; i &lt; getAlgebra().getBladeCount())</span>
<span class="fc" id="L863">			return (T) scales.getWeights()[i];</span>
<span class="fc" id="L864">		return null;</span>
	}

	/**
	 * Return the grade key for the monad
	 * &lt;br&gt;
	 * @return long
	 */
	public long getGradeKey() {
<span class="fc" id="L873">		return gradeKey;</span>
	}

	/**
	 * This answers a question concerning which type of ProtoN children are
	 * used.
	 * &lt;br&gt;
	 * @return CladosField mode for this monad
	 */
	@Override
	public CladosField getMode() {
<span class="fc" id="L884">		return scales.getMode();</span>
	}

	/**
	 * Simple gettor for name of the monad.
	 * &lt;br&gt;
	 * @return String Contains the name of the Monad.
	 */
	public String getName() {
<span class="fc" id="L893">		return name;</span>
	}

	/**
	 * This method returns the map relating basis blades to coefficients.
	 * &lt;br&gt;
	 * @return Scale of Blades and ProtoN children. This is the 'coefficients'
	 *         object.
	 */
	public Scale&lt;? extends ProtoN&gt; getWeights() {
<span class="fc" id="L903">		return scales;</span>
	}

	/**
	 * This method returns the sparse flag of the monad in case someone wants to
	 * know. It is just a gettor method, though.
	 * &lt;br&gt;
	 * @return boolean
	 */
	public boolean getSparseFlag() {
<span class="fc" id="L913">		return sparseFlag;</span>
	}

	/**
	 * This method suppresses grades in the Monad not equal to the integer passed.
	 * &lt;br&gt;
	 * @param pGrade byte integer of the grade TO KEEP.
	 * @return Monad but in practice it will always be a child of MonadAbtract
	 */
	public Monad gradePart(byte pGrade) {
<span class="fc bfc" id="L923" title="All 6 branches covered.">		if (pGrade &gt;= getAlgebra().getGradeCount() | pGrade &lt; 0)</span>
<span class="fc" id="L924">			return this;</span>
<span class="fc" id="L925">		scales.zeroAllButGrade(pGrade);</span>
<span class="fc" id="L926">		setGradeKey();</span>
<span class="fc" id="L927">		return this;</span>
	}

	/**
	 * This integer stream is OFTEN used internally in monads for calculations.
	 * Rather than type it out in long form, it is aliases to this method.
	 * &lt;br&gt;
	 * @return Integer stream ranging through all the grades of the algebra
	 */
	public IntStream gradeStream() {
<span class="fc" id="L937">		return IntStream.range(0, getAlgebra().getGradeCount());</span>
	}

	/**
	 * This method suppresses the grade in the Monad equal to the integer passed.
	 * &lt;br&gt;
	 * @param pGrade byte integer of the grade TO SUPPRESS.
	 * @return Monad but in practice it will always be a child of MonadAbtract
	 */
	public Monad gradeSuppress(byte pGrade) {
<span class="fc bfc" id="L947" title="All 6 branches covered.">		if (pGrade &lt; 0 | pGrade &gt;= getAlgebra().getGradeCount())</span>
<span class="fc" id="L948">			return this;</span>
<span class="fc" id="L949">		scales.zeroAtGrade(pGrade);</span>
<span class="fc" id="L950">		setGradeKey();</span>
<span class="fc" id="L951">		return this;</span>
	}

	/**
	 * Mirror the sense of all geometry generators in the Monad.
	 * &lt;br&gt;
	 * @return Monad after the main involution is complete.
	 */
	public Monad mainInvolution() {
<span class="fc" id="L960">		scales.mainInvolution();</span>
<span class="fc" id="L961">		return this;</span>
	}

	/**
	 * This method does a deep check for the equality of two monads. It is not meant
	 * for checking that two monad references actually point to the same object
	 * since that is easily handled with ==. This one checks algebras, cardinals, and 
	 * weihts. Each object owned by a monad has its own specialized isEqual() that is called.
	 * &lt;br&gt;
	 * Note that this could be done by override Object's equals() method. That might
	 * happen in the future, but thought will have to be given to how to override
	 * the hashing method too.
	 * &lt;br&gt;
	 * @param pM Monad
	 * @return boolean
	 */
	public boolean isGEqual(Monad pM) {
<span class="fc bfc" id="L978" title="All 2 branches covered.">		if (!Monad.isReferenceMatch(this, pM))</span>
<span class="fc" id="L979">			return false;</span>
<span class="pc bpc" id="L980" title="1 of 5 branches missed.">		switch (getMode()) {</span>
<span class="fc" id="L981">			case COMPLEXD : return bladeStream().allMatch(blade -&gt; </span>
<span class="fc" id="L982">							ComplexD.isEqual((ComplexD) scales.get(blade), (ComplexD) pM.scales.get(blade)));</span>
<span class="fc" id="L983">			case COMPLEXF : return bladeStream().allMatch(blade -&gt; </span>
<span class="fc" id="L984">							ComplexF.isEqual((ComplexF) scales.get(blade), (ComplexF) pM.scales.get(blade)));</span>
<span class="fc" id="L985">			case REALD : return bladeStream().allMatch(blade -&gt; </span>
<span class="fc" id="L986">							RealD.isEqual((RealD) scales.get(blade), (RealD) pM.scales.get(blade)));</span>
<span class="fc" id="L987">			case REALF : return bladeStream().allMatch(blade -&gt; </span>
<span class="fc" id="L988">							RealF.isEqual((RealF) scales.get(blade), (RealF) pM.scales.get(blade)));</span>
<span class="nc" id="L989">			default : return false;</span>
		
		}
	}

	/**
	 * Return the magnitude of the Monad
	 * &lt;br&gt;
	 * Since the map internal to Scale can accept any of the CladosF numbers as
	 * values, there is a cast to a 'generic' type within this method. This would
	 * normally cause warnings by the compiler since the generic named in the
	 * internal map IS a ProtoN child AND casting an unchecked type could fail
	 * at runtime.
	 * &lt;br&gt;
	 * That won't happen here when CladosF builders are used. They can't build
	 * anything that is NOT a ProtoN child. They can't even build a
	 * ProtoN instance directly. Therefore, only children can arrive as the
	 * value parameter of the 'put' function. Thus, there is no danger of a failed
	 * cast operation... until someone creates a new ProtoN child class and
	 * fails to update all builders.
	 * &lt;br&gt;
	 * @param &lt;T&gt; ProtoN number from CladosF with the Field interface this
	 *            time.
	 * @return ProtoN but in practice it is always a child of ProtoN
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public &lt;T extends ProtoN &amp; Field&gt; T magnitude() {
<span class="fc" id="L1016">		return (T) scales.modulusSum();</span>
	}

	/**
	 * Monad antisymmetric multiplication: 1/2(pM this - this pM) This operation is
	 * allowed when the two monads use the same field and satisfy the Reference
	 * Matching test.
	 * &lt;br&gt;
	 * @param pM Monad
	 * @return Monad
	 */
	public Monad multiplyAntisymm(Monad pM) {
<span class="fc bfc" id="L1028" title="All 2 branches covered.">		if (!isReferenceMatch(this, pM))</span>
<span class="fc" id="L1029">			throw new IllegalArgumentException(&quot;Symm multiply fails reference match.&quot;);</span>
<span class="fc" id="L1030">		Monad halfTwoRight = (GBuilder.copyOfMonad(this)).multiplyRight(pM);</span>
<span class="fc" id="L1031">		(this.multiplyLeft(pM)).subtract(halfTwoRight);</span>
<span class="pc bpc" id="L1032" title="1 of 5 branches missed.">		switch (getMode()) {</span>
			case COMPLEXD -&gt; {
<span class="fc" id="L1034">				scale(ComplexD.newONE(scales.getCardinal()).scale(BY2_D));</span>
<span class="fc" id="L1035">				break;</span>
			}
			case COMPLEXF -&gt; {
<span class="fc" id="L1038">				scale( ComplexF.newONE(scales.getCardinal()).scale(BY2_F));</span>
<span class="fc" id="L1039">				break;</span>
			}
			case REALD -&gt; {
<span class="fc" id="L1042">				scale((RealD.newONE(scales.getCardinal()).scale(BY2_D)));</span>
<span class="fc" id="L1043">				break;</span>
			}
			case REALF -&gt; {
<span class="fc" id="L1046">				scale((RealF.newONE(scales.getCardinal()).scale(BY2_F)));</span>
				break;
			}
		}
<span class="fc" id="L1050">		setGradeKey();</span>
<span class="fc" id="L1051">		return this;</span>
	}

	/**
	 * Monad leftside multiplication: (pM this) This operation is allowed when the
	 * two monads use the same field and satisfy the Reference Match test.
	 * &lt;br&gt;
	 * WHEN SPARSE | Use gradeKey (a base 10 representation of grades present) to
	 * find the non-zero grades. For example: gradeKey=101 means the monad is a sum
	 * of bivector and scalar because 10^2+10^0 = 101.
	 * &lt;br&gt;
	 * In a sparse monad, the gradeKey will have few 1's, making looping on all
	 * blades less optimal. Instead, we parse gradeKey and loop through the blades
	 * for grades that could be non-ZERO.
	 * &lt;br&gt;
	 * NOTE that the mode of the inbound monad is NOT checked. That can lead to odd
	 * behavior if one sends in a complex numbers expecting against real numbers.
	 * What IS checked is the cardinal and that likely traps most errors that can be
	 * made. It's not perfect, though. If someone intentionally builds different
	 * number types using the same cardinal, they will get around the detection in
	 * place here.
	 * &lt;br&gt;
	 * What will happen in that case? The inbound numbers will be multiplied against
	 * coefficients as THEY understand multiplication. The inbound numbers gets cast
	 * to the other, so imaginary components won't get used in real number
	 * multiplication.
	 * &lt;br&gt;
	 * @param pM  Monad
	 * @param &lt;T&gt; ProtoN number from CladosF with all interfaces this time.
	 * @return Monad
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public &lt;T extends ProtoN &amp; Field &amp; Normalizable&gt; Monad multiplyLeft(Monad pM) {
<span class="fc bfc" id="L1084" title="All 2 branches covered.">		if (!Monad.isReferenceMatch(this, pM))</span>
<span class="fc" id="L1085">			throw new IllegalArgumentException(&quot;Left multiply fails reference match.&quot;);</span>
<span class="fc" id="L1086">		GProduct tProd = getAlgebra().getGProduct();</span>
<span class="fc" id="L1087">		Basis tBasis = getAlgebra().getGBasis();</span>

<span class="fc" id="L1089">		Scale&lt;T&gt; newScales = new Scale&lt;T&gt;(getMode(), tBasis, scales.getCardinal()).zeroAll();</span>
<span class="fc bfc" id="L1090" title="All 2 branches covered.">		if (sparseFlag) {</span>
<span class="fc" id="L1091">			long slideKey = gradeKey;</span>
<span class="fc" id="L1092">			byte logKey = (byte) Math.log10(slideKey); // logKey is the highest grade with non-zero blades</span>
<span class="pc bpc" id="L1093" title="1 of 2 branches missed.">			while (logKey &gt;= 0) {</span>
<span class="fc" id="L1094">				tBasis.bladeOfGradeStream(logKey).filter(blade -&gt; getWeights().isNotZeroAt(blade)).forEach(blade -&gt; {</span>
<span class="fc" id="L1095">					int col = tBasis.find(blade) - 1;</span>
<span class="fc" id="L1096">					pM.bladeStream().filter(blade2 -&gt; pM.getWeights().isNotZeroAt(blade2)).parallel().forEach(blade2 -&gt; {</span>
<span class="fc" id="L1097">						int row = tBasis.find(blade2) - 1;</span>
<span class="fc" id="L1098">						int treturnBlade = Math.abs(tProd.getResult(row, col)) - 1;		//Recover Cayley table entry as index</span>
<span class="fc bfc" id="L1099" title="All 2 branches covered.">						if (treturnBlade == -1) treturnBlade = 0;						//If it is -1 set it to scalar</span>
<span class="fc" id="L1100">						Blade bMult = tBasis.getSingleBlade(treturnBlade);</span>
<span class="pc bpc" id="L1101" title="1 of 5 branches missed.">						switch (getMode()) {</span>
						case COMPLEXD -&gt; {
							try {
<span class="fc" id="L1104">								ComplexD tAgg = ComplexD</span>
<span class="fc" id="L1105">										.multiply((ComplexD) getWeights().get(blade), (ComplexD) pM.getWeights().get(blade2))</span>
<span class="fc" id="L1106">										.scale(Double.valueOf(tProd.getSign(row, col)))</span>
<span class="fc" id="L1107">										.add(newScales.get(bMult));</span>
<span class="fc" id="L1108">								newScales.put(bMult, (T) tAgg);</span>
<span class="nc" id="L1109">							} catch (FieldBinaryException e) {</span>
<span class="nc" id="L1110">								throw new IllegalArgumentException(&quot;Left multiply fails ProtoN reference match.&quot;);</span>
<span class="fc" id="L1111">							}</span>
							break;
						}
						case COMPLEXF -&gt; {
							try {
<span class="fc" id="L1116">								ComplexF tAgg = ComplexF</span>
<span class="fc" id="L1117">										.multiply((ComplexF) getWeights().get(blade), (ComplexF) pM.getWeights().get(blade2))</span>
<span class="fc" id="L1118">										.scale(Float.valueOf(tProd.getSign(row, col)))</span>
<span class="fc" id="L1119">										.add(newScales.get(bMult));</span>
<span class="fc" id="L1120">								newScales.put(bMult, (T) tAgg);</span>
<span class="nc" id="L1121">							} catch (FieldBinaryException e) {</span>
<span class="nc" id="L1122">								throw new IllegalArgumentException(&quot;Left multiply fails ProtoN reference match.&quot;);</span>
<span class="fc" id="L1123">							}</span>
							break;
						}
						case REALD -&gt; {
							try {
<span class="fc" id="L1128">								RealD tAgg = RealD</span>
<span class="fc" id="L1129">										.multiply((RealD) getWeights().get(blade), (RealD) pM.getWeights().get(blade2))</span>
<span class="fc" id="L1130">										.scale(Double.valueOf(tProd.getSign(row, col)))</span>
<span class="fc" id="L1131">										.add(newScales.get(bMult));</span>
<span class="fc" id="L1132">								newScales.put(bMult, (T) tAgg);</span>
<span class="nc" id="L1133">							} catch (FieldBinaryException e) {</span>
<span class="nc" id="L1134">								throw new IllegalArgumentException(&quot;Left multiply fails ProtoN reference match.&quot;);</span>
<span class="fc" id="L1135">							}</span>
							break;
						}
						case REALF -&gt; {
							try {
<span class="fc" id="L1140">								RealF tAgg = RealF</span>
<span class="fc" id="L1141">										.multiply((RealF) getWeights().get(blade), (RealF) pM.getWeights().get(blade2))</span>
<span class="fc" id="L1142">										.scale(Float.valueOf(tProd.getSign(row, col)))</span>
<span class="fc" id="L1143">										.add(newScales.get(bMult));</span>
<span class="fc" id="L1144">								newScales.put(bMult, (T) tAgg);</span>
<span class="nc" id="L1145">							} catch (FieldBinaryException e) {</span>
<span class="nc" id="L1146">								throw new IllegalArgumentException(&quot;Left multiply fails ProtoN reference match.&quot;);</span>
<span class="fc" id="L1147">							}</span>
							break;
						}
						}
<span class="fc" id="L1151">					});</span>
<span class="fc" id="L1152">				});</span>
<span class="fc" id="L1153">				slideKey -= Math.pow(10, logKey); // Subtract 10^logKey marking grade as done.</span>
<span class="fc bfc" id="L1154" title="All 2 branches covered.">				if (slideKey == 0)</span>
<span class="fc" id="L1155">					break; // we've processed all grades including scalar.</span>
<span class="fc" id="L1156">				logKey = (byte) Math.log10(slideKey); // if zero it will be the last in loop</span>
			} // while loop completion -&gt; all grades in 'this' processed
<span class="fc" id="L1158">		} else {</span>
<span class="fc" id="L1159">			bladeStream().filter(blade -&gt; getWeights().isNotZeroAt(blade)).forEach(blade -&gt; {</span>
<span class="fc" id="L1160">				int col = tBasis.find(blade) - 1;</span>
<span class="fc" id="L1161">				pM.bladeStream().filter(blade2 -&gt; pM.getWeights().isNotZeroAt(blade2)).parallel().forEach(blade2 -&gt; {</span>
<span class="fc" id="L1162">					int row = tBasis.find(blade2) - 1;</span>
<span class="fc" id="L1163">					int treturnBlade = Math.abs(tProd.getResult(row, col)) - 1;		//Recover Cayley table entry as index</span>
<span class="pc bpc" id="L1164" title="1 of 2 branches missed.">					if (treturnBlade == -1) treturnBlade = 0;						//If it is -1 set it to scalar</span>
<span class="fc" id="L1165">					Blade bMult = tBasis.getSingleBlade(treturnBlade);</span>
<span class="pc bpc" id="L1166" title="1 of 5 branches missed.">					switch (getMode()) {</span>
					case COMPLEXD -&gt; {
						try {
<span class="fc" id="L1169">							ComplexD tAgg = ComplexD</span>
<span class="fc" id="L1170">									.multiply((ComplexD) getWeights().get(blade), (ComplexD) pM.getWeights().get(blade2))</span>
<span class="fc" id="L1171">									.scale(Double.valueOf(tProd.getSign(row, col)))</span>
<span class="fc" id="L1172">									.add(newScales.get(bMult));</span>
<span class="fc" id="L1173">							newScales.put(bMult, (T) tAgg);</span>
<span class="nc" id="L1174">						} catch (FieldBinaryException ex) {</span>
<span class="nc" id="L1175">							throw new IllegalArgumentException(&quot;Left multiply fails ProtoN reference match.&quot;);</span>
<span class="fc" id="L1176">						}</span>
						break;
					}
					case COMPLEXF -&gt; {
						try {
<span class="fc" id="L1181">							ComplexF tAgg = ComplexF</span>
<span class="fc" id="L1182">									.multiply((ComplexF) getWeights().get(blade), (ComplexF) pM.getWeights().get(blade2))</span>
<span class="fc" id="L1183">									.scale(Float.valueOf(tProd.getSign(row, col)))</span>
<span class="fc" id="L1184">									.add(newScales.get(bMult));</span>
<span class="fc" id="L1185">							newScales.put(bMult, (T) tAgg);</span>
<span class="nc" id="L1186">						} catch (FieldBinaryException ex) {</span>
<span class="nc" id="L1187">							throw new IllegalArgumentException(&quot;Left multiply fails ProtoN reference match.&quot;);</span>
<span class="fc" id="L1188">						}</span>
						break;
					}
					case REALD -&gt; {
						try {
<span class="fc" id="L1193">							RealD tAgg = RealD</span>
<span class="fc" id="L1194">									.multiply((RealD) getWeights().get(blade), (RealD) pM.getWeights().get(blade2))</span>
<span class="fc" id="L1195">									.scale(Double.valueOf(tProd.getSign(row, col)))</span>
<span class="fc" id="L1196">									.add(newScales.get(bMult));</span>
<span class="fc" id="L1197">							newScales.put(bMult, (T) tAgg);</span>
<span class="nc" id="L1198">						} catch (FieldBinaryException ex) {</span>
<span class="nc" id="L1199">							throw new IllegalArgumentException(&quot;Left multiply fails ProtoN reference match.&quot;);</span>
<span class="fc" id="L1200">						}</span>
						break;
					}
					case REALF -&gt; {
						try {
<span class="fc" id="L1205">							RealF tAgg = RealF</span>
<span class="fc" id="L1206">									.multiply((RealF) getWeights().get(blade), (RealF) pM.getWeights().get(blade2))</span>
<span class="fc" id="L1207">									.scale(Float.valueOf(tProd.getSign(row, col)))</span>
<span class="fc" id="L1208">									.add(newScales.get(bMult));</span>
<span class="fc" id="L1209">							newScales.put(bMult, (T) tAgg);</span>
<span class="nc" id="L1210">						} catch (FieldBinaryException ex) {</span>
<span class="nc" id="L1211">							throw new IllegalArgumentException(&quot;Left multiply fails ProtoN reference match.&quot;);</span>
<span class="fc" id="L1212">						}</span>
						break;
					}
					}
<span class="fc" id="L1216">				});</span>
<span class="fc" id="L1217">			});</span>
		}
<span class="fc" id="L1219">		scales = newScales;</span>
<span class="fc" id="L1220">		setGradeKey();</span>
<span class="fc" id="L1221">		return this;</span>
	}

	/**
	 * Monad rightside multiplication: (this pM) This operation is allowed when the
	 * two monads use the same field and satisfy the Reference Match test.
	 * &lt;br&gt;
	 * WHEN SPARSE | Use gradeKey (a base 10 representation of grades present) to
	 * find the non-zero grades. For example: gradeKey=101 means the monad is a sum
	 * of bivector and scalar because 10^2+10^0 = 101.
	 * &lt;br&gt;
	 * In a sparse monad, the gradeKey will have few 1's, making looping on all
	 * blades less optimal. Instead, we parse gradeKey and loop through the blades
	 * for grades that could be non-ZERO.
	 * &lt;br&gt;
	 * NOTE that the mode of the inbound monad is NOT checked. That can lead to odd
	 * behavior if one sends in a complex numbers expecting against real numbers.
	 * What IS checked is the cardinal and that likely traps most errors that can be
	 * made. It's not perfect, though. If someone intentionally builds different
	 * number types using the same cardinal, they will get around the detection in
	 * place here.
	 * &lt;br&gt;
	 * What will happen in that case? The inbound numbers will be multiplied against
	 * coefficients as THEY understand multiplication. The inbound numbers gets cast
	 * to the other, so imaginary components won't get used in real number
	 * multiplication.
	 * &lt;br&gt;
	 * @param pM  Monad
	 * @param &lt;T&gt; ProtoN number from CladosF with all interfaces this time.
	 * @return Monad
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public &lt;T extends ProtoN &amp; Field &amp; Normalizable&gt; Monad multiplyRight(Monad pM) {
<span class="fc bfc" id="L1254" title="All 2 branches covered.">		if (!isReferenceMatch(this, pM)) // Don't try if not a reference match</span>
<span class="fc" id="L1255">			throw new IllegalArgumentException(&quot;Right multiply fails reference match.&quot;);</span>
<span class="fc" id="L1256">		GProduct tProd = getAlgebra().getGProduct();</span>
<span class="fc" id="L1257">		Basis tBasis = getAlgebra().getGBasis();</span>

<span class="fc" id="L1259">		Scale&lt;T&gt; newScales = new Scale&lt;T&gt;(getMode(), tBasis, scales.getCardinal()).zeroAll();</span>
<span class="fc bfc" id="L1260" title="All 2 branches covered.">		if (sparseFlag) {</span>
<span class="fc" id="L1261">			long slideKey = gradeKey;</span>
<span class="fc" id="L1262">			byte logKey = (byte) Math.log10(slideKey); // logKey is the highest grade with non-zero blades</span>
<span class="pc bpc" id="L1263" title="1 of 2 branches missed.">			while (logKey &gt;= 0) {</span>
<span class="fc" id="L1264">				tBasis.bladeOfGradeStream(logKey).filter(blade -&gt; getWeights().isNotZeroAt(blade)).forEach(blade -&gt; {</span>
<span class="fc" id="L1265">					int col = tBasis.find(blade) - 1;</span>
<span class="fc" id="L1266">					pM.bladeStream().filter(blade2 -&gt; pM.getWeights().isNotZeroAt(blade2)).parallel().forEach(blade2 -&gt; {</span>
<span class="fc" id="L1267">						int row = tBasis.find(blade2) - 1;</span>
<span class="fc" id="L1268">						int treturnBlade = Math.abs(tProd.getResult(col, row)) - 1;		//Recover Cayley table entry as index</span>
<span class="fc bfc" id="L1269" title="All 2 branches covered.">						if (treturnBlade == -1) treturnBlade = 0;						//If it is -1 set it to scalar</span>
<span class="fc" id="L1270">						Blade bMult = tBasis.getSingleBlade(treturnBlade);</span>
<span class="pc bpc" id="L1271" title="1 of 5 branches missed.">						switch (getMode()) {</span>
						case COMPLEXD -&gt; {
							try {
<span class="fc" id="L1274">								ComplexD tAgg = ComplexD</span>
<span class="fc" id="L1275">										.multiply((ComplexD) getWeights().get(blade), (ComplexD) pM.getWeights().get(blade2))</span>
<span class="fc" id="L1276">										.scale(Double.valueOf(tProd.getSign(col, row)))</span>
<span class="fc" id="L1277">										.add(newScales.get(bMult));</span>
<span class="fc" id="L1278">								newScales.put(bMult, (T) tAgg);</span>
<span class="nc" id="L1279">							} catch (FieldBinaryException e) {</span>
<span class="nc" id="L1280">								throw new IllegalArgumentException(&quot;Left multiply fails ProtoN reference match.&quot;);</span>
<span class="fc" id="L1281">							}</span>
							break;
						}
						case COMPLEXF -&gt; {
							try {
<span class="fc" id="L1286">								ComplexF tAgg = ComplexF</span>
<span class="fc" id="L1287">										.multiply((ComplexF) getWeights().get(blade), (ComplexF) pM.getWeights().get(blade2))</span>
<span class="fc" id="L1288">										.scale(Float.valueOf(tProd.getSign(col, row)))</span>
<span class="fc" id="L1289">										.add(newScales.get(bMult));</span>
<span class="fc" id="L1290">								newScales.put(bMult, (T) tAgg);</span>
<span class="nc" id="L1291">							} catch (FieldBinaryException e) {</span>
<span class="nc" id="L1292">								throw new IllegalArgumentException(&quot;Left multiply fails ProtoN reference match.&quot;);</span>
<span class="fc" id="L1293">							}</span>
							break;
						}
						case REALD -&gt; {
							try {
<span class="fc" id="L1298">								RealD tAgg = RealD</span>
<span class="fc" id="L1299">										.multiply((RealD) getWeights().get(blade), (RealD) pM.getWeights().get(blade2))</span>
<span class="fc" id="L1300">										.scale(Double.valueOf(tProd.getSign(col, row)))</span>
<span class="fc" id="L1301">										.add(newScales.get(bMult));</span>
<span class="fc" id="L1302">								newScales.put(bMult, (T) tAgg);</span>
<span class="nc" id="L1303">							} catch (FieldBinaryException e) {</span>
<span class="nc" id="L1304">								throw new IllegalArgumentException(&quot;Left multiply fails ProtoN reference match.&quot;);</span>
<span class="fc" id="L1305">							}</span>
							break;
						}
						case REALF -&gt; {
							try {
<span class="fc" id="L1310">								RealF tAgg = RealF</span>
<span class="fc" id="L1311">										.multiply((RealF) getWeights().get(blade), (RealF) pM.getWeights().get(blade2))</span>
<span class="fc" id="L1312">										.scale(Float.valueOf(tProd.getSign(col, row)))</span>
<span class="fc" id="L1313">										.add(newScales.get(bMult));</span>
<span class="fc" id="L1314">								newScales.put(bMult, (T) tAgg);</span>
<span class="nc" id="L1315">							} catch (FieldBinaryException e) {</span>
<span class="nc" id="L1316">								throw new IllegalArgumentException(&quot;Left multiply fails ProtoN reference match.&quot;);</span>
<span class="fc" id="L1317">							}</span>
							break;
						}
						}
<span class="fc" id="L1321">					});</span>
<span class="fc" id="L1322">				});</span>
<span class="fc" id="L1323">				slideKey -= Math.pow(10, logKey); // Subtract 10^logKey marking grade as done.</span>
<span class="fc bfc" id="L1324" title="All 2 branches covered.">				if (slideKey == 0)</span>
<span class="fc" id="L1325">					break; // we've processed all grades including scalar.</span>
<span class="fc" id="L1326">				logKey = (byte) Math.log10(slideKey); // if zero it will be the last in loop</span>
			} // while loop completion -&gt; all grades in 'this' processed
<span class="fc" id="L1328">		} else {</span>
<span class="fc" id="L1329">			bladeStream().filter(blade -&gt; getWeights().isNotZeroAt(blade)).forEach(blade -&gt; {</span>
<span class="fc" id="L1330">				int col = tBasis.find(blade) - 1;</span>
<span class="fc" id="L1331">				pM.bladeStream().filter(blade2 -&gt; pM.getWeights().isNotZeroAt(blade2)).parallel().forEach(blade2 -&gt; {</span>
<span class="fc" id="L1332">					int row = tBasis.find(blade2) - 1;</span>
<span class="fc" id="L1333">					int treturnBlade = Math.abs(tProd.getResult(col, row)) - 1;		//Recover Cayley table entry as index</span>
<span class="fc bfc" id="L1334" title="All 2 branches covered.">					if (treturnBlade == -1) treturnBlade = 0;						//If it is -1 set it to scalar</span>
<span class="fc" id="L1335">					Blade bMult = tBasis.getSingleBlade(treturnBlade);</span>
<span class="pc bpc" id="L1336" title="1 of 5 branches missed.">					switch (getMode()) {</span>
					case COMPLEXD -&gt; {
						try {
<span class="fc" id="L1339">							ComplexD tAgg = ComplexD</span>
<span class="fc" id="L1340">									.multiply((ComplexD) getWeights().get(blade), (ComplexD) pM.getWeights().get(blade2))</span>
<span class="fc" id="L1341">									.scale(Double.valueOf(tProd.getSign(col, row)))</span>
<span class="fc" id="L1342">									.add(newScales.get(bMult));</span>
<span class="fc" id="L1343">							newScales.put(bMult, (T) tAgg);</span>
<span class="nc" id="L1344">						} catch (FieldBinaryException ex) {</span>
<span class="nc" id="L1345">							throw new IllegalArgumentException(&quot;Left multiply fails ProtoN reference match.&quot;);</span>
<span class="fc" id="L1346">						}</span>
						break;
					}
					case COMPLEXF -&gt; {
						try {
<span class="fc" id="L1351">							ComplexF tAgg = ComplexF</span>
<span class="fc" id="L1352">									.multiply((ComplexF) getWeights().get(blade), (ComplexF) pM.getWeights().get(blade2))</span>
<span class="fc" id="L1353">									.scale(Float.valueOf(tProd.getSign(col, row)))</span>
<span class="fc" id="L1354">									.add(newScales.get(bMult));</span>
<span class="fc" id="L1355">							newScales.put(bMult, (T) tAgg);</span>
<span class="nc" id="L1356">						} catch (FieldBinaryException ex) {</span>
<span class="nc" id="L1357">							throw new IllegalArgumentException(&quot;Left multiply fails ProtoN reference match.&quot;);</span>
<span class="fc" id="L1358">						}</span>
						break;
					}
					case REALD -&gt; {
						try {
<span class="fc" id="L1363">							RealD tAgg = RealD</span>
<span class="fc" id="L1364">									.multiply((RealD) getWeights().get(blade), (RealD) pM.getWeights().get(blade2))</span>
<span class="fc" id="L1365">									.scale(Double.valueOf(tProd.getSign(col, row)))</span>
<span class="fc" id="L1366">									.add(newScales.get(bMult));</span>
<span class="fc" id="L1367">							newScales.put(bMult, (T) tAgg);</span>
<span class="nc" id="L1368">						} catch (FieldBinaryException ex) {</span>
<span class="nc" id="L1369">							throw new IllegalArgumentException(&quot;Left multiply fails ProtoN reference match.&quot;);</span>
<span class="fc" id="L1370">						}</span>
						break;
					}
					case REALF -&gt; {
						try {
<span class="fc" id="L1375">							RealF tAgg = RealF</span>
<span class="fc" id="L1376">									.multiply((RealF) getWeights().get(blade), (RealF) pM.getWeights().get(blade2))</span>
<span class="fc" id="L1377">									.scale(Float.valueOf(tProd.getSign(col, row)))</span>
<span class="fc" id="L1378">									.add(newScales.get(bMult));</span>
<span class="fc" id="L1379">							newScales.put(bMult, (T) tAgg);</span>
<span class="nc" id="L1380">						} catch (FieldBinaryException ex) {</span>
<span class="nc" id="L1381">							throw new IllegalArgumentException(&quot;Left multiply fails ProtoN reference match.&quot;);</span>
<span class="fc" id="L1382">						}</span>
						break;
					}
					}
<span class="fc" id="L1386">				});</span>
<span class="fc" id="L1387">			});</span>
		}
<span class="fc" id="L1389">		scales = newScales;</span>
<span class="fc" id="L1390">		setGradeKey();</span>
<span class="fc" id="L1391">		return this;</span>
	}

	/**
	 * Monad symmetric multiplication: 1/2(pM this + this pM) This operation is
	 * allowed when the two monads use the same field and satisfy the Reference
	 * Matching test.
	 * &lt;br&gt;
	 * @param pM Monad
	 * @return Monad
	 */
	public Monad multiplySymm(Monad pM) {
<span class="fc bfc" id="L1403" title="All 2 branches covered.">		if (!isReferenceMatch(this, pM))</span>
<span class="fc" id="L1404">			throw new IllegalArgumentException(&quot;Symm multiply fails reference match.&quot;);</span>
<span class="fc" id="L1405">		Monad halfTwoRight = (GBuilder.copyOfMonad(this)).multiplyRight(pM);</span>
<span class="fc" id="L1406">		(this.multiplyLeft(pM)).add(halfTwoRight);</span>

<span class="pc bpc" id="L1408" title="1 of 5 branches missed.">		switch (getMode()) {</span>
			case COMPLEXD -&gt; {
<span class="fc" id="L1410">				scale(ComplexD.newONE(scales.getCardinal()).scale(BY2_D));</span>
<span class="fc" id="L1411">				break;</span>
			}
			case COMPLEXF -&gt; {
<span class="fc" id="L1414">				scale(ComplexF.newONE(scales.getCardinal()).scale(BY2_F));</span>
<span class="fc" id="L1415">				break;</span>
			}
			case REALD -&gt; {
<span class="fc" id="L1418">				scale(RealD.newONE(scales.getCardinal()).scale(BY2_D));</span>
<span class="fc" id="L1419">				break;</span>
			}
			case REALF -&gt; {
<span class="fc" id="L1422">				scale(RealF.newONE(scales.getCardinal()).scale(BY2_F));</span>
				break;
			}
		}
<span class="fc" id="L1426">		setGradeKey();</span>
<span class="fc" id="L1427">		return this;</span>
	}

	/**
	 * Normalize the monad using the definition that involves 
	 * @return Monad this after the operation is complete
	 * @throws FieldException This exception is thrown when normalizing a zero-sized
	 *                        or field-conflicted monad. The object throwing it
	 * 						  is one of the ProtoN children in Scale
	 */
	public Monad normalize() throws FieldException {
<span class="fc" id="L1438">		Monad tRev = (GBuilder.copyOfMonad(this)).reverse().conjugate();</span>
<span class="fc" id="L1439">		tRev.multiplyRight(this).gradePart((byte) 0); 	//The scalar part will be real.</span>

<span class="pc bpc" id="L1441" title="1 of 5 branches missed.">		switch (getMode()) {</span>
			case COMPLEXD -&gt; {
<span class="fc" id="L1443">				ComplexD tMagCD = ((ComplexD) tRev.getWeights().getScalar().invert()); //img part == 0</span>
<span class="fc" id="L1444">				tMagCD.setReal(Math.sqrt(Math.abs(tMagCD.getReal())));</span>
<span class="fc" id="L1445">				this.scale(tMagCD);</span>
<span class="fc" id="L1446">			}	</span>
			case COMPLEXF -&gt; {
<span class="fc" id="L1448">				ComplexF tMagCF = ((ComplexF) tRev.getWeights().getScalar().invert()); //img part == 0</span>
<span class="fc" id="L1449">				tMagCF.setReal((float) Math.sqrt(Math.abs(tMagCF.getReal())));</span>
<span class="fc" id="L1450">				this.scale(tMagCF);		</span>
<span class="fc" id="L1451">			}</span>
			case REALD -&gt; {
<span class="fc" id="L1453">				RealD tMagRD = ((RealD) tRev.getWeights().getScalar().invert());</span>
<span class="fc" id="L1454">				tMagRD.setReal(Math.sqrt(Math.abs(tMagRD.getReal())));</span>
<span class="fc" id="L1455">				this.scale(tMagRD);				</span>
<span class="fc" id="L1456">			}</span>
			case REALF -&gt; {
<span class="fc" id="L1458">				RealF tMagRF = ((RealF) tRev.getWeights().getScalar().invert());</span>
<span class="fc" id="L1459">				tMagRF.setReal((float) Math.sqrt(Math.abs(tMagRF.getReal())));</span>
<span class="fc" id="L1460">				this.scale(tMagRF);</span>
<span class="fc" id="L1461">			}</span>
			default -&gt; {}
		}
<span class="fc" id="L1464">		return this;</span>
	}

	/**
	 * Normalize the monad as if all its basis blades were 'vectors' in the 
	 * 2^n-dimensional vector space we can form using the basis from the 
	 * n-dimensional algebra.
	 * &lt;br&gt;
	 * @return Monad after normalization effort is attempted.
	 * @throws FieldException This exception is thrown when normalizing a zero-sized
	 *                        or field-conflicted monad. The object throwing it
	 * 						  is the Scale on behalf of one of its entries.
	 */
	public Monad normalizeOnVS() throws FieldException {
<span class="fc" id="L1478">		scales.normalize();</span>
<span class="fc" id="L1479">		return this;</span>
	}

	/**
	 * Reverse the multiplication order of all geometry generators in the Monad.
	 * Active Reversion: Alternating pairs of grades switch signs as a result of all
	 * the permutation, so the easiest thing to do is to change the coefficients
	 * instead.
	 * &lt;br&gt;
	 * @return Monad returns itself when done to support streaming operations.
	 */
	public Monad reverse() {
<span class="fc" id="L1491">		scales.reverse();</span>
<span class="fc" id="L1492">		return this;</span>
	}

	/**
	 * Monad Scaling: (this * real number) Only the Monad coefficients are scaled by
	 * the real number.
	 * &lt;br&gt;
	 * NOTE that the mode of the inbound scaling number is NOT checked. That can
	 * lead to odd behavior if one sends in a complex number expecting to scale a
	 * real number. What IS checked is the cardinal and that likely traps most
	 * errors that can be made. It's not perfect, though. If someone intentionally
	 * builds different number types using the same cardinal, they will get around
	 * the detection in place here. What will happen in that case? The inbound
	 * number will be multiplied against coefficients as THEY understand
	 * multiplication. The inbound number gets cast to the other, so imaginary
	 * components won't get used in real number multiplication.
	 * &lt;br&gt;
	 * @param pScale ProtoN to use for scaling the monad
	 * @param &lt;T&gt;    ProtoN number from CladosF with the Field interface.
	 * @return Monad after the scaling is complete.
	 */
	public &lt;T extends ProtoN &amp; Field &amp; Normalizable&gt; Monad scale(T pScale) {
<span class="fc" id="L1514">		scales.scale(pScale);</span>
<span class="fc" id="L1515">		setGradeKey();</span>
<span class="fc" id="L1516">		return this;</span>
	}

	/**
	 * Reset the Coefficient array used for this Monad. Use of this method is
	 * discouraged, but occasionally necessary. The ideal way of setting up the
	 * coefficient array is to build a new Monad with the new coefficient array.
	 * Using this set method encourages developers to reuse old objects. While this
	 * is useful for avoiding object construction overhead, it is dangerous in that
	 * the old meaning of the object might linger in the various name attributes.
	 * Caution is advised if this method is used while frequent reuse should be
	 * considered bad form.
	 * &lt;br&gt;
	 * @param &lt;T&gt;  ProtoN number from CladosF with all interfaces this time.
	 * @param ppC ProtoN child array for weights
	 * @return Monad after setting the coefficients to the offered array.
	 * @throws CladosMonadException This exception is thrown when the array offered
	 *                              for coordinates is of the wrong length.
	 */
	public &lt;T extends ProtoN &amp; Field &amp; Normalizable&gt; Monad setCoeff(T[] ppC) throws CladosMonadException {
<span class="pc bpc" id="L1536" title="3 of 6 branches missed.">		if (ppC.length != getAlgebra().getBladeCount() | ppC.length == 0)</span>
<span class="nc" id="L1537">			throw new CladosMonadException(this, &quot;Coefficient array passed for coefficient copy is wrong length&quot;);</span>

<span class="fc" id="L1539">		if 	(</span>
<span class="fc bfc" id="L1540" title="All 2 branches covered.">			(ppC[0] instanceof RealF) &amp; (getMode() == CladosField.REALF)</span>
<span class="fc bfc" id="L1541" title="All 2 branches covered.">		| 	(ppC[0] instanceof RealD) &amp; (getMode() == CladosField.REALD)</span>
<span class="fc bfc" id="L1542" title="All 2 branches covered.">		| 	(ppC[0] instanceof ComplexF) &amp; (getMode() == CladosField.COMPLEXF)</span>
<span class="pc bpc" id="L1543" title="1 of 4 branches missed.">		| 	(ppC[0] instanceof ComplexD) &amp; (getMode() == CladosField.COMPLEXD)</span>
			)
		{
<span class="fc" id="L1546">			scales.setWeightsArray(FListBuilder.copyOf(getMode(), ppC));</span>
<span class="fc" id="L1547">			setGradeKey();</span>
		} 
		else 
<span class="nc" id="L1550">			throw new CladosMonadException(this, &quot;Coefficient array passed for coefficient copy is different mode.&quot;);</span>

<span class="fc" id="L1552">		return this;</span>
	}

	/**
	 * Set the grade key for the monad. Never accept an externally provided key. Always recalculate it 
	 * after any of the unary or binary operations.
	 * &lt;br&gt;&lt;br&gt;
	 * While we are here, we ALSO set the sparseFlag. The nonZero coeff detection loop that fills gradeKey 
	 * is a grade detector, so if foundGrade is less than or equal to half gradeCount, sparseFlag is set 
	 * to true and false otherwise.
	 * &lt;br&gt;&lt;br&gt;
	 * Use this IF you set one of the weights manually by reaching into the scales.
	 * &lt;br&gt;&lt;br&gt;
	 * @return Monad this one after the grade key is set.
	 */
	public Monad setGradeKey() {
<span class="fc" id="L1568">		foundGrades = 0;</span>
<span class="fc" id="L1569">		gradeKey = 0;</span>

<span class="fc" id="L1571">		gradeStream().forEach(grade -&gt; {</span>
<span class="fc bfc" id="L1572" title="All 2 branches covered.">			if (getAlgebra().getGBasis().bladeOfGradeStream((byte) grade).parallel().anyMatch(</span>
<span class="fc" id="L1573">															blade -&gt; getWeights().isNotZeroAt(blade))){</span>
<span class="fc" id="L1574">				foundGrades++;</span>
<span class="fc" id="L1575">				gradeKey += (long) Math.pow(10, grade);</span>
			}
<span class="fc" id="L1577">		});</span>

<span class="fc bfc" id="L1579" title="All 2 branches covered.">		if (gradeKey == 0) {	//Special case for scalars. If no grades detected, scalar it must be.</span>
<span class="fc" id="L1580">			foundGrades++;</span>
<span class="fc" id="L1581">			gradeKey++;</span>
		}
<span class="fc bfc" id="L1583" title="All 2 branches covered.">		sparseFlag = (foundGrades &lt;= getAlgebra().getGradeCount() / 2) ? true : false;</span>
<span class="fc" id="L1584">		return this;</span>
	}

	/**
	 * Simple setter of the name of the monad.
	 * &lt;br&gt;
	 * @param pName String name of the monad to set
	 * @return Monad after setting the name.
	 */
	public Monad setName(String pName) {
<span class="fc" id="L1594">		name = pName;</span>
<span class="fc" id="L1595">		return this;</span>
	}

	/**
	 * Reset the weights for this Monad. Use of this method is not encouraged, 
	 * but there are reasonable use cases. Ideally one uses the Monad's own operation 
	 * methods to alter weights, but that applies mostly to physical models. In cases
	 * where a user directly manipulates weights, this method and the one for direct
	 * handling of weights is more suitable.
	 * &lt;br&gt;
	 * This method fails with an exception if the Scale object references a different
	 * basis than the one in the Algebra. No basis change is tolerated because the 
	 * scales relate to a basis which only makes sense with respect to an algebra.
	 * Future version will relax this requirement by tolerating Scales referencing a 
	 * Frame instead of requiring a connection to the canonical basis. 
	 * &lt;br&gt;
	 * Using this set method encourages developers to reuse old objects. While this
	 * is useful for avoiding object construction overhead, it is dangerous in that
	 * old references might linger enabling unexpected opportunities to edit weights.
	 * Caution is advised when this method is used while frequent reuse occurs.
	 * &lt;br&gt;
	 * @param &lt;T&gt;  ProtoN number from CladosF with all interfaces this time.
	 * @param pScale The Scale to change to... constructed on the same Basis as the current Scale
	 * @return Monad after setting the coefficients to the offered array.
	 * @throws CladosMonadException This exception is thrown when the scale offered
	 *                              doesn't share exactly the same Basis as the one it replaces.
	 */
	public &lt;T extends ProtoN &amp; Field &amp; Normalizable&gt; Monad setScale(Scale&lt;T&gt; pScale) throws CladosMonadException {
<span class="fc bfc" id="L1623" title="All 2 branches covered.">		if (pScale.getBasis() != scales.getBasis() )</span>
<span class="fc" id="L1624">			throw new CladosMonadException(this, &quot;Coefficient array offered uses a different basis &quot;);</span>
		
<span class="fc" id="L1626">		scales = pScale;</span>
<span class="fc" id="L1627">		setGradeKey();</span>

<span class="fc" id="L1629">		return this;</span>
	}

	/**
	 * Return the magnitude squared of the Monad
	 * &lt;br&gt;
	 * Since the map internal to Scale can accept any of the CladosF numbers as
	 * values, there is a cast to a 'generic' type within this method. This would
	 * normally cause warnings by the compiler since the generic named in the
	 * internal map IS a ProtoN child AND casting an unchecked type could fail
	 * at runtime.
	 * &lt;br&gt;
	 * That won't happen here when CladosF builders are used. They can't build
	 * anything that is NOT a ProtoN child. They can't even build a
	 * ProtoN instance directly. Therefore, only children can arrive as the
	 * value parameter of the 'put' function. Thus, there is no danger of a failed
	 * cast operation... until someone creates a new ProtoN child class and
	 * fails to update all builders.
	 * &lt;br&gt;
	 * @param &lt;T&gt; ProtoN number from CladosF without the interfaces this time.
	 * @return ProtoN but in practice it is always a child of ProtoN
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public &lt;T extends ProtoN&gt; T sqMagnitude() {
<span class="fc" id="L1653">		return (T) scales.modulusSQSum();</span>
	}

	/**
	 * Monad Subtraction: (this - pM) The two monads must be reference matches and use the same ProtoN 
	 * child. The first check involves a reference match which will spot algebra mismatches. 
	 * The next step involves trying subtraction and possibly catching exceptions that result from Scales 
	 * containing mutable weights.
	 * &lt;br&gt;
	 * @param pM Monad to be subtracted from this one
	 * @return Monad returned that has the passed monad subtracted from it.
	 */
	public Monad subtract(Monad pM) {
<span class="fc bfc" id="L1666" title="All 2 branches covered.">		if (!Monad.isReferenceMatch(this, pM))</span>
<span class="fc" id="L1667">			throw new IllegalArgumentException(&quot;Can't subtract monads without a reference match.&quot;);</span>

<span class="fc" id="L1669">		bladeStream().parallel().forEach(blade -&gt; {		//Monads are reference matches now</span>
			try {										//but their Scales don't realize that and we have
<span class="fc" id="L1671">				scales.get(blade).subtract(pM.scales.get(blade));</span>
<span class="nc" id="L1672">			} catch (FieldBinaryException e) {			//to check again because weights are mutable.</span>
<span class="nc" id="L1673">				throw new IllegalArgumentException(&quot;Can't subtract when cardinals don't match.&quot;);</span>
<span class="fc" id="L1674">			}</span>
<span class="fc" id="L1675">		});</span>
<span class="fc" id="L1676">		setGradeKey();</span>
<span class="fc" id="L1677">		return this;</span>
	}

	/**
	 * Simple setter method of the algebra for this monad.
	 * &lt;br&gt;
	 * It is NOT advisable to re-set algebras lightly. Avoid nulling them out.
	 * They carry the meaning of 'directions' in the underlying basis.
	 * &lt;br&gt;
	 * @param pA Algebra to set
	 * @return Monad after setting the algebra.
	 */
	protected Monad setAlgebra(Algebra pA) {
<span class="fc" id="L1690">		algebra = pA;</span>
<span class="fc" id="L1691">		return this;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>