<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Nyad.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Clados</a> &gt; <a href="index.source.html" class="el_package">org.interworldtransport.cladosG</a> &gt; <span class="el_source">Nyad.java</span></div><h1>Nyad.java</h1><pre class="source lang-java linenums">/*
 * &lt;h2&gt;Copyright&lt;/h2&gt; Â© 2025 Alfred Differ&lt;br&gt;
 * ------------------------------------------------------------------------ &lt;br&gt;
 * ---org.interworldtransport.cladosG.Nyad&lt;br&gt;
 * -------------------------------------------------------------------- &lt;br&gt;
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version. 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.&lt;br&gt;&lt;br&gt;
 * 
 * Use of this code or executable objects derived from it by the Licensee 
 * states their willingness to accept the terms of the license. &lt;br&gt; &lt;br&gt;
 * 
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.&lt;br&gt; &lt;br&gt;
 * 
 * ------------------------------------------------------------------------ &lt;br&gt;
 * ---org.interworldtransport.cladosG.Nyad&lt;br&gt;
 * ------------------------------------------------------------------------ &lt;br&gt;
 */
package org.interworldtransport.cladosG;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Optional;
import java.util.stream.Stream;

import org.interworldtransport.cladosF.Cardinal;
import org.interworldtransport.cladosF.FBuilder;
import org.interworldtransport.cladosF.CladosField;
import org.interworldtransport.cladosF.ProtoN;
import org.interworldtransport.cladosF.Field;
import org.interworldtransport.cladosF.Normalizable;
import org.interworldtransport.cladosGExceptions.*;

/**
 * Nyads are technically lists of monads that share a common foot, but do not necessarily share the same algebra.
 * In use they are the cladosG representation of an 'extensor'. While monads can directly represent geometry, 
 * nyads are maps using monads as operators where more than one monad is required. Monads are also operators by 
 * themselves, so nyads are extensions on the range of transformations represented.
 * &lt;br&gt;&lt;br&gt;
 * Examples&lt;br&gt;
 * Nyad arity = 0: Multivector Q	: No operand. It is what it is... but it can be composed with others.&lt;br&gt;
 * Nyad arity = 1: Mirror M 		: Reflection of an operand (Inverse mirror is computed then used.)&lt;br&gt;
 * Nyad arity = 1: Rotor R 			: Rotation of an operand (Inverse rotor is computed then used.)&lt;br&gt;
 * Nyad arity = 2: Mirrors M1, M2 	: Rotation as a double reflection of an operand.&lt;br&gt;
 * Nyad arity = n: Mirrors M1...Mn	: N-fold composition of reflections covers a lot of transformations.&lt;br&gt;
 * Nyad arity = p+q+r	: Single blade monads m1...m_p+q+r : Basis transformations not reached by reflections.&lt;br&gt;
 * Nyad arity = 2(p+q+r): Single blade monds for two distinct p+q+r algebras : Ken Greider's 'Connector' idea which
 * is like a basis transformation but between two distinct algebras.
 * &lt;br&gt;&lt;br&gt;
 * If the monads involved are of different algebras, there is no path to simplifying them. The nyad is essentially
 * a juxtapostion of monads that might be related through other objects, but not in the nyad. The juxtapostion
 * flag signals when there are no shared algebras.
 * &lt;br&gt;&lt;br&gt; 
 * If the monad are of the same algebra, this is a path to simplyfying them but it could be through multiplication 
 * or addition which isn't specified in the nyad. If it is through multiplication, then composition is possible. 
 * If it is through  addition, then summation is possible. Since only one flag is needed to signal summation and 
 * composition are possible, the composition flag suffices.
 * &lt;br&gt;&lt;br&gt;
 * Unary Operations : One nyad involved.&lt;br&gt;
 * 1) Weight		: Monads that share an algebra are added.&lt;br&gt; 
 * 2) Compose(L/R)	: Monads that share an algebra are multiplied where left -&gt; right is stack top -&gt; bottom.&lt;br&gt;
 * Binary Operations: Two nyads involved.&lt;br&gt;
 * 3) Append		: Monad list of one is appended to the other. Weight() operation is NOT performed.&lt;br&gt;
 * 4) Multiply(L/R)	: Monads sharing algebras are multiplied. Danglers are added as if multiplied by ONE.
 * &lt;br&gt;&lt;br&gt;
 * Each of these pairs implements concepts of addition and multiplication that might easily be recognized by other
 * names. For example, nyad's 'compose' is both multiplication and simplification. A nyad with two mirrorsfrom the 
 * same algebra can be used to rotate operands in the algebra, but the two mirrors can be kept separate or simplified
 * to create a rotor without changing what they nyad can do.
 * &lt;br&gt;&lt;br&gt;
 * Multiple Algebra Operations:&lt;br&gt;
 * TODO 5) Compression	: A monad in one algebra is cast to an algebra used by another monad then composed with it.&lt;br&gt;
 * Compression can be left or right sided or symmetric or antisymmetric versions. Projection then Composition.&lt;br&gt;
 * Examples of this operation can be found in the work of Ken Greider and his students in support of classical
 * and quantum field theories using Clifford algebras.
 * &lt;br&gt;&lt;br&gt;
 * The Nyad is an evolving class. It is meant to encompass extensors as Hestenes described them. Nyad's methods
 * will likely change in the near future as it is adapted to current uses that might not make use of 'extensor' 
 * as a term yet. If the operations become complicated enough, Nyad will be subclassed and specialized at the 
 * child class level instead of being turned into a hairball.
 * &lt;br&gt;&lt;br&gt;
 * NOTE: Nyads are Modal because they contain modal objects. Nyad does not directly refer to modal numbers, but 
 * mode protections are required to ensure Nyad does not mix representations of precision or complexity. Monads
 * are modal, so methods handling them must be also.
 * &lt;br&gt;&lt;br&gt;
 * ALSO NOTE: While Nyads are modal, they may not be Unitized. Nyads are the maps of things that may be unitized.
 * &lt;br&gt;&lt;br&gt;
 * @version 2.0
 * @author Dr Alfred W Differ
 */
public class Nyad implements Modal {
	/**
	 * Return true if the Monads in the two lists are GEqual and the nyads are reference matches. 
	 * Only monads sharing the same algebra name need to be checked against each other. 
	 * No check is to be made for equality between the monad names.
	 * &lt;br&gt;
	 * This method is needed to compare Nyads since comparing instances via their
	 * variable names only checks to see if both variables reference the same place
	 * in memory
	 * &lt;br&gt;
	 * @param pT Nyad to be tested (first one)
	 * @param pN  Nyad to be tested (the other one)
	 * @return boolean
	 */
	public static final boolean isNEqual(Nyad pT, Nyad pN) {
<span class="fc bfc" id="L112" title="All 2 branches covered.">		if (pT.arity() != pN.arity())				// Check if the Nyads are of the same order</span>
<span class="fc" id="L113">			return false;							// Return false if they are not</span>

<span class="fc bfc" id="L115" title="All 2 branches covered.">		if (pT.algrity() != pN.algrity())			// Check if the nyads algebra orders are the same</span>
<span class="fc" id="L116">			return false;							// Return false if they are not</span>
		
<span class="fc bfc" id="L118" title="All 2 branches covered.">		if (pT.getFoot() != pN.getFoot())			// Check if the feet match</span>
<span class="fc" id="L119">			return false;							// Return false if they don't	</span>
		
<span class="fc" id="L121">		boolean fcheck = pT.monadStream().allMatch(y -&gt; pN.monadStream().anyMatch(x -&gt; x.isGEqual(y)));</span>
<span class="fc" id="L122">		boolean bcheck = pN.monadStream().allMatch(y -&gt; pT.monadStream().anyMatch(x -&gt; x.isGEqual(y)));</span>
<span class="fc" id="L123">		return fcheck &amp; bcheck;						// These two ensure reflexive testing is complete</span>
													// Failures in one should stop the other, but the streams will
													// halt in a protected way where loops risk mutability.	
	}

	/**
	 * This method performs a strong test for a reference match. All properties of Nyads must match  except for names. 
	 * Each monad in a nyad must have a counterpart in the other that is a reference matches.  There must be NO unpaired 
	 * monads, so the algebra lists have to be identical to within sorting as well.
	 * 
	 * Only monads sharing the same algebra need to be checked against each other for reference matches. 
	 * For those in the same algebra, we make use of the isRefereceMatch method and compare the two.
	 * &lt;br&gt;
	 * @param pT Nyad
	 * @param pN  Nyad
	 * @return boolean
	 */
	public static final boolean isStrongReferenceMatch(Nyad pT, Nyad pN) {
<span class="fc bfc" id="L141" title="All 2 branches covered.">		if (pT.arity() != pN.arity())				// Check if the Nyads are of the same order</span>
<span class="fc" id="L142">			return false;							// Return false if they are not</span>
		
<span class="fc bfc" id="L144" title="All 2 branches covered.">		if (pT.algrity() != pN.algrity())			// Check if the nyads algebra orders are the same</span>
<span class="fc" id="L145">			return false;							// Return false if they are not</span>

<span class="fc bfc" id="L147" title="All 2 branches covered.">		if (pT.getFoot() != pN.getFoot())			// Check if the feet match</span>
<span class="fc" id="L148">			return false;							// Return false if they do not		</span>
		
<span class="fc" id="L150">		boolean fcheck = pT.monadStream().allMatch(y -&gt; pN.monadStream().anyMatch(x -&gt; Monad.isReferenceMatch(x, y)));</span>
<span class="fc" id="L151">		boolean bcheck = pN.monadStream().allMatch(y -&gt; pT.monadStream().anyMatch(x -&gt; Monad.isReferenceMatch(x, y)));</span>
<span class="fc" id="L152">		return fcheck &amp; bcheck;						// These two ensure reflexive testing is complete</span>
													// Failures in one should stop the other, but the streams will
													// halt in a protected way where loops risk mutability.	
	}

	/**
	 * This method performs a weak test for a reference match. It is similar to the strong reference match, but 
	 * tolerates dangling monads. Only monads in each nyad that share an algebra must reference match.
	 * &lt;br&gt;
	 * Unpaired monads (those with no algebra matching counterpart in the other nyad) are counted as matches 
	 * against unit scalars even though the matching unit scalar monad isn't present. The isUnitMatch*() method 
	 * compares two monads this time because the monad lists are already filtered to ensure algebras already match.
	 * &lt;br&gt;
	 * @param pT Nyad
	 * @param pN  Nyad
	 * @return boolean
	 */
	public static final boolean isWeakReferenceMatch(Nyad pT, Nyad pN) {
<span class="fc bfc" id="L170" title="All 2 branches covered.">		if (pT.getFoot() != pN.getFoot())			// Check to see if the Feet match</span>
<span class="fc" id="L171">			return false;							// Return false if they do not	</span>

<span class="fc bfc" id="L173" title="All 6 branches covered.">		if (pT.algrity() == 0 | pN.algrity() == 0)</span>
<span class="fc" id="L174">			return true;							// Edge case: AT LEAST one nyad is empty... so the other has danglers and passes.</span>

<span class="fc bfc" id="L176" title="All 2 branches covered.">		if (!pT.algebraStream().anyMatch(y -&gt; pN.algebraStream().anyMatch(x -&gt; x.equals(y)))) 										</span>
<span class="fc" id="L177">			return true;							// Edge case: ALL monads are danglers. Weak match passes by default</span>
		
<span class="fc" id="L179">		return  pT.algebraStream().anyMatch(y -&gt; 	// Pick an algebra in pT [Failure to match means algebra in both and unit match failed]</span>
<span class="fc" id="L180">					pT.monadInAlgebraStream(y).anyMatch(pTm -&gt; 	// Pick a monad in pT using the algebra and find anyMatch of</span>
<span class="fc" id="L181">						pN.monadInAlgebraStream(y).anyMatch(pNm -&gt; 		// Pick a monad in pN using the algebra and find anyMatch of</span>
<span class="pc bpc" id="L182" title="1 of 2 branches missed.">							Monad.isUnitMatch(pNm, pTm) | !pN.has(y)		// The two monads being unit matches or pT's being a dangler</span>
								)));
													// Any monad in pN not chosen for a check is a known dangler. No need to check it.
													// Any unit match for monads sharing an algebra suffices, so two nyads with 
													// two monads in the same algebra with different units will pass weak matching
													// but if they had differnt algebras (swapped) and the units swapped, they'd fail.
													// Examples filling in the truth table are obviously needed as test cases.
	}

	/**
	 * This is a boolean flag set to True when the monads ALL refer to the same
	 * algebra. Otherwise it should be false.
	 */
<span class="fc" id="L195">	private boolean compositionFlag = false;</span>

	/**
	 * This is a boolean flag set to True when the monads ALL refer to DIFFERENT
	 * algebras. Otherwise it should be false.
	 */
<span class="fc" id="L201">	private boolean jFlag = false;</span>

	/**
	 * This array is the list of algebras used in the Nyad.
	 */
	protected ArrayList&lt;Algebra&gt; algebraList;

	/**
	 * This is the Foot to which all the algebras of all monads should reference
	 */
	private Foot sharedFoot;

	/**
	 * This is the internal element supporting the Modal interface.
	 */
	private CladosField mode;

	/**
	 * This array is the list of Monads that makes up the NyadRealF. It will be tied
	 * to the footPoint members of each Monad as keys.
	 */
	protected ArrayList&lt;Monad&gt; monadList;

	/**
	 * All objects of this class have a name independent of all other features.
	 */
	protected String Name;

	/**
	 * Simple copy constructor of a Nyad. The passed Nyad will be copied in detail. This contructor is used most often to 
	 * get around operations that alter one of the nyads when the developer does not wish it to be altered.
	 * &lt;br&gt;&lt;br&gt;
	 * @param pN Nyad				copy this one
	 * @throws CladosNyadException 	One reason for this. The initialzing nyad is null. If instead the 'appendMonad' methods 
	 * 								complain the exception will arrive as an IllegalArgumentException.
	 */
	public Nyad(Nyad pN) throws CladosNyadException {
<span class="fc" id="L238">		this(pN.getName(), pN, true);</span>
<span class="fc" id="L239">	}</span>

	/**
	 * A basic constructor of a Nyad that starts with a Monad. The Monad will be copied and placed at the top of the list OR 
	 * reused based on pCopy The Foot, however, will be used exactly as is either way.
	 * &lt;br&gt;&lt;br&gt;
	 * @param pName String			new name of the nyad to be created
	 * @param pM    Monad			Single monad used to initiate this nyad.
	 * @param pCopy boolean 		True - Copy the monads!		False - Re-use the monads!
	 * @throws CladosNyadException 	One reason for this. The initialzing nyad is null. If instead the 'appendMonad' methods 
	 * 								complain the exception will arrive as an IllegalArgumentException.
	 */
<span class="fc" id="L251">	public Nyad(String pName, Monad pM, boolean pCopy) throws CladosNyadException {</span>
<span class="pc bpc" id="L252" title="1 of 2 branches missed.">		if (pM == null) 			throw new CladosNyadException(null, &quot;This nyad constructor requires initializing nyad.&quot;);</span>
		
<span class="fc" id="L254">		monadList = new ArrayList&lt;Monad&gt;(1);</span>
<span class="fc" id="L255">		algebraList = new ArrayList&lt;Algebra&gt;(1);</span>
		
<span class="fc" id="L257">		setName(pName);	</span>
<span class="fc" id="L258">		setFoot(pM.getAlgebra().getFoot());</span>
<span class="fc" id="L259">		mode = pM.getMode();</span>
		
<span class="fc bfc" id="L261" title="All 2 branches covered.">		if (pCopy)		appendACopy(pM);</span>
<span class="fc" id="L262">		else			append(pM);</span>
<span class="fc" id="L263">	}</span>

	/**
	 * A simple copy constructor of a Nyad. The passed Nyad will be copied
	 * without the name. This constructor is used most often to clone other objects
	 * in every way except name.
	 * &lt;br&gt;&lt;br&gt;
	 * The Foot object is re-used. The Algebra object is re-used. The Nyad's
	 * proto-number object is re-used. The Nyad's monad objects are copyied OR
	 * re-used depending on pCopy. 
	 * &lt;br&gt;&lt;br&gt;
	 * @param pName String			new name of the nyad to be created
	 * @param pN    Nyad			to be copied
	 * @param pCopy boolean 		True - Copy the monads!		False - Re-use the monads!
	 * @throws CladosNyadException 	One reason for this. The initialzing nyad is null. If instead the 'appendMonad' methods 
	 * 								complain the exception will arrive as an IllegalArgumentException.
	 */
<span class="fc" id="L280">	public Nyad(String pName, Nyad pN, boolean pCopy) throws CladosNyadException {</span>
<span class="pc bpc" id="L281" title="1 of 2 branches missed.">		if (pN == null) 			throw new CladosNyadException(null, &quot;This nyad constructor requires initializing monad.&quot;);</span>

<span class="fc bfc" id="L283" title="All 2 branches covered.">		if (pN.arity() == 0) 	throw new IllegalArgumentException(&quot;Offered Nyad to copy is empty.&quot;);</span>

<span class="fc" id="L285">		setName(pName);</span>
<span class="fc" id="L286">		setFoot(pN.getFoot());</span>
<span class="fc" id="L287">		mode = pN.getMonadAt(0).getMode();</span>
		
<span class="fc" id="L289">		monadList = new ArrayList&lt;Monad&gt;(pN.monadList.size());</span>
<span class="fc" id="L290">		algebraList = new ArrayList&lt;Algebra&gt;(pN.algebraList.size());</span>
<span class="fc bfc" id="L291" title="All 2 branches covered.">		if (pCopy)</span>
<span class="fc" id="L292">			pN.monadStream().forEach(x -&gt; {</span>
<span class="fc" id="L293">				try {appendACopy(x);} </span>
<span class="pc" id="L294">				catch (CladosNyadException e) {throw new IllegalArgumentException(&quot;Nyad copied changed during construction.&quot;);}</span>
<span class="fc" id="L295">			});</span>
		else 
<span class="fc" id="L297">			pN.monadStream().forEach(x -&gt; {</span>
<span class="fc" id="L298">				try {append(x);} </span>
<span class="pc" id="L299">				catch (CladosNyadException e) {throw new IllegalArgumentException(&quot;Nyad reused changed during construction.&quot;);}</span>
<span class="fc" id="L300">			});</span>
<span class="fc" id="L301">	}</span>

	/**
	 * This is just an alias for algebraList.stream().
	 * &lt;br&gt;&lt;br&gt;
	 * @return Stream of distinct algebras in use in this Nyad.
	 */
	public Stream&lt;Algebra&gt; algebraStream() {
<span class="fc" id="L309">		return algebraList.stream();</span>
	}


	/**
	 * Return the algebra order of this Nyad
	 * &lt;br&gt;&lt;br&gt;
	 * @return integer number of algebras present in the monad list
	 */
	public int algrity() {
<span class="fc" id="L319">		return algebraList.size();</span>
	}

	/**
	 * This method appends the monads from the offered nyad to this nyad's monadList.
	 * &lt;br&gt;&lt;br&gt;
	 * There are ways this method silently fails.&lt;br&gt;
	 * 1) Offer a nyad that does not share the same foot.&lt;br&gt;
	 * 2) Offer a nyad with numbers in a different mode. (Mixed precision or Rea/Complex).&lt;br&gt;
	 * If either these happen, this method just returns this nyad.
	 * &lt;br&gt;&lt;br&gt;
	 * The try/catch block internal to the stream that does the actual list appending won't happen because the possible ways it 
	 * happens are caught outside the stream with the silent fails. As a result, this method shouldn't throw anything unless
	 * some egregious error has occured.
	 * &lt;br&gt;&lt;br&gt;
	 * @param pN Nyad to be added to this one. 
	 * @return Nyad after the addition operation is complete
	 */
	public Nyad append(Nyad pN) {
<span class="nc bnc" id="L338" title="All 2 branches missed.">		if (pN == null) 				return this;</span>
<span class="nc bnc" id="L339" title="All 2 branches missed.">		if (pN.getMode() != mode)		return this;</span>
<span class="nc bnc" id="L340" title="All 2 branches missed.">		if (pN.getFoot() != sharedFoot)	return this;</span>

<span class="nc" id="L342">		pN.monadStream().forEach(m -&gt; {</span>
<span class="nc" id="L343">			try 							{ appendACopy(m); } </span>
<span class="nc" id="L344">			catch (CladosNyadException e) 	{ ; /* Every way this can happen is deflected by the initial checks */ }</span>
<span class="nc" id="L345">		});</span>
<span class="nc" id="L346">		resetFlags();</span>
<span class="nc" id="L347">		return this;</span>
	}

	/**
	 * Add another Monad to the list of monads in this nyad. This method re-uses the Monad offered 
	 * as a parameter, so the Nyad DOES reference it.
	 * &lt;br&gt;
	 * Be aware that this method silently disallows adding the same monad to the list again. 
	 * This prevents two entries in the monad list pointing at the same monad. If two ARE needed, 
	 * use the appendMonadCopy method.
	 * &lt;br&gt;
	 * @param pM Monad to append to the list
	 * @throws CladosNyadException Exception thrown if the foot of the new monad fails to match
	 * @return Nyad
	 */
	public Nyad append(Monad pM) throws CladosNyadException {
<span class="fc bfc" id="L363" title="All 2 branches covered.">		if (has(pM))	return this;					// If it is in the list... silently return.</span>

<span class="fc bfc" id="L365" title="All 2 branches covered.">		if (!pM.getAlgebra().getFoot().equals(getFoot()))</span>
<span class="fc" id="L366">						throw new CladosNyadException(this, &quot;Nyad / New Monad Foot mismatch&quot;);</span>

<span class="pc bpc" id="L368" title="1 of 2 branches missed.">		if (pM.getMode() != mode)</span>
<span class="nc" id="L369">						throw new CladosNyadException(this, &quot;Nyad / New Monad Mode mismatch&quot;);</span>

<span class="fc" id="L371">		monadList.ensureCapacity(monadList.size() + 1);	// Append monad to the list</span>
<span class="fc" id="L372">		monadList.add(pM);</span>
<span class="fc" id="L373">		resetFlags();</span>
<span class="fc" id="L374">		return this;</span>
	}

	/**
	 * Add another Monad to the list of monads in this nyad. This method creates a new copy 
	 * of the offered monad, so the Nyad does not wind up referencing the one passed in.
	 * &lt;br&gt;
	 * Be aware that this method silently allows adding the a monad to the list again. Two 
	 * references to the same monad are still avoided, but two monads will pass a GEquals test.
	 * &lt;br&gt;
	 * @param pM Monad to append to the list
	 * @throws CladosNyadException  Exception thrown if the foot of the new monad fails to match.
	 * @return Nyad
	 */
	public Nyad appendACopy(Monad pM) throws CladosNyadException {
<span class="fc bfc" id="L389" title="All 2 branches covered.">		if (!pM.getAlgebra().getFoot().equals(getFoot()))</span>
<span class="fc" id="L390">						throw new CladosNyadException(this, &quot;Nyad / New Monad Foot mismatch&quot;);</span>

<span class="pc bpc" id="L392" title="1 of 2 branches missed.">		if (pM.getMode() != mode)</span>
<span class="nc" id="L393">						throw new CladosNyadException(this, &quot;Nyad / New Monad Mode mismatch&quot;);</span>
		
<span class="fc" id="L395">		monadList.ensureCapacity(monadList.size() + 1);</span>
<span class="fc" id="L396">		monadList.add(GBuilder.copyOfMonad(pM));		// Add Monad to the ArrayList</span>
<span class="fc" id="L397">		resetFlags();</span>
<span class="fc" id="L398">		return this;</span>
	}

	/**
	 * Return the number of monads in this Nyad
	 * &lt;br&gt;&lt;br&gt;
	 * @return int
	 */
	public int arity() {
<span class="fc" id="L407">		return monadList.size();</span>
	}

/**
	 * Monads that share an algebra are 'composed'. Only one monad per algebra is kept after all is said and done. 
	 * The algebra list is used to search for monads in the list. When two are more are found, a new monad is created 
	 * that is a left-side product of all the others. When only one is found, it is simply copied. As a result of 
	 * this, an entirely new list is created and the old one replaced.
	 * &lt;br&gt;&lt;br&gt;
	 * @return Nyad after the algebra sharing modes are added as weights.
	 */
	public Nyad composeLeft() {
<span class="nc bnc" id="L419" title="All 2 branches missed.">		if (monadList.size() == 0)	return this;</span>
<span class="nc" id="L420">		ArrayList&lt;Monad&gt; newMonads = new ArrayList&lt;&gt;(monadList.size());</span>
<span class="nc" id="L421">		algebraStream().forEach(alg -&gt; {								//Stream through algebras in the algebra list</span>
<span class="nc" id="L422">			int tHop = find(alg);										//index of first monad at the algebra</span>
<span class="nc" id="L423">			Monad tCopy = GBuilder.copyOfMonad(getMonadAt(tHop));		//Yep. Copy of the first monad at the algebra</span>
<span class="nc bnc" id="L424" title="All 2 branches missed.">			while (findNext(alg, tHop) &gt;= 0){							//There exists a next monad at the algebra</span>
<span class="nc" id="L425">				tCopy.multiplyLeft(getMonadAt(findNext(alg, tHop)));	//right multiply it to the working copy</span>
<span class="nc" id="L426">				tHop = findNext(alg, tHop);								//and hop along the list to the next monad at the algebra</span>
			}
<span class="nc" id="L428">			newMonads.add(tCopy);										//Append the sum at the algebra to newMonads list</span>
<span class="nc" id="L429">		});</span>
<span class="nc" id="L430">		newMonads.trimToSize();</span>
<span class="nc" id="L431">		monadList = newMonads;											//Compose operation complete, so replace the monad list</span>
<span class="nc" id="L432">		resetFlags();													//and reset flags and algebra list.		</span>
<span class="nc" id="L433">		return this;</span>
	}

	/**
	 * Monads that share an algebra are 'composed'. Only one monad per algebra is kept after all is said and done. 
	 * The algebra list is used to search for monads in the list. When two are more are found, a new monad is created 
	 * that is a right-side product of all the others. When only one is found, it is simply copied. As a result of 
	 * this, an entirely new list is created and the old one replaced.
	 * &lt;br&gt;&lt;br&gt;
	 * @return Nyad after the algebra sharing modes are added as weights.
	 */
	public Nyad composeRight() {
<span class="nc bnc" id="L445" title="All 2 branches missed.">		if (monadList.size() == 0)	return this;</span>
<span class="nc" id="L446">		ArrayList&lt;Monad&gt; newMonads = new ArrayList&lt;&gt;(monadList.size());</span>
<span class="nc" id="L447">		algebraStream().forEach(alg -&gt; {								//Stream through algebras in the algebra list</span>
<span class="nc" id="L448">			int tHop = find(alg);										//index of first monad at the algebra</span>
<span class="nc" id="L449">			Monad tCopy = GBuilder.copyOfMonad(getMonadAt(tHop));		//Yep. Copy of the first monad at the algebra</span>
<span class="nc bnc" id="L450" title="All 2 branches missed.">			while (findNext(alg, tHop) &gt;= 0){							//There exists a next monad at the algebra</span>
<span class="nc" id="L451">				tCopy.multiplyRight(getMonadAt(findNext(alg, tHop)));	//right multiply it to the working copy</span>
<span class="nc" id="L452">				tHop = findNext(alg, tHop);								//and hop along the list to the next monad at the algebra</span>
			}
<span class="nc" id="L454">			newMonads.add(tCopy);										//Append the sum at the algebra to newMonads list</span>
<span class="nc" id="L455">		});</span>
<span class="nc" id="L456">		newMonads.trimToSize();</span>
<span class="nc" id="L457">		monadList = newMonads;											//Compose operation complete, so replace the monad list</span>
<span class="nc" id="L458">		resetFlags();													//and reset flags and algebra list.		</span>
<span class="nc" id="L459">		return this;</span>
	}

	/**
	 * Dyad style anti-symmetric multiplication: Project Right-&gt;Left then 0.5[left right - right left]
	 * &lt;br&gt;&lt;br&gt;
	 * Monads are placed in the same algebra and antisymmetrically multiplied. Most reference match tests will pass 
	 * because the right monad loses an algebra reference to which it once belonged. It is still possible for the 
	 * test to fail, though, because monad modes and cardnials might still be different.
	 * &lt;br&gt;&lt;br&gt;
	 * In a lot of cases, this method will produce nonsense. Simply defining the right side monad to be in the algebra 
	 * for the left monad destroys the meaning carried by the right monad unless the two algebras are essentially the same. 
	 * This happens, though, for cases where algebras are kept as book-keeping devices preventing simplification of operations.
	 * This is exactly the case for using nyads as juxtapositions.
	 * &lt;br&gt;&lt;br&gt;
	 * @param pKeep	int Index for the monad to be altered by multiplication. Operand
	 * @param pUse	int Index for the monad to DO the alteration bymultiplication. Operator
	 * @throws CladosNyadException 	This happens with an edge case involving a basis mis-match in the two algebras.
	 * @return Nyad this nyad after the alteration.
	 */
	public Nyad compressAntiSymm(int pKeep, int pUse) throws CladosNyadException {
<span class="fc bfc" id="L480" title="All 2 branches covered.">		if (validateMIndex(pKeep) &amp; validateMIndex(pUse)) 					// Check for monad list out of bounds errors.</span>
<span class="fc" id="L481">						compressAntiSymm(monadList.get(pKeep), monadList.get(pUse));</span>
<span class="fc" id="L482">		else 			throw new IndexOutOfBoundsException(&quot;Anti-Symmetric Compression out of range error&quot;);</span>

<span class="fc" id="L484">		return this;</span>
	}

	/**
	 * Dyad style anti-symmetric multiplication: Project Right-&gt;Left then 0.5[left right + right left]
	 * &lt;br&gt;&lt;br&gt;
	 * Monads are placed in the same algebra and symmetrically multiplied. Most reference match tests will pass 
	 * because the right monad loses an algebra reference to which it once belonged. It is still possible for the 
	 * test to fail, though, because monad modes and cardnials might still be different.
	 * &lt;br&gt;&lt;br&gt;
	 * In a lot of cases, this method will produce nonsense. Simply defining the right side monad to be in the algebra 
	 * for the left monad destroys the meaning carried by the right monad unless the two algebras are essentially the same. 
	 * This happens, though, for cases where algebras are kept as book-keeping devices preventing simplification of operations.
	 * This is exactly the case for using nyads as juxtapositions.
	 * &lt;br&gt;&lt;br&gt;
	 * @param pKeep Monad in the left multiplication role. (This is the one with the algebra that is kept.)
	 * @param pUse 	Monad in the right multiplication role. (This one looses its algebra reference and gets REMOVED FROM NYAD)
	 * @throws CladosNyadException 	This happens with an edge case involving a basis mis-match in the two algebras.
	 * @return Nyad this nyad after the alteration.
	 */
	public Nyad compressAntiSymm(Monad pKeep, Monad pUse) throws CladosNyadException {
<span class="pc bpc" id="L505" title="1 of 2 branches missed.">		if (pKeep.getAlgebra().getBasis() != pUse.getAlgebra().getBasis()) 	// Proceed only if Basis is exact match</span>
<span class="nc" id="L506">						throw new CladosNyadException(this, &quot;Symmetric Compression requires exact Basis match.&quot;);</span>
		
<span class="fc bfc" id="L508" title="All 4 branches covered.">		if (!this.has(pKeep) || !this.has(pUse))							// Proceed only if both monads in nyad.</span>
<span class="fc" id="L509">						throw new CladosNyadException(this, &quot;Symmetric Compression requires monads be in the nyad.&quot;);</span>

<span class="fc" id="L511">		pUse = Monad.projectReference(pKeep, pUse);							// Right Monad is ALTERED HERE!</span>
<span class="fc" id="L512">		pKeep.commutator(pUse).scale(0.5);								// Now do the deed. (Precision doesn't matter)</span>
<span class="fc" id="L513">		monadList.remove(pUse);												// Right Monad is REMOVED HERE!</span>
<span class="fc" id="L514">		monadList.trimToSize();</span>
<span class="fc" id="L515">		resetFlags();														// Work out consequences</span>
<span class="fc" id="L516">		return this;</span>
	}

	/**
	 * Dyad style symmetric multiplication: Project Right-&gt;Left then 0.5[left right + right left]
	 * &lt;br&gt;&lt;br&gt;
	 * Monads are placed in the same algebra and symmetrically multiplied. Most reference match tests will pass 
	 * because the right monad loses an algebra reference to which it once belonged. It is still possible for the 
	 * test to fail, though, because monad modes and cardnials might still be different.
	 * &lt;br&gt;&lt;br&gt;
	 * In a lot of cases, this method will produce nonsense. Simply defining the right side monad to be in the algebra 
	 * for the left monad destroys the meaning carried by the right monad unless the two algebras are essentially the same. 
	 * This happens, though, for cases where algebras are kept as book-keeping devices preventing simplification of operations.
	 * This is exactly the case for using nyads as juxtapositions.
	 * &lt;br&gt;&lt;br&gt;
	 * @param pKeep	int Index for the monad to be altered by multiplication. Operand
	 * @param pUse	int Index for the monad to DO the alteration bymultiplication. Operator
	 * @throws CladosNyadException 	This happens with an edge case involving a basis mis-match in the two algebras.
	 * @return Nyad this nyad after the alteration.
	 */
	public Nyad compressSymm(int pKeep, int pUse) throws CladosNyadException {
<span class="fc bfc" id="L537" title="All 2 branches covered.">		if (validateMIndex(pKeep) &amp; validateMIndex(pUse)) 						// Check for monad list out of bounds errors.</span>
<span class="fc" id="L538">						compressSymm(monadList.get(pKeep), monadList.get(pUse));</span>
<span class="fc" id="L539">		else 			throw new IndexOutOfBoundsException(&quot;Symmetric Compression out of range error&quot;);</span>
		
<span class="fc" id="L541">		return this;</span>
	}

	/**
	 * Dyad style symmetric multiplication: Project Right-&gt;Left then 0.5[left right + right left]
	 * &lt;br&gt;&lt;br&gt;
	 * Monads are placed in the same algebra and symmetrically multiplied. Most reference match tests will pass 
	 * because the right monad loses an algebra reference to which it once belonged. It is still possible for the 
	 * test to fail, though, because monad modes and cardnials might still be different.
	 * &lt;br&gt;&lt;br&gt;
	 * In a lot of cases, this method will produce nonsense. Simply defining the right side monad to be in the algebra 
	 * for the left monad destroys the meaning carried by the right monad unless the two algebras are essentially the same. 
	 * This happens, though, for cases where algebras are kept as book-keeping devices preventing simplification of operations.
	 * This is exactly the case for using nyads as juxtapositions.
	 * &lt;br&gt;&lt;br&gt;
	 * @param pKeep Monad in the left multiplication role. (This is the one with the algebra that is kept.)
	 * @param pUse Monad in the right multiplication role. (This one looses its algebra reference and gets REMOVED FROM NYAD)
	 * @throws CladosNyadException 	This happens with an edge case involving a basis mis-match in the two algebras.
	 * @return Nyad this nyad after the alteration.
	 */
	public Nyad compressSymm(Monad pKeep, Monad pUse) throws CladosNyadException {
<span class="pc bpc" id="L562" title="1 of 2 branches missed.">		if (pKeep.getAlgebra().getBasis() != pUse.getAlgebra().getBasis()) 	// Proceed only if Basis is exact match</span>
<span class="nc" id="L563">						throw new CladosNyadException(this, &quot;Symmetric Compression requires exact Basis match.&quot;);</span>
		
<span class="fc bfc" id="L565" title="All 4 branches covered.">		if (!this.has(pKeep) || !this.has(pUse))							// Proceed only if both monads in nyad.</span>
<span class="fc" id="L566">						throw new CladosNyadException(this, &quot;Symmetric Compression requires monads be in the nyad.&quot;);</span>

<span class="fc" id="L568">		pUse = Monad.projectReference(pKeep, pUse);							// Right Monad is ALTERED HERE!</span>
<span class="fc" id="L569">		pKeep.anticommutator(pUse).scale(0.5);							// Now do the deed. (Precision doesn't matter)</span>
<span class="fc" id="L570">		monadList.remove(pUse);												// Right Monad is REMOVED HERE!</span>
<span class="fc" id="L571">		monadList.trimToSize();</span>
<span class="fc" id="L572">		resetFlags();														// Work out consequences</span>
<span class="fc" id="L573">		return this;</span>
	}

	/**
	 * Create a new monad for this nyad using the prototype field and then append it to the end of the monadList. 
	 * A 'zero' for the new algebra will be added to the list. This method creates a new algebra using the offered 
	 * name and signature. It is not a copy method.
	 * &lt;br&gt;
	 * @param pMonadName    String
	 * @param pAlgebraName String
	 * @param pSig     String
	 * @param pCard    String
	 * @throws CladosMonadException		This exception is thrown when the new monad constructor fails.
	 * @throws BadSignatureException	This exception is thrown when signature is rejected as invalid.
	 * @throws CladosNyadException		This exception is thrown when the new monad cannot be appended. 
	 * 									Perhaps there is a reference mismatch or the new monad failed construction.
	 * @return Nyad
	 */
	public Nyad create(String pMonadName, String pAlgebraName, String pSig, String pCard)
							throws 			BadSignatureException, CladosException, CladosNyadException {
																			//Prepare Cardinal. Re-use where possible.
<span class="fc bfc" id="L594" title="All 2 branches covered.">		Cardinal tCard = (pCard == null) ? Cardinal.generate(getMode()) : FBuilder.createCardinal(pCard);</span>
																		
<span class="fc" id="L596">		Algebra tAlg = null;												//Prepare algebra for monad if needed. Re-use where possible</span>
<span class="fc" id="L597">		Optional&lt;Algebra&gt; foundAlg = algebraStream().filter(x -&gt; x.getAName().equals(pAlgebraName)).findFirst();</span>
<span class="fc bfc" id="L598" title="All 2 branches covered.">		if(foundAlg.isPresent())		tAlg = foundAlg.get();				//Algebra found by name, referenced, then OFFERED SIGNATURE IS IGNORED</span>
		else {																//Have to construct algebra not found. Signature gets used.
<span class="fc" id="L600">			Optional&lt;GProduct&gt; foundGP = GCache.INSTANCE.findGProduct(pSig);</span>
<span class="fc bfc" id="L601" title="All 2 branches covered.">			tAlg = (foundGP.isPresent()) ? GBuilder.createAlgebraWithFootGP(sharedFoot, foundGP.get(), pAlgebraName)</span>
<span class="fc" id="L602">										 : GBuilder.createAlgebraWithFoot(sharedFoot, pAlgebraName, pSig);				</span>
		}
<span class="fc" id="L604">		Scale&lt;?&gt; tScale = new Scale&lt;&gt;(mode, tAlg.getBasis(), tCard);		//Now make a ZERO Scale&lt;?&gt; w/o naming the ProtoN child</span>

<span class="fc" id="L606">		append(GBuilder.createMonadWithAlgebra(tScale, tAlg, pMonadName));	//Now append a newly constructed monad</span>
<span class="fc" id="L607">		return this;														//All done!</span>
	}

	/**
	 * Each of the Monads is turned into its PS Dual from the left.
	 * &lt;br&gt;
	 * @return Nyad after it has been altered
	 */
	public Nyad dualLeft() {
<span class="fc" id="L616">		monadStream().forEach(tSpot -&gt; tSpot.multiplyByPSLeft());</span>
<span class="fc" id="L617">		return this;</span>
	}

	/**
	 * Each of the Monads is turned into its PS Dual from the right.
	 * &lt;br&gt;
	 * @return Nyad after it has been altered.
	 */
	public Nyad dualRight() {
<span class="fc" id="L626">		monadStream().forEach(tSpot -&gt; tSpot.multiplyByPSRight());</span>
<span class="fc" id="L627">		return this;</span>
	}

	/**
	 * Overridden Equals method from Object.
	 * This ensures reference equality is the standard. They must literally be the same object to be equal.
	 * @return boolean check for reference equality
	 */
	@Override
	public boolean equals(Object obj) {
<span class="nc bnc" id="L637" title="All 2 branches missed.">		return (this == obj);</span>
	}

	/**
	 * Return an integer pointing to a monad that uses the algebra referenced. If more than
	 * one monad uses the algebra, the returned integer will point at the first one in the list.
	 * &lt;br&gt;
	 * @param pAlg Algebra used to filter the monads to find the first to use it.
	 * @return int index of the first monad found using the offered algebra. -1 if none are found.
	 */
	public int find(Algebra pAlg) {
<span class="fc" id="L648">		Optional&lt;Monad&gt; foundThis = monadInAlgebraStream(pAlg).findFirst();</span>
		
<span class="fc bfc" id="L650" title="All 2 branches covered.">		if (foundThis.isEmpty())			return -1;</span>
<span class="fc" id="L651">		return monadList.indexOf(foundThis.get());</span>
	}

	/**
	 * Return an integer pointing to a monad that equals the referenced one. If more than one monad 
	 * might match, the returned integer will point at the first one in the list.
	 * &lt;br&gt;
	 * @param pIn Monad used to filter the monads to find the first one.
	 * @return int index of the first monad found. -1 if none are found.
	 */
	public int find(Monad pIn) {
<span class="fc bfc" id="L662" title="All 2 branches covered.">		Optional&lt;Monad&gt; foundThis = monadStream().filter(pM -&gt; pM == pIn).findFirst();</span>
		
<span class="fc bfc" id="L664" title="All 2 branches covered.">		if (foundThis.isEmpty())			return -1;</span>
<span class="fc" id="L665">		return monadList.indexOf(foundThis.get());				</span>
	}

	/**
	 * Return the index for monad matching requested name within the nyad if found.
	 * &lt;br&gt;
	 * @param pName String name of the monad to use in the stream filter to find it
	 * @return int index of the first monad found to match the name. -1 if nothing found.
	 */
	public int find(String pName) {
<span class="fc" id="L675">		Optional&lt;Monad&gt; foundThis = monadStream().filter(pM -&gt; pName.equals(pM.getName())).findFirst();</span>
		
<span class="fc bfc" id="L677" title="All 2 branches covered.">		if(foundThis.isEmpty())			return -1;</span>
<span class="fc" id="L678">		return monadList.indexOf(foundThis.get());</span>
	}

	/**
	 * Return an integer larger than pStart pointing to a monad in the nyad that
	 * uses the algebra referenced in the parameter.
	 * &lt;br&gt;
	 * @param pAlg   Algebra used to filter the monad stream to find the next use.
	 * @param pStart int index of the next monad found. -1 if none found.
	 * @return int
	 */
	public int findNext(Algebra pAlg, int pStart) {
<span class="fc" id="L690">		Optional&lt;Monad&gt; foundThis = monadStream().skip(pStart).filter(x -&gt; x.getAlgebra().equals(pAlg)).findFirst();</span>
		
<span class="fc bfc" id="L692" title="All 2 branches covered.">		if (foundThis.isEmpty())			return -1;</span>
<span class="fc" id="L693">		return monadList.indexOf(foundThis.get());</span>
	}

	/**
	 * Return the element of the array of Algebras at the jth index.
	 * &lt;br&gt;
	 * @param pIndex int
	 * @return Algebra
	 */
	public Algebra getAlgebraAt(int pIndex) {
<span class="fc bfc" id="L703" title="All 2 branches covered.">		if (validateAIndex(pIndex))			return algebraList.get(pIndex);</span>
<span class="fc" id="L704">		return null;</span>
	}

	/**
	 * Simple getter for the Foot for which the nyad relies
	 * &lt;br&gt;
	 * @return Foot
	 */
	public Foot getFoot() {
<span class="fc" id="L713">		return sharedFoot;</span>
	}

	/**
	 * This answers a question concerning which type of ProtoN children are used. The nyad itself
	 * isn't modal, but its monads have an implicit dependence.
	 * &lt;br&gt;&lt;br&gt;
	 * @return CladosField mode for this monad
	 */
	@Override
	public CladosField getMode() {
<span class="fc" id="L724">		return mode;</span>
	}

	/**
	 * Return the element of the array of Monads at the jth index. If the index is out of bounds
	 * this method silently returns with a null.
	 * &lt;br&gt;
	 * @param pIndex int
	 * @return Monad
	 */
	public Monad getMonadAt(int pIndex) {
<span class="fc bfc" id="L735" title="All 2 branches covered.">		if(validateMIndex(pIndex))			return monadList.get(pIndex);</span>
<span class="fc" id="L736">		return null;</span>
	}

	/**
	 * Simple getter method of the name of a nyad.
	 * &lt;br&gt;
	 * @return String name of the nyad.
	 */
	public String getName() {
<span class="fc" id="L745">		return Name;</span>
	}

	/**
	 * Return a boolean stating whether or not the nyad has a monad using the algebra offered. 
	 * More than one might exist in the nyad. One is enough for a True response.
	 * &lt;br&gt;
	 * @param pAlg Algebra to be checked to see if it is used in the nyad anywhere.
	 * @return boolean
	 */
	public boolean has(Algebra pAlg) {
<span class="fc" id="L756">		return algebraStream().filter(x -&gt; (x.equals(pAlg))).findAny().isPresent();			</span>
	}

	/**
	 * This method reports on whether the offered monad is in the nyad's list. If it is in the list 
	 * more than once it is the same as being present only once.
	 * &lt;br&gt;
	 * @param pIn Monad used to filter the monads to find the first one.
	 * @return boolean True if monad found in the list.
	 */
	public boolean has(Monad pIn) {
<span class="fc bfc" id="L767" title="All 2 branches covered.">		return monadStream().filter(pM -&gt; pM == pIn).findFirst().isPresent();</span>
	}

	/**
	 * Return a boolean stating whether or not the nyad contains the named monad.
	 * &lt;br&gt;
	 * @param pName String
	 * @return boolean
	 */
	public boolean has(String pName) {
<span class="fc bfc" id="L777" title="All 2 branches covered.">		return monadStream().filter(x -&gt; x.getName() == pName).findAny().isPresent();		</span>
	}

	/**
	 * This method finds how often a particular algebra shows up in use by monads in
	 * the nyad. Results could range from zero to nyadOrder.
	 * &lt;br&gt;
	 * @param pAlg Algebra
	 * @return int This method counts how many instances of the algebra are present
	 *         in monads in the nyad
	 */
	public long howManyUsing(Algebra pAlg) {
<span class="fc" id="L789">		return monadInAlgebraStream(pAlg).count();</span>
	}

	/**
	 * If the monads listed within a nyad are all of the same algebra, the nyad is modeling
	 * a composition of monads without simplifying them. The jFlag might be true or false
	 * depending on the monad count. What matters is algebra count = 1.
	 * &lt;br&gt;
	 * This method returns the compositionFlag. No attempt is made to check flag correctness.
	 * &lt;br&gt;
	 * @return boolean True if nyad's monads are all of the same algebra
	 */
	public boolean isComposition() {
<span class="fc" id="L802">		return compositionFlag;</span>
	}

	/**
	 * If the monads listed within a nyad are all of a different algebra, the nyad is modeling a
	 * juxtaposition and the jFlag should be set to true. The compositionFlag might be true or false
	 * depending on whether there is more than one monad. What matters is algebra count = monad count.
	 * &lt;br&gt;
	 * This method returns that flag. That's all. No attempt is made to check flag correctness.
	 * &lt;br&gt;
	 * @return boolean True if nyad is strong meaning each Monad is of a different
	 *         algebra False if nyad's monads double up on any particular algebra
	 */
	public boolean isJuxtaposition() {
<span class="fc" id="L816">		return jFlag;</span>
	}

	/**
	 * This method returns true when there are more monads than algebras and at least two of each.
	 * &lt;br&gt;
	 * @return boolean False if nyad is a juxtaposition or a composition. True otherwise.
	 */
	public boolean isMixed() {
<span class="fc bfc" id="L825" title="All 4 branches covered.">		return !jFlag &amp; !compositionFlag;</span>
	}

	/**
	 * This method determines whether or not the Nyad is a pscalar in the algebra in question. 
	 * It works essentially the same way as isScalarAt. It checks all monads using the offered algebra.
	 * &lt;br&gt;
	 * The edge case present in isScalarAt is not present here so tests for proper function of this 
	 * method should try empty nyads and nyads without monads using this algebra.
	 * &lt;br&gt;
	 * @param pAlg Algebra offered as a filter for this test.
	 * @return boolean returned if all monads (at least one) in the algebra test true for isGrade(max).
	 */
	public boolean isPScalarAt(Algebra pAlg) {
<span class="fc" id="L839">		int maxGrade = pAlg.getGradeCount() - 1;		// find pAlg's max grade</span>
<span class="fc" id="L840">		final long count1 = howManyUsing(pAlg);			// this could be zero or all the monads</span>
<span class="fc" id="L841">		final long count2 = monadInAlgebraStream(pAlg).filter(tM -&gt; Monad.isGrade(tM, maxGrade)).count();</span>
<span class="pc bpc" id="L842" title="3 of 6 branches missed.">		return (count1 &gt; 0) &amp; (count2 &gt; 0) &amp; (count1 == count2);</span>
	}

	/**
	 * This method determines whether the Nyad is a scalar in the algebra in question.
	 * &lt;br&gt;
	 * This method counts the number of monads using the algebra in the first stream.
	 * It then counts the streamed monads in that algebra and filters them for scalar grade.
	 * If the two counts match, then all monads in that algebra are scalars.
	 * &lt;br&gt;
	 * One edge case involves the algebra not being present in the nyad at all. In that case  both counts 
	 * will be zero and this test will pass. That represents how we can append a monad set to scalar = 1 
	 * without changing how the nyad functions in compositions or as scalar = 0 without changing how it 
	 * behaves in additions.
	 * &lt;br&gt;
	 * @param pAlg Algebra offered as a filter for this test.
	 * @return boolean returned if all monads (even none) in the algebra test true for isGrade(0).
	 */
	public boolean isScalarAt(Algebra pAlg) {
<span class="fc" id="L861">		final long count1 = howManyUsing(pAlg);		// this could be zero or all the monads</span>
<span class="fc" id="L862">		final long count2 = monadInAlgebraStream(pAlg).filter(tM -&gt; Monad.isGrade(tM, 0)).count();</span>
<span class="fc bfc" id="L863" title="All 2 branches covered.">		return (count1 == count2);</span>
	}

	/**
	 * This is just an alias for monadList.stream().
	 * &lt;br&gt;
	 * @param pAlg Algebra to use as a filter on the monad stream.
	 * @return Stream of distinct monads listed in this Nyad.
	 */
	public Stream&lt;Monad&gt; monadInAlgebraStream(Algebra pAlg) {
<span class="fc" id="L873">		return monadList.stream().filter(x -&gt; x.getAlgebra().equals(pAlg));</span>
	}

	/**
	 * This is just an alias for monadList.reversed().stream(). There are a number of internal uses for a reversed
	 * stream of the monads, but the biggest will likely be how it reverse streams a stack of monads for compositions.
	 * &lt;br&gt;
	 * @return Stream of distinct monads listed in reverse.
	 */
	public Stream&lt;Monad&gt; monadReverseStream() {
<span class="nc" id="L883">		return monadList.reversed().stream();</span>
	}

	/**
	 * This is just an alias for monadList.stream() where each of the monads has been reversed. 
	 * The biggest use will probably be with conjugation/sandwich products involving stacks.
	 * &lt;br&gt;
	 * @return Stream of distinct reversed monads.
	 */
	public Stream&lt;Monad&gt; monadsReversedStream() {
<span class="nc" id="L893">		return monadList.stream().map(pM -&gt; pM.reverse());</span>
	}

	/**
	 * This is just an alias for monadList.stream(). There are a number of internal uses for a stream
	 * of the monads in this nyad, but the biggest will likely be how it streams a stack of monads
	 * for compositions.
	 * &lt;br&gt;
	 * @return Stream of distinct monads listed in this Nyad.
	 */
	public Stream&lt;Monad&gt; monadStream() {
<span class="fc" id="L904">		return monadList.stream();</span>
	}

	/**
	 * This method appends the monads from the offered nyad to this nyad's monadList and then composes. 
	 * &lt;br&gt;&lt;br&gt;
	 * 'This' nyad is treated as the right monad stack and all compositions are done with left side multiplication. 
	 * &lt;br&gt;&lt;br&gt;
	 * @param pN Nyad to be multiplied with this one. 
	 * @return Nyad after the operation is complete
	 */
	public Nyad multiplyLeft(Nyad pN) {
<span class="nc" id="L916">		this.append(pN);</span>
<span class="nc" id="L917">		this.composeLeft();		</span>
<span class="nc" id="L918">		return this;</span>
	}

	/**
	 * This method appends the monads from the offered nyad to this nyad's monadList and then composes. 
	 * &lt;br&gt;&lt;br&gt;
	 * 'This' nyad is treated as the left monad stack and all compositions are done with right side multiplication. 
	 * &lt;br&gt;&lt;br&gt;
	 * @param pN Nyad to be multiplied with this one. 
	 * @return Nyad after the operation is complete
	 */
	public Nyad multiplyRight(Nyad pN) {
<span class="nc" id="L930">		this.append(pN);</span>
<span class="nc" id="L931">		this.composeRight();		</span>
<span class="nc" id="L932">		return this;</span>
	}

	/**
	 * This method takes a pair of monads (keep, use) and multiplies the left one by the right one from the right.
	 * When it is done, the left monad is changed and the right monad is removed from the nyad. Finding these monads
	 * is the task of this method... then it hands off to the similarly named method that accepts the monads directly.
	 * &lt;br&gt;&lt;br&gt;
	 * @param pKeep	int Index for the monad to be altered by multiplication. Operand
	 * @param pUse	int Index for the monad to DO the alteration bymultiplication. Operator
	 * @throws CladosMonadException	This happens if the monad pair fail a reference match test
	 * @throws CladosNyadException	This happens if the monad pair are not in the nyad
	 * @return Nyad this nyad after the alteration.
	 * 
	 */
	public Nyad multiplyLeftward(int pKeep, int pUse) throws CladosNyadException, CladosMonadException {
<span class="pc bpc" id="L948" title="1 of 2 branches missed.">		if (validateMIndex(pKeep) &amp; validateMIndex(pUse)) 					// Check for monad list out of bounds errors.</span>
<span class="fc" id="L949">						multiplyLeftward(monadList.get(pKeep), monadList.get(pUse));</span>
<span class="nc" id="L950">		else			throw new IndexOutOfBoundsException(&quot;Symmetric Compression out of range error&quot;);</span>
		
<span class="fc" id="L952">		return this;</span>
	}

	/**
	 * This method takes a pair of monads (keep, use) and multiplies the left one by the right one from the right.
	 * When it is done, the left monad is changed and the right monad is removed from the nyad.
	 * &lt;br&gt;&lt;br&gt;
	 * @param pKeep Monad to be altered by multiplication. Operand
	 * @param pUse 	Monad to DO the alteration bymultiplication. Operator
	 * @return Nyad	after the multiplication is complete and the 'use' monad removed
	 * @throws CladosMonadException	This happens if the monad pair fail a reference match test
	 * @throws CladosNyadException	This happens if the monad pair are not in the nyad
	 */
	public Nyad multiplyLeftward(Monad pKeep, Monad pUse) throws CladosMonadException, CladosNyadException {
<span class="pc bpc" id="L966" title="1 of 2 branches missed.">		if (!Monad.isReferenceMatch(pKeep, pUse)) 				// Proceed only if they reference match.</span>
<span class="nc" id="L967">						throw new CladosMonadException(pKeep, &quot;Monad pair fails reference match for multiplication onto left.&quot;);</span>
		
<span class="pc bpc" id="L969" title="2 of 4 branches missed.">		if (!this.has(pKeep) || !this.has(pUse))				// Proceed only if both monads in nyad.</span>
<span class="nc" id="L970">						throw new CladosNyadException(this, &quot;Monad pair must be in nyad for multiplication onto left.&quot;);</span>
		
<span class="fc" id="L972">		pKeep.multiplyRight(pUse);								// Only now can we do the deed.</span>
<span class="fc" id="L973">		monadList.remove(pUse);									// Right Monad is REMOVED HERE!</span>
<span class="fc" id="L974">		monadList.trimToSize();</span>
<span class="fc" id="L975">		resetFlags();											// Work out consequences</span>

<span class="fc" id="L977">		return this;</span>
	}

	/**
	 * This method takes a pair of monads (Use, keep) and multiplies the right one by the left one from the left.
	 * When it is done, the right monad is changed and the left monad is removed from the nyad. Finding these monads
	 * is the task of this method... then it hands off to the similarly named method that accepts the monads directly.
	 * &lt;br&gt;&lt;br&gt;
	 * @param pKeep	int Index for the monad to be altered by multiplication. Operand
	 * @param pUse	int Index for the monad to DO the alteration bymultiplication. Operator
	 * @throws CladosMonadException	This happens if the monad pair fail a reference match test
	 * @throws CladosNyadException	This happens if the monad pair are not in the nyad
	 * @return Nyad this nyad after the alteration.
	 * 
	 */
	public Nyad multiplyRightward(int pKeep, int pUse) throws CladosNyadException, CladosMonadException {
<span class="pc bpc" id="L993" title="1 of 2 branches missed.">		if (validateMIndex(pKeep) &amp; validateMIndex(pUse)) 					// Check for monad list out of bounds errors.</span>
<span class="fc" id="L994">						multiplyRightward(monadList.get(pUse), monadList.get(pKeep));</span>
<span class="nc" id="L995">		else 			throw new IndexOutOfBoundsException(&quot;Symmetric Compression out of range error&quot;);</span>

<span class="fc" id="L997">		return this;</span>
	}

	/**
	 * This method takes a pair of monads (Use, keep) and multiplies the right one by the left one from the left.
	 * When it is done, the right monad is changed and the left monad is removed from the nyad.
	 * &lt;br&gt;&lt;br&gt;
	 * @param pUse 	Monad to DO the alteration bymultiplication. Operator
	 * @param pKeep Monad to be altered by multiplication. Operand
	 * @return Nyad	after the multiplication is complete and the 'use' monad removed
	 * @throws CladosMonadException	This happens if the monad pair fail a reference match test
	 * @throws CladosNyadException	This happens if the monad pair are not in the nyad
	 */
	public Nyad multiplyRightward(Monad pUse, Monad pKeep) throws CladosMonadException, CladosNyadException {
<span class="pc bpc" id="L1011" title="1 of 2 branches missed.">		if (!Monad.isReferenceMatch(pUse, pKeep)) 				// Proceed only if they reference match.</span>
<span class="nc" id="L1012">						throw new CladosMonadException(pUse, &quot;Monad pair fails reference match for multiplication onto right.&quot;);</span>
		
<span class="pc bpc" id="L1014" title="2 of 4 branches missed.">		if (!this.has(pUse) || !this.has(pKeep))				// Proceed only if both monads in nyad.</span>
<span class="nc" id="L1015">						throw new CladosNyadException(this, &quot;Monad pair must be in nyad for multiplication onto right.&quot;);</span>

<span class="fc" id="L1017">		pKeep.multiplyLeft(pUse);								// Only now can we do the deed.</span>
<span class="fc" id="L1018">		monadList.remove(pUse);									// Left Monad is REMOVED HERE!</span>
<span class="fc" id="L1019">		monadList.trimToSize();</span>
<span class="fc" id="L1020">		resetFlags();											// Work out consequences</span>

<span class="fc" id="L1022">		return this;</span>
	}

	/**
	 * This method takes the Monad at the k'th position in the list and swaps it for
	 * the one in the k-1 position if there is one there. If the index points to
	 * the first Monad, this function silently returns with no pop action.
	 * &lt;br&gt;
	 * @param pIndex int at which the pop is to occur
	 * @return Nyad this nyad after alteration of the monad list
	 */
	public Nyad pop(int pIndex) {
<span class="fc bfc" id="L1034" title="All 4 branches covered.">		if (validateMIndex(pIndex) &amp; pIndex != 0) 				//Net result: Valid key but not the top of the stack</span>
<span class="fc" id="L1035">			monadList.add(pIndex, monadList.remove(pIndex-1));</span>
<span class="fc" id="L1036">		return this;</span>
	}

	/**
	 * This method takes the offered Monad swaps it for the one before it in the stack. 
	 * &lt;br&gt;
	 * 1. If the monad isn't there, nothing happens.&lt;br&gt;
	 * 2. If the monad is at the top of the list, popping up isn't possible, thus nothing happens.&lt;br&gt; 
	 * &lt;br&gt;
	 * @param pM Monad in the list to be popped if possible
	 * @return Nyad this nyad after alteration of the monad list
	 */
	public Nyad pop(Monad pM) {
<span class="fc bfc" id="L1049" title="All 2 branches covered.">		if(monadList.contains(pM)){</span>
<span class="fc" id="L1050">			int key = monadList.indexOf(pM);</span>
<span class="fc" id="L1051">			pop(key);</span>
		}
<span class="fc" id="L1053">		return this;</span>
	}

	/**
	 * Project the monad onto the algebra offered. The end result is the monad using the offered algebra
	 * &lt;br&gt;&lt;br&gt;
	 * The two algebras must share the same basis. If they do not, this method silently does nothing.
	 * &lt;br&gt;&lt;br&gt;
	 * @param pUse Algebra onto which pKeep is to be projected.
	 * @param pKeep Monad to be projected onto pUse
	 * @return Monad which has been pressed into the other algebra
	 */
	public Monad projectOnto(Monad pKeep, Algebra pUse) {
<span class="nc bnc" id="L1066" title="All 2 branches missed.">		if (pKeep.getAlgebra().getBasis().equals(pUse.getBasis()))</span>
<span class="nc" id="L1067">			return pKeep.setAlgebra(pUse);</span>
<span class="nc" id="L1068">		return pKeep;</span>
	}

	/**
	 * This method takes the Monad at the k'th position in the list and swaps it for
	 * the one in the k+1 position if there is one there. If the index points to the
	 * last Monad, this function silently returns with no push action.
	 * &lt;br&gt;
	 * @param pIndex int at which the push is to occur
	 * @return Nyad this nyad after alteration of the monad list
	 */
	public Nyad push(int pIndex) {
<span class="fc bfc" id="L1080" title="All 4 branches covered.">		if (validateMIndex(pIndex) &amp; pIndex != monadList.size())  //Net result: Valid key but not the bottom of the stack</span>
<span class="fc" id="L1081">			monadList.add(pIndex+1, monadList.remove(pIndex));</span>
<span class="fc" id="L1082">		return this;</span>
	}

	/**
	  * This method takes the offered Monad and swaps it for the next one lower in the stack.
	 * &lt;br&gt;
	 * 1. If the monad isn't there, nothing happens.&lt;br&gt;
	 * 2. If the monad is at the bottom of the list, pushign down isn't possible, thus nothing happens.&lt;br&gt; 
	 * &lt;br&gt;
	 * @param pM Monad in the list to be pushed if possible
	 * @return Nyad this nyad after alteration of the monad list
	 */
	public Nyad push(Monad pM) {
<span class="fc bfc" id="L1095" title="All 2 branches covered.">		if(monadList.contains(pM)){</span>
<span class="fc" id="L1096">			int key = monadList.indexOf(pM);</span>
<span class="fc" id="L1097">			push(key);</span>
		}
<span class="fc" id="L1099">		return this;</span>
	}

	/**
	 * Remove a Monad on the list of monads in this nyad using it's integer index.
	 * If the index is out of range, this method silently returns.
	 * &lt;br&gt;
	 * @param pIndex int index of the monad to be removed.
	 * @return Nyad this nyad after the attempted removal.
	 */
	public Nyad remove(int pIndex) {
<span class="fc bfc" id="L1110" title="All 2 branches covered.">		if (validateMIndex(pIndex))	{</span>
<span class="fc" id="L1111">			monadList.remove(pIndex);</span>
<span class="fc" id="L1112">			monadList.trimToSize();</span>
<span class="fc" id="L1113">			resetFlags();</span>
		}
			
<span class="fc" id="L1116">		return this;</span>
	}

	/**
	 * Remove a monad on the list of monads in this nyad.
	 * If the monad isn't in the nyad, this method silently returns.
	 * &lt;br&gt;
	 * @param pM Monad to be removed
	 * @return Nyad this nyad after the attempted removal.
	 */
	public Nyad remove(Monad pM) {
<span class="fc bfc" id="L1127" title="All 2 branches covered.">		if (monadList.removeAll(Collections.singleton(pM))) {</span>
<span class="fc" id="L1128">			monadList.trimToSize();</span>
<span class="fc" id="L1129">			resetFlags();</span>
		}
<span class="fc" id="L1131">		return this;</span>
	}

	/**
	 * Remove monads in the nyad using the offered algebra.
	 * If the algebra isn't inuse in the nyad, this method silently returns.
	 * &lt;br&gt;
	 * @param pA Algebra to use as a filter to collect monads to be removed
	 * @return Nyad this one after the alteration
	 */
	public Nyad removeAt(Algebra pA) {
<span class="fc" id="L1142">		monadInAlgebraStream(pA).toList().forEach(x -&gt; remove(x));		</span>
<span class="fc" id="L1143">		return this;</span>
	}

	/**
	 * This method takes a pair of monads (keep, use) and multiplies the left one by the right one from the left
	 * and then again with the reversed right one from the right. Symbolically: (Right)(Left)(Right.reservse).
	 * Finding these monads is the task of this method... then it hands off to the similarly named method that 
	 * accepts the monads directly.  When it is done, the left monad is changed and the right monad is removed from the nyad.
	 * &lt;br&gt;&lt;br&gt;
	 * @param pKeep Monad to be altered by multiplication. Operand
	 * @param pUse 	Monad to DO the alteration bymultiplication. Operator
	 * @return Nyad	after the multiplication is complete and the 'use' monad removed
	 * @throws CladosMonadException	This happens if the monad pair fail a reference match test
	 * @throws CladosNyadException	This happens if the monad pair are not in the nyad
	 */
	public Nyad sandwich(int pKeep, int pUse) throws CladosMonadException, CladosNyadException {
<span class="pc bpc" id="L1159" title="1 of 2 branches missed.">		if (validateMIndex(pKeep) &amp; validateMIndex(pUse)) 					// Check for monad list out of bounds errors.</span>
<span class="fc" id="L1160">						sandwich(monadList.get(pKeep), monadList.get(pUse));</span>
<span class="nc" id="L1161">		else 			throw new IndexOutOfBoundsException(&quot;Sandwich conjugation out of range error&quot;);</span>

<span class="fc" id="L1163">		return this;</span>
	}

	/**
	 * This method takes a pair of monads (keep, use) and multiplies the left one by the right one from the left
	 * and then again with the reversed right one from the right. Symbolically: (Right)(Left)(Right.reservse).
	 * When it is done, the left monad is changed and the right monad is removed from the nyad.
	 * &lt;br&gt;&lt;br&gt;
	 * @param pKeep Monad to be altered by sandwich. Operand
	 * @param pUse 	Monad to DO the alteration by sandwich. Operator
	 * @return Nyad	after the multiplication is complete and the 'use' monad removed
	 * @throws CladosMonadException	This happens if the monad pair fail a reference match test
	 * @throws CladosNyadException	This happens if the monad pair are not in the nyad
	 */
	public Nyad sandwich(Monad pKeep, Monad pUse) throws CladosMonadException, CladosNyadException {
<span class="pc bpc" id="L1178" title="1 of 2 branches missed.">		if (!Monad.isReferenceMatch(pKeep, pUse)) 				// Proceed only if they reference match.</span>
<span class="nc" id="L1179">						throw new CladosMonadException(pKeep, &quot;Monad pair fails reference match for sandwich multiplication.&quot;);</span>
		
<span class="pc bpc" id="L1181" title="2 of 4 branches missed.">		if (!this.has(pKeep) || !this.has(pUse))				// Proceed only if both monads in nyad.</span>
<span class="nc" id="L1182">						throw new CladosNyadException(this, &quot;Monad pair must be in nyad for sandwich multiplication.&quot;);</span>
		
<span class="fc" id="L1184">		(pKeep.multiplyLeft(pUse)).multiplyRight(pUse.reverse());	// Only now can we do the deed.</span>
<span class="fc" id="L1185">		monadList.remove(pUse);									// Right Monad is REMOVED HERE!</span>
<span class="fc" id="L1186">		monadList.trimToSize();</span>
<span class="fc" id="L1187">		resetFlags();											// Work out consequences</span>

<span class="fc" id="L1189">		return this;</span>
	}

	/**
	 * This method takes a pair of monads (keep, use) and multiplies the left one by the right one from the left
	 * and then again with the reversed right one from the right. Symbolically: (Right)(Left)(Right.reservse).
	 * Finding these monads is the task of this method... then it hands off to the similarly named method that 
	 * accepts the monads directly.  When it is done, the left monad is changed and the right monad is removed from the nyad.
	 * &lt;br&gt;&lt;br&gt;
	 * @param pKeep 	Monad to be altered by multiplication. Operand
	 * @param pUse 		Monad to DO the alteration bymultiplication. Operator
	 * @param pSource	Nyad that is the source of the pUse Monad. 
	 * @return Nyad		after the multiplication is complete and the 'use' monad removed
	 * @throws CladosMonadException	This happens if the monad pair fail a reference match test
	 * @throws CladosNyadException	This happens if the monad pair are not in the nyad
	 */
	public Nyad sandwich(int pKeep, int pUse, Nyad pSource) throws CladosMonadException, CladosNyadException {
<span class="pc bpc" id="L1206" title="1 of 2 branches missed.">		if (pSource == null)															// Check 'use' monad is in source nyad.</span>
<span class="nc" id="L1207">						throw new CladosNyadException(this, &quot;Source nyad needed for this sandwich multiplication.&quot;); </span>
<span class="pc bpc" id="L1208" title="1 of 2 branches missed.">		else if (this.validateMIndex(pKeep) &amp; pSource.validateMIndex(pUse)) 			// Check for monad list out of bounds errors.</span>
<span class="fc" id="L1209">						sandwich(monadList.get(pKeep), pSource.getMonadAt(pUse), pSource);</span>
<span class="nc" id="L1210">		else 			throw new IndexOutOfBoundsException(&quot;Sandwich conjugation out of range error&quot;);</span>

<span class="fc" id="L1212">		return this;</span>
	}

	/**
	 * This method takes a pair of monads (keep, use) and multiplies the left one by the right one from the left
	 * and then again with the reversed right one from the right. Symbolically: (Right)(Left)(Right.reservse).
	 * When it is done, the left monad is changed and the right monad is removed from its nyad source.
	 * &lt;br&gt;&lt;br&gt;
	 * At present, this method treats reverse() as a cheap inverse(). What we really want is the GP reciprocal.
	 * &lt;br&gt;&lt;br&gt;
	 * @param pKeep 	Monad to be altered by sandwich. Operand
	 * @param pUse 		Monad to DO the alteration by sandwich. Operator
	 * @param pSource	Nyad that is the source of the pUse Monad. 
	 * @return Nyad		this nyad after the multiplication is complete and the 'use' monad removed from the source
	 * @throws CladosMonadException	This happens if the monad pair fail a reference match test
	 * @throws CladosNyadException	This happens if the monad pair are not in the nyad
	 */
	public Nyad sandwich(Monad pKeep, Monad pUse, Nyad pSource) throws CladosMonadException, CladosNyadException {
<span class="pc bpc" id="L1230" title="1 of 2 branches missed.">		if (pSource == null)									// Check 'use' monad is in source nyad.</span>
<span class="nc" id="L1231">						throw new CladosNyadException(this, &quot;Source nyad needed for this sandwich multiplication.&quot;); </span>

<span class="pc bpc" id="L1233" title="1 of 2 branches missed.">		if (!Monad.isReferenceMatch(pKeep, pUse)) 				// Proceed only if they reference match.</span>
<span class="nc" id="L1234">						throw new CladosMonadException(pKeep, &quot;Monad pair fails reference match for sandwich multiplication.&quot;);</span>
		
<span class="pc bpc" id="L1236" title="2 of 4 branches missed.">		if (!this.has(pKeep) || !pSource.has(pUse))				// Proceed only if both monads in nyad.</span>
<span class="nc" id="L1237">						throw new CladosNyadException(this, &quot;Monad pair must be in nyad for sandwich multiplication.&quot;);</span>
		
<span class="fc" id="L1239">		(pKeep.multiplyLeft(pUse)).multiplyRight(pUse.reverse());	// Only now can we do the deed.</span>
<span class="fc" id="L1240">		pSource.remove(pUse);									// Right Monad is REMOVED AT SOURCE HERE!</span>
<span class="fc" id="L1241">		monadList.trimToSize();</span>
<span class="fc" id="L1242">		resetFlags();											// Work out consequences</span>

<span class="fc" id="L1244">		return this;</span>
	}

	/**
	 * Nyad Scaling: Pick a monad and scale it by the magnitude provided. Only one monad can 
	 * be scaled within a nyad at a time. Note that a request to scale a monad that cannot be 
	 * found in the list results in no action and no exception.
	 * &lt;br&gt;&lt;br&gt;
	 * @param pIndex   int index at which to find the monad
	 * @param pMag ProtoN child object used to scale the monad. Can't be an actual ProtoN.
	 * @param &lt;T&gt; ProtoN child object generic type support
	 * @return Nyad after the monads at the offered index has been scaled
	 */
	public &lt;T extends ProtoN &amp; Field &amp; Normalizable&gt; Nyad scale(int pIndex, T pMag) {
<span class="fc bfc" id="L1258" title="All 2 branches covered.">		if (validateMIndex(pIndex))			monadList.get(pIndex).scale(pMag);</span>
<span class="fc" id="L1259">		return this;</span>
	}

	/**
	 * Nyad Scaling: Pick an algebra and scale all monads using it. Many monads can be scaled
	 * at a time. Note that a request to scale monads at an algebra that cannot be found 
	 * in the list results in no action and no exception.
	 * &lt;br&gt;&lt;br&gt;
	 * @param pAlg Algebra to use as monad stream filter for scaling action.
	 * @param pMag ProtoN child object
	 * @param &lt;T&gt; ProtoN child object generic type support
	 * @return Nyad after the monads at the offered algebra have been scaled
	 */
	public &lt;T extends ProtoN &amp; Field &amp; Normalizable&gt; Nyad scaleUsing(Algebra pAlg, T pMag) {
<span class="fc bfc" id="L1273" title="All 2 branches covered.">		monadStream().filter(pM -&gt; pM.getAlgebra() == pAlg).forEach(x -&gt; x.scale(pMag));</span>
<span class="fc" id="L1274">		return this;</span>
	}

	/**
	 * Set the name of this Nyad
	 * &lt;br&gt;
	 * @param name String
	 * @return Nyad this nyad after the alteration.
	 */
	public Nyad setName(String name) {
<span class="fc" id="L1284">		Name = name;</span>
<span class="fc" id="L1285">		return this;</span>
	}

	/**
	 * This method resets the internal list of algebras associated with the nyad. It streams the monads 
	 * and copies references to unique algebras found along the way. The juxtapositon and composition 
	 * flags are reset based on what conditions are found in the monad and algebra lists.
	 * &lt;br&gt;&lt;br&gt;
	 * |-------Flags-------|---compositionFlag = True---|---compositionFlag = False---|&lt;br&gt;
	 * |-------------------|-------algebra # = 0 or 1---|-------------algebra # &gt; 1---|&lt;br&gt;
	 * |---jFlag = True----|----[Zero or One Monad]-----|----[monad # = algebra #]----|&lt;br&gt;
	 * |-------------------|----------------------------|-----------------------------|&lt;br&gt;
	 * |---jFlag = False---|--------[One Algebra]-------|----[monad # &gt; algebra #]----|&lt;br&gt;
	 * |-------------------|----------------------------|-----------------------------|&lt;br&gt;
	 * &lt;br&gt;
	 * @return Nyad this nyad after the alteration.
	 */
	public Nyad resetFlags() {
<span class="fc" id="L1303">		algebraList.clear();</span>
<span class="fc" id="L1304">		algebraList.ensureCapacity(monadList.size());</span>

<span class="fc bfc" id="L1306" title="All 2 branches covered.">		if (monadList.size() == 0) {							//Empty set edge case</span>
<span class="fc" id="L1307">			jFlag = true;</span>
<span class="fc" id="L1308">			compositionFlag = true;</span>
<span class="fc" id="L1309">			return this;										//and we're done.</span>
		}
<span class="fc" id="L1311">		monadStream().forEach(m -&gt; {							//At least one monad to process</span>
<span class="fc bfc" id="L1312" title="All 2 branches covered.">			if (!algebraList.contains(m.getAlgebra()))			//Stash a reference to the algebra if </span>
<span class="fc" id="L1313">				algebraList.add(m.getAlgebra());				//it isn't already stashed.</span>
<span class="fc" id="L1314">		});</span>
																//Now we set/reset the state flags.
<span class="fc bfc" id="L1316" title="All 2 branches covered.">		if (monadList.size() == 1) {							//Singlton nyad edge case is similar to empty set, so...</span>
<span class="fc" id="L1317">			jFlag = true;										//is a juxtaposition by default</span>
<span class="fc" id="L1318">			compositionFlag = true;								//and a composition by default.</span>
<span class="fc bfc" id="L1319" title="All 2 branches covered.">		} else if (algebraList.size() == 1) {					//Multiple monads all sharing an algebra</span>
<span class="fc" id="L1320">			jFlag = false;										//are not juxtapositions</span>
<span class="fc" id="L1321">			compositionFlag = true;								//but ARE compositions.</span>
<span class="fc bfc" id="L1322" title="All 2 branches covered.">		} else if (monadList.size() == algebraList.size()) {	//Multiple monads and just as many algebras</span>
<span class="fc" id="L1323">			jFlag = true;										//ARE juxtapositions</span>
<span class="fc" id="L1324">			compositionFlag = false;							//and never compositions.</span>
		} else {												//Monads outnumber Algebras and more than one of each, so...
<span class="fc" id="L1326">			jFlag = false;										//it is NOT a juxtaposition</span>
<span class="fc" id="L1327">			compositionFlag = false;							//and NOT a composition. (Mixed Case)</span>
		}
<span class="fc" id="L1329">		return this;</span>
	}

	/**
	 * Monads that share an algebra are 'added'. Only one monad per algebra is kept after all is said and done. The algebra list 
	 * is used to search for monads in the list. When two are more are found, a new monad is created that is a sum of all the others. 
	 * When only one is found, it is simply copied. As a result of this, an entirely new list is created and the old one replaced.
	 * &lt;br&gt;&lt;br&gt;
	 * @return Nyad after the algebra sharing modes are added as weights.
	 */
	public Nyad weight() {
<span class="nc bnc" id="L1340" title="All 2 branches missed.">		if (monadList.size() == 0)	return this;</span>
<span class="nc" id="L1341">		ArrayList&lt;Monad&gt; newMonads = new ArrayList&lt;&gt;(monadList.size());</span>
<span class="nc" id="L1342">		algebraStream().forEach(alg -&gt; {								//Stream through algebras in the algebra list</span>
<span class="nc" id="L1343">			int tHop = find(alg);										//index of first monad at the algebra</span>
<span class="nc" id="L1344">			Monad tCopy = GBuilder.copyOfMonad(getMonadAt(tHop));		//Yep. Copy of the first monad at the algebra</span>
<span class="nc bnc" id="L1345" title="All 2 branches missed.">			while (findNext(alg, tHop) &gt;= 0){							//There exists a next monad at the algebra</span>
<span class="nc" id="L1346">				tCopy.add(getMonadAt(findNext(alg, tHop)));				//add it to the working copy</span>
<span class="nc" id="L1347">				tHop = findNext(alg, tHop);								//and hop along the list to the next monad at the algebra</span>
			}
<span class="nc" id="L1349">			newMonads.add(tCopy);										//Append the sum at the algebra to newMonads list</span>
<span class="nc" id="L1350">		});</span>
<span class="nc" id="L1351">		newMonads.trimToSize();</span>
<span class="nc" id="L1352">		monadList = newMonads;											//Summation operation complete, so replace the monad list</span>
<span class="nc" id="L1353">		resetFlags();													//and reset flags and algebra list.		</span>
<span class="nc" id="L1354">		return this;</span>
	}

	/**
	 * Set the Foot for the nyad using this method. A Foot merely labels where an
	 * algebra is expected to be tangent to an underlying manifold.
	 * &lt;br&gt;
	 * @param pF Foot to set for the nyad.
	 * @return Nyad this nyad after the alteration.
	 */
	protected Nyad setFoot(Foot pF) {
<span class="fc" id="L1365">		sharedFoot = pF;</span>
<span class="fc" id="L1366">		return this;</span>
	}

	/**
	 * Set the Monad List for this Nyad. A new ArrayList is constructed, but the monads 
	 * in the offered list are NOT copied.
	 * &lt;br&gt;
	 * @param pML ArrayList Contains the list of monads for the nyad
	 * @return Nyad this nyad after the alteration.
	 */
	protected Nyad setMonadList(ArrayList&lt;Monad&gt; pML) {
<span class="fc bfc" id="L1377" title="All 2 branches covered.">		monadList = (pML == null) ? new ArrayList&lt;Monad&gt;() : new ArrayList&lt;Monad&gt;(pML);</span>
<span class="fc" id="L1378">		resetFlags();</span>
<span class="fc" id="L1379">		return this;</span>
	}

	/*
	 * This method checks the offered integer to determine if it is out of bounds with respect to the monad list.
	 */
	private boolean validateAIndex(int pHere) {
<span class="fc bfc" id="L1386" title="All 6 branches covered.">		if (pHere &gt;= 0 &amp; pHere &lt; algebraList.size())	return true;</span>
<span class="fc" id="L1387">		return false;</span>
	}

	/*
	 * This method checks the offered integer to determine if it is out of bounds with respect to the monad list.
	 */
	private boolean validateMIndex(int pHere) {
<span class="fc bfc" id="L1394" title="All 6 branches covered.">		if (pHere &gt;= 0 &amp; pHere &lt; monadList.size())		return true;</span>
<span class="fc" id="L1395">		return false;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>