<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CanonicalBasis.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Clados</a> &gt; <a href="index.source.html" class="el_package">org.interworldtransport.cladosG</a> &gt; <span class="el_source">CanonicalBasis.java</span></div><h1>CanonicalBasis.java</h1><pre class="source lang-java linenums">/*
 * &lt;h2&gt;Copyright&lt;/h2&gt; Â© 2025 Alfred Differ&lt;br&gt;
 * ------------------------------------------------------------------------ &lt;br&gt;
 * ---org.interworldtransport.cladosG.CanonicalBasis&lt;br&gt;
 * -------------------------------------------------------------------- &lt;br&gt;
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version. 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.&lt;br&gt;&lt;br&gt;
 * 
 * Use of this code or executable objects derived from it by the Licensee 
 * states their willingness to accept the terms of the license. &lt;br&gt; &lt;br&gt;
 * 
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.&lt;br&gt; &lt;br&gt;
 * 
 * ------------------------------------------------------------------------ &lt;br&gt;
 * ---org.interworldtransport.cladosG.CanonicalBasis&lt;br&gt;
 * ------------------------------------------------------------------------ &lt;br&gt;
 */
package org.interworldtransport.cladosG;

import java.util.ArrayList;
import java.util.stream.IntStream;
import java.util.stream.LongStream;
import java.util.stream.Stream;

/**
 * This interface represents the 'contract' obeyed by a canonical basis in cladosG. 
 * Most of the interface focuses upon gettor methods that return blade information, 
 * but there are a few convenience methods too that support grade information and 
 * ranges as detected by the number of generators found in a blade. Finally there 
 * are also a few methods for dealing with keys and basis size validation.
 * &lt;br&gt;&lt;br&gt;
 * The farther one gets from basic methods dealing with blades and span, the more 
 * one is wandering off into conveniences. The various keys matter, but as computational 
 * short-cuts for product tables having to deal with very large vector spaces.
 * &lt;br&gt;&lt;br&gt;
 * @version 2.0
 * @author Dr Alfred W Differ
 */
public interface CanonicalBasis {

	/**
	 * This method detects whether or not the number of generators being used is
	 * currently supported by Clados. The point for it is to prevent internal errors
	 * in other classes.
	 * &lt;br&gt;
	 * For example, someone attempting to create a basis with a negative number of
	 * generators should be stopped up front without having to check for that
	 * situation themselves.
	 * &lt;br&gt;
	 * The trickier one, though, involves a number of generators that will blow up
	 * an internal representation in a basis or CliffordProduct class. For example,
	 * trying to build a basis with 64 generators will create a list of 2E64
	 * blades... or at least the library will try if the size isn't validated first.
	 * Perhaps the list representation of a Basis can hold that many Blades, but the
	 * keys identifying them might not if they rely on java primitives. Also, the
	 * related CliffordProduct holds a product table of all blades. Its internal
	 * representation might break too.
	 * &lt;br&gt;
	 * This method provides a single place to validate the largest possible grade of 
	 * a basis. Having it be static avoids having this test be specialized for each 
	 * Basis object. This version AVOIDS placing magic numbers in the interface or 
	 * objects. Actual limits are in the CladosConstant class as static elements.
	 * &lt;br&gt;
	 * @param pGens int This is the number of generators of the basis.
	 * @return TRUE returned if the number of generators is in the supported range.
	 *         FALSE otherwise.
	 */
	public static boolean validateSize(int pGens) {
<span class="fc bfc" id="L76" title="All 4 branches covered.">		return (pGens &gt;= CladosConstant.SCALARGRADE &amp; pGens &lt;= CladosConstant.MAXGRADE);</span>
	}

	/**
	 * In support of streams, a basis should offer a stream of its blades of a
	 * particular grade.
	 * &lt;br&gt;
	 * @param pIn byte integer for magnitude of grade of blades in stream.
	 * @return Stream of Blades in the basis of a particular grade.
	 */
	public abstract Stream&lt;Blade&gt; bladeOfGradeStream(byte pIn);

	/**
	 * In support of streams, a basis should offer a stream of its blades.
	 * &lt;br&gt;
	 * @return Stream of Blades in the basis
	 */
	public abstract Stream&lt;Blade&gt; bladeStream();

	/**
	 * Old-fashioned 'find' method that reports index location in the basis where a
	 * Blade is found OR -1 if it wasn't found.
	 * &lt;br&gt;
	 * @param pIn Blade to be found
	 * @return integer index pointing to element of a list containing the Blade OR
	 *         -1 if the blade wasn't found.
	 */
	public abstract int find(Blade pIn);

	/**
	 * Return the number of independent blades in the basis. This is the same as the
	 * linear dimension of an algebra that uses this basis.
	 * &lt;br&gt;
	 * @return int
	 */
	public abstract int getBladeCount();

	/**
	 * Return the number of grades in the basis. Since there is no geometry in the
	 * basis this is a measure of the number of distinct generator subset types that
	 * can be formed where the element count determines the type. Because the empty
	 * set includes no generators, GradeCount will always be one more than the
	 * number of generators.
	 * &lt;br&gt;
	 * @return byte
	 */
	public abstract byte getGradeCount();

	/**
	 * This method simply delivers the otherwise private grade range list. Useful
	 * for testing purposes, but should be avoided as much as possible.
	 * &lt;br&gt;
	 * @return ArrayList of Integers A list of grades boxed as Integers.
	 */
	public abstract ArrayList&lt;Integer&gt; getGrades();

	/**
	 * Get an index to the first blade of grade specified by the parameter.
	 * &lt;br&gt;
	 * @param p1 byte This is for choosing which grade index range to return.
	 * @return int Index within the basis where requested grade starts.
	 */
	public abstract int getGradeStart(byte p1);

	/**
	 * Return the long at p1 in the EddingtonKey array.
	 * &lt;br&gt;
	 * @param p1 short This is the desired key at p1 .
	 * @return long
	 */
	public abstract long getKey(int p1);

	/**
	 * This is a short-hand method for getSingleBlade('last'). It just returns the
	 * last blade in the basis.
	 * &lt;br&gt;
	 * @return Blade that is the last in the basis
	 */
	public abstract Blade getPScalarBlade();
	
	/**
	 * This is a special version of getGradeStart() that finds the highest grade.
	 * &lt;br&gt;
	 * @return int Index within the basis where pscalar grade starts.
	 */
	public abstract int getPScalarStart();
	
	/**
	 * This is a short-hand method for getSingleBlade(0). It just returns the first
	 * blade in the basis.
	 * &lt;br&gt;
	 * @return Blade that is the first in the basis
	 */
	public abstract Blade getScalarBlade();

	/**
	 * Simple gettor method retrieves the Blade at the indexed position in the
	 * Basis.
	 * &lt;br&gt;
	 * @param p1 integer index
	 * @return Blade at the indexed position.
	 */
	public abstract CanonicalBlade getSingleBlade(int p1);

	/**
	 * This should essentially be an integer stream, but grades are very small. The
	 * maximum grade in a basis is equal to the number of generators used to create
	 * it. For now, a single byte integer suffices, but IntStream is better
	 * supported by Java.
	 * &lt;br&gt;
	 * @return Stream of Grades in the basis
	 */
	public abstract IntStream gradeStream();

	/**
	 * This method should answer the question whether the offered blade is in the basis.
	 * How it does so is up to the concrete class to decide, but the usual way involves
	 * testing for keys in a list or map containing the blades of the basis.
	 * &lt;br&gt;
	 * @param pB	Blade to be checked if it is in the basis.
	 * @return boolean answering true of false about whether the blade is in the basis
	 */
	public abstract boolean hasBlade(Blade pB);

	/**
	 * Similar to bladestream(), this method returns a stream of boxed long integers
	 * that represents blade keys.
	 * &lt;br&gt;
	 * @return LongStream of blade keys.
	 */
	public abstract LongStream keyStream();

	/**
	 * This is a validator detects blade out of range issues. If one tries to name a
	 * blade by its index, it is always possible for the offered integer to be out
	 * of range.
	 * &lt;br&gt;
	 * This method demands a contract term for validating the blade index to be referenced.
	 * It is NOT static because the maximum grade of a basis is object dependent.
	 * Implementations of this method should AVOID placing magic numbers in the method 
	 * body by using CladosConstant static elements like validateSize(int) does.
	 * &lt;br&gt;
	 * @param pIn Integer representing the integer index of the blade
	 * @return boolean True if parameter in the supported range [0, bladeCount]
	 */
	public abstract boolean validateBladeIndex(int pIn);

	/**
	 * This validator detects grade out of range issues. If one tries to name a
	 * grade by its index, it is always possible for the offered integer to be out
	 * of range.
	 * &lt;br&gt;
	 * This method demands a contract term for validating the grade index to be referenced.
	 * It is NOT static because the maximum blade of a basis is object dependent.
	 * Implementations of this method should AVOID placing magic numbers in the method 
	 * body by using CladosConstant static elements like validateSize(int) does.
	 * &lt;br&gt;
	 * @param pIn Integer representing the integer index of the grade
	 * @return boolean True if parameter in the supported range [0, gradeCount]
	 */
	public abstract boolean validateGradeIndex(int pIn);

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>