<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Scale.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Clados</a> &gt; <a href="index.source.html" class="el_package">org.interworldtransport.cladosG</a> &gt; <span class="el_source">Scale.java</span></div><h1>Scale.java</h1><pre class="source lang-java linenums">/*
 * &lt;h2&gt;Copyright&lt;/h2&gt; Â© 2025 Alfred Differ&lt;br&gt;
 * ------------------------------------------------------------------------ &lt;br&gt;
 * ---org.interworldtransport.cladosF.Scale&lt;br&gt;
 * -------------------------------------------------------------------- &lt;br&gt;
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version. 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.&lt;br&gt;&lt;br&gt;
 * 
 * Use of this code or executable objects derived from it by the Licensee 
 * states their willingness to accept the terms of the license. &lt;br&gt; &lt;br&gt;
 * 
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.&lt;br&gt; &lt;br&gt;
 * 
 * ------------------------------------------------------------------------ &lt;br&gt;
 * ---org.interworldtransport.cladosF.Scale&lt;br&gt;
 * ------------------------------------------------------------------------ &lt;br&gt;
 */
package org.interworldtransport.cladosG;

import java.util.Map;
import java.util.TreeMap;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;

import static org.interworldtransport.cladosF.CladosField.*;
import org.interworldtransport.cladosF.*;
import org.interworldtransport.cladosFExceptions.*;

/**
 * This class contains cladosF numbers that act together as the coefficients of
 * a monad. They are all children of ProtoN and implement Field, so they
 * have both a sense of 'units' and support basic arithmetic operations. Which
 * numbers are contained internally, therefore, is tracked by two private
 * elements. One contains a reference to a Cardinal that all the numbers should
 * share. The other is a reference two one of the CladosField elements so we
 * know whether this Scale is expected to contain real or complex numbers and at
 * what level of floating point precision. Access to the two private elements is
 * managed by their 'get' methods. getCardinal() and getMode(). There are set
 * methods for them too, but they are package protected methods that should not
 * be handled much by developers of physical models.
 * &lt;br&gt;&lt;br&gt;
 * The data structure used to represent 'coefficients' used to be a fixed array
 * that had the same length as the number of blades in a monad's basis. That has
 * been modernized to an IdentityHashMap contained within this class. The basis
 * against which the map is applicable can be referenced by another private
 * element, but shouldn't be manipulated once set. The private element is
 * finalized.
 * &lt;br&gt;&lt;br&gt;
 * An IdentityHashMap was used instead of a simpler HashMap in order to get
 * reference equality between map keys instead of object equality. Map Keys are
 * Blades from the basis, so reference equality is the correct expectation when
 * comparing keys. Typical use of keys from the map occurs with streams that
 * effectively iterate through the blades for access to coefficients in the
 * encompassing vector space. The information within a blade is far less
 * important than which blade it is, thus reference equality is what is needed.
 * &lt;br&gt;&lt;br&gt;
 * Map Values are CladosF numbers like RealF or ComplexD. Because they are
 * objects instead of primitives, they behave much like Java's boxed primitives.
 * In fact, they would BE those boxed primitives if not for the need to track
 * units in physical models. For example, one meter is not one second. No
 * equality test should pass.
 * &lt;br&gt;&lt;br&gt;
 * Because values are objects, care must be taken once one has a reference to
 * them. Any reference to one enables a developer to change it without the Scale
 * or Monad knowing. This is the hydra monster named Mutability. It IS a danger
 * here. Many of Scale's methods copy inbound numbers to avoid altering them,
 * but some do not INTENTIONALLY.
 * &lt;br&gt;&lt;br&gt;
 * 1. Coefficient settors that accept arrays do NOT copy values before placing
 * them in the internal map. BEWARE BEWARE BEWARE
 * &lt;br&gt;&lt;br&gt;
 * 2. Put() does not copy the incoming value before placing it in the internal
 * map. Again... BEWARE.
 * &lt;br&gt;&lt;br&gt;
 * 3. Coefficient settors that accept maps DO COPY values before placing them in
 * the internal map. Any object from which values are taken to be used here are
 * safe from the hydra.
 * &lt;br&gt;&lt;br&gt;
 * 4. All gettors for coefficients provide direct references to values in the
 * map. The most common use is INTENTIONAL MUTABILITY, so... BEWARE THE HYDRA.
 * The safest way to use them is within streams / lambdas.
 * &lt;br&gt;&lt;br&gt;
 * GENERAL NOTE | Many of the methods for Scale look a lot like Monad, so one can
 * reasonably wonder why all the extra stuff in Monad when Scale looks enough like 
 * a tuple to represent things. The primary difference is that Scale contains only 
 * the coefficients and references a basis like what we got used to as students. 
 * That's not enough because a basis is only enough to represent linear combinations
 * for a vector space. Other geometric meanings aren't in the basis. They are in the
 * product table. Combining product table and basis into an 'algebra' gives a MUCH 
 * better description of a 'tuple's' reference frame than a vector space.
 * &lt;br&gt;&lt;br&gt;
 * 
 * @version 2.0
 * @author Dr Alfred W Differ
 * @param &lt;D&gt; CladosF number like RealF, RealD, ComplexF, ComplexD. They must be
 *            children of ProtoN AND implement Field.
 */
<span class="fc" id="L106">public final class Scale&lt;D extends ProtoN &amp; Field &amp; Normalizable&gt; implements Unitized, Modal {</span>
	/**
	 * When entries appear in the internal map, they should all share the same
	 * cardinal. That cardinal is referenced here where it gives meaning to the weights
	 * in this scale. This is WHY Scale implments Unitized.
	 */
	private Cardinal card;

	/**
	 * This basis is the reference against which these scaling weights make sense. 
	 * For example, a list of 16 real floats is just a tuple. When coupled to a basis, 
	 * they become weights for a sum of geometry composing a multivector.
	 * &lt;br&gt;
	 * Once set, the applicable basis should not change. Scales make sense
	 * RELATIVE to a basis. Never on their own.
	 */
	private final Basis gBasis;

	/**
	 * This tree map is that actual list of weights mapped by their applicable blade.
	 * In use, one calls the Scale's get(Blade) to get a generic that happens to be 
	 * a CladosF.ProtoN child. One can also call a number of specialized 
	 * gettors to get weights for well named blades.
	 * &lt;br&gt;
	 * This feature used to be a simple array of particular children of ProtoN,
	 * but that made for several different... and mostly related implementations of Scale
	 * or of burying Scale in Monad and maintaining several mostly related versions 
	 * of those. Using a map like this reduces the family of objects in CladosG at
	 * the cost of swapping data structures from an array to a map.
	 * &lt;br&gt;
	 * This feature ALSO used to be a hash map (java's IdentityHashMap), but hash maps
	 * don't ensure the extraction of values arrive in any particular order. That makes
	 * a mess of the design where streams are used to deliver pieces of geometry or 
	 * numbers to lambda functions. If the weights storied in this map emerge in 
	 * unpredictable ways, then all operations must act on blades AND numbers which 
	 * we are trying to avoid. Getting a predictable order (from a TreeMap) comes 
	 * at a small performance cost that simply must be paid.
	 */
	private TreeMap&lt;Blade, D&gt; map;

	/**
	 * This is the type of ProtoN that should be present in the list held by
	 * this class. For example, if mode = CladosField.REALF, then all elements in
	 * the list will be the RealF child of ProtoN. 
	 * &lt;br&gt;
	 * Mode ensures the scale elements all have the same precision and come from the same 
	 * numeric field. It is also WHY Scale implements Modal.
	 */
	private final CladosField mode;

	/**
	 * This method is for detecting cardinal differences in an array of numbers to be used as weights for a monad.
	 * The Scale might be able to tolerate them, but the monad won't when it is put to use. TypeMatching will fail.
	 * &lt;br&gt;&lt;br&gt;
	 * return value +1: Incoming numbers perfectly match the standard cardinal.			Suggest using them.
	 * return value  0: Incoming numbers are a jumbled mess wrt the standard cardinal. 	Suggest tossing them.
	 * return value -1: Incoming numbers perfectly MISmatch the standard cardinal.		Suggest changing standard.
	 * &lt;br&gt;&lt;br&gt;
	 * @param &lt;D&gt; 	stands in for a ProtoN child class
	 * @param pCard Cardinal to be used as the measure for deviations in the offered number array.
	 * @param pIn 	array of ProtoN children to be tested for nulls
	 * @return integer offered for decisions about keeping the numbers or the standard cardinal.
	 */
	public final static &lt;D extends ProtoN &amp; Field &amp; Normalizable&gt; int testCardinalMatchesIncoming(Cardinal pCard, D[] pIn) {
<span class="fc" id="L170">		long standardMatch = IntStream	.range(0, pIn.length)								</span>
<span class="pc bpc" id="L171" title="1 of 2 branches missed.">										.filter(i -&gt; pIn[i].getCardinal() == pCard )</span>
<span class="fc" id="L172">										.count();</span>
<span class="fc" id="L173">		long internalMatch = IntStream	.range(1, pIn.length)								</span>
<span class="pc bpc" id="L174" title="1 of 2 branches missed.">										.filter(i -&gt; pIn[i].getCardinal() == pIn[0].getCardinal())</span>
<span class="fc" id="L175">										.count();				</span>

		//If standardMatch = pIn.length						: Cardinal match is perfect and the incoming numbers can be re-used with no cardinal resets.
		//If standardMatch is between {0, pIn.length}		: Cardinal match is a mess and the incoming numbers are not typeMatches for each other.
		//If standardMatch = 0								: Nothing matches and we might need to swap the standard cardinal
		//	If internalMatch = pIn.length -1				: Cardinals match perfectly within the incoming numbers and we should swap the standard.
		//	If internalMatch is between {0, pIn.length -1}	: Cardinal match is a mess

<span class="pc bpc" id="L183" title="1 of 2 branches missed.">		return 	(standardMatch == pIn.length) ? 1								//Standard Match is perfect</span>
<span class="nc bnc" id="L184" title="All 6 branches missed.">				: (standardMatch == 0 &amp; internalMatch == pIn.length -1) ? -1 	//Standard Match is perfectly wrong... change the standard.</span>
<span class="nc" id="L185">				: 0;															//Garbage offered. Toss it!</span>
	}

	/**
	 * This method is for detecting mode difference in an array of numbers to be used as weights for a monad.
	 * The Scale might be able to tolerate them, but the monad won't... so they are rejected at Scale.
	 * &lt;br&gt;&lt;br&gt;
	 * @param &lt;D&gt; 	stands in for a ProtoN child class
	 * @param pMode CladosField to be used as the measure for deviations in the offered number array.
	 * @param pIn 	array of ProtoN children to be tested for nulls
	 * @return boolean True if no mode mismatches are present in the array. False if any are.
	 */
	public final static &lt;D extends ProtoN &amp; Field &amp; Normalizable&gt; boolean validateModeIncoming(CladosField pMode, D[] pIn) {

<span class="fc" id="L199">		return IntStream	.range(0, pIn.length)								</span>
<span class="fc bfc" id="L200" title="All 16 branches covered.">							.filter(i -&gt;	!(pIn[i] instanceof RealF &amp; pMode == REALF)</span>
										&amp; 	!(pIn[i] instanceof RealD &amp; pMode == REALD)
										&amp; 	!(pIn[i] instanceof ComplexF &amp; pMode == COMPLEXF)
										&amp; 	!(pIn[i] instanceof ComplexD &amp; pMode == COMPLEXD) )
<span class="fc bfc" id="L204" title="All 2 branches covered.">							.count() == 0;</span>
	}

	/**
	 * This method is for detecting nulls in an array of numbers to be used as weights for a monad.
	 * The Scale might be able to tolerate them, but the monad won't... so they are rejected at Scale.
	 * &lt;br&gt;&lt;br&gt;
	 * @param &lt;D&gt; stands in for a ProtoN child class
	 * @param pIn array of ProtoN children to be tested for nulls
	 * @return boolean True if no nulls are present in the array. False if any are.
	 */
	public final static &lt;D extends ProtoN &amp; Field &amp; Normalizable&gt; boolean validateNoNullsIncoming(D[] pIn) {
<span class="fc" id="L216">		 return IntStream	.range(0, pIn.length)</span>
<span class="fc bfc" id="L217" title="All 2 branches covered.">							.filter(i -&gt; pIn[i]==null)</span>
<span class="fc bfc" id="L218" title="All 2 branches covered.">							.count() == 0;</span>
	}

	/**
	 * This is the constructor to use when one does not have the actual map ready,
	 * but will provide it later.
	 * &lt;br&gt;
	 * @param pMode CladosField enumeration so we know what kind of ProtoN to
	 *              expect from get()
	 * @param pB    Basis to which the blades used in the internal map belong.
	 * @param pCard Incoming Cardinal to reference here.
	 */
<span class="fc" id="L230">	public Scale(CladosField pMode, Basis pB, Cardinal pCard) {</span>
<span class="fc" id="L231">		map = new TreeMap&lt;&gt;();</span>
<span class="fc" id="L232">		mode = pMode;</span>
<span class="fc" id="L233">		gBasis = pB;</span>
<span class="fc" id="L234">		card = pCard;</span>
<span class="fc" id="L235">		zeroAll();</span>
<span class="fc" id="L236">	}</span>

	/**
	 * This is the constructor to use when one already has a map built and a
	 * reference to the basis on which the map relies for keys.
	 * &lt;br&gt;
	 * This is NOT a copy constructor. Use it when you fully intend for the offered map
	 * to directly provide the weights in this Scale.
	 * &lt;br&gt;
	 * @param pMode  CladosField enumeration so we know what kind of ProtoN to
	 *               expect from get()
	 * @param pB     Basis to which the blades offered in the map belong.
	 * @param pInMap This is a Map to copy. Probably a view of another Scale object.
	 */
<span class="fc" id="L250">	public Scale(CladosField pMode, Basis pB, Map&lt;Blade, D&gt; pInMap) {</span>
<span class="fc" id="L251">		mode = pMode;</span>
<span class="fc" id="L252">		gBasis = pB;</span>
<span class="fc" id="L253">		card = pInMap.get(pB.getScalarBlade()).getCardinal();</span>
<span class="fc" id="L254">		map = new TreeMap&lt;&gt;();</span>
<span class="fc" id="L255">		map.putAll(pInMap);</span>
		
<span class="pc bpc" id="L257" title="1 of 2 branches missed.">		assert (pInMap.keySet().size() == pB.getBladeCount());</span>
<span class="fc" id="L258">	}</span>

	/**
	 * Straight forward copy constructor. Copies values ONLY. Re-uses keys.
	 * &lt;br&gt;
	 * @param pIn Scale to be imitated.
	 */
	public Scale(Scale&lt;D&gt; pIn) {
<span class="fc" id="L266">		this(pIn.getMode(), pIn.gBasis, pIn.getCardinal());</span>
<span class="fc" id="L267">		gBasis.bladeStream().forEach(blade -&gt; {</span>
<span class="fc" id="L268">			map.put(blade, FBuilder.copyOf(pIn.get(blade)));</span>
<span class="fc" id="L269">		});</span>
<span class="fc" id="L270">	}</span>

	/**
	 * This method conjugates all the values in the internal map, but leaves the
	 * blades of the algebra untouched.
	 * &lt;br&gt;
	 * @return Scale object. Just this object after modification.
	 */
	public Scale&lt;D&gt; conjugateNumbers() {
<span class="fc" id="L279">		this.weightsParallelStream().forEach(w -&gt; w.conjugate());</span>
<span class="fc" id="L280">		return this;</span>
	}

	/**
	 * This method 'conjugates' blades of the algebra, but leaves the numbers untouched.
	 * blades of the algebra untouched. 
	 * &lt;br&gt;&lt;br&gt;
	 * These are Shrirokov's 'standard conjugates' that flip signs on blocks of weights
	 * in powers of two. For example...&lt;br&gt;
	 * invoke with (0) is the identity. It flips nothing.&lt;br&gt;
	 * invoke with (1) is the main involution. It flips every odd grade... so Integer.lowestOneBit(j)) == 1 &lt;br&gt;
	 * invoke with (2) is the reverse involution. It flips every other pair of grades... so Integer.lowestOneBit(j/2)) == 1 &lt;br&gt;
	 * invoke with (3) is unnamed, but flips every other quartet of grades... so Integer.lowestOneBit(j/4)) == 1 &lt;br&gt;
	 * invoke with (4) is unnamed, but flips every other octet of grades... so Integer.lowestOneBit(j/8)) == 1 &lt;br&gt;
	 * etc.
	 * &lt;br&gt;&lt;br&gt;
	 * @param pWhich int used for pow(2, pWhich-1) which is the grade block size for sign switches.
	 * @return Scale after modification of numbers.
	 */
	public Scale&lt;D&gt; conjugateShirokov(int pWhich) {
<span class="pc bpc" id="L300" title="1 of 2 branches missed.">		if (pWhich &lt;1) 			return this;</span>

<span class="fc" id="L302">		int power = CladosConstant.pow((byte) 2, pWhich-1).intValue();			//1 -&gt; 2^0=1	2 -&gt; 2^1=2</span>
<span class="fc bfc" id="L303" title="All 2 branches covered.">		gBasis.gradeStream().filter(j -&gt; (Integer.lowestOneBit(j/power)) == 1).parallel().forEach(grade -&gt; {</span>
<span class="fc" id="L304">			gBasis.bladeOfGradeStream((byte) grade).forEach(blade -&gt; {</span>
<span class="pc bpc" id="L305" title="1 of 3 branches missed.">				switch (mode) {</span>
				case REALF:						//Tricky here. This case falls through to the next and gets handled.
				case COMPLEXF:
<span class="fc" id="L308">					(map.get(blade)).scale(CladosConstant.MINUS_ONE_F);</span>
<span class="fc" id="L309">					break;						//Both cases handled in one then break.</span>
				case REALD:						//Tricky here. This case falls through to the next and gets handled.
				case COMPLEXD:
<span class="fc" id="L312">					(map.get(blade)).scale(CladosConstant.MINUS_ONE_D);</span>
				}			//Both cases handled in one then done.
<span class="fc" id="L314">			});</span>
<span class="fc" id="L315">		});</span>
<span class="fc" id="L316">		return this;</span>
	}

	/**
	 * This method imitates the 'get()' method in a map. Offer a key and receive a
	 * value in return. In this particular case, keys are blades from the basis and
	 * values are weights of those blades.
	 * &lt;br&gt;
	 * @param pB Blade to use as key in internal map
	 * @return A ProtoN child related to this blade
	 */
	public D get(Blade pB) {
<span class="fc" id="L328">		return map.get(pB);</span>
	}

	/**
	 * Simple gettor method for the Basis associated with this object.
	 * Be aware this basis is finalized, so it won't be changeable to 
	 * a new basis. What might be possible is altering the internal details
	 * of the basis, so be careful.
	 * &lt;br&gt;
	 * @return Basis in use in this.
	 */
	public Basis getBasis() {
<span class="fc" id="L340">		return gBasis;</span>
	}

	/**
	 * Simple gettor method for the Cardinal associated with this object.
	 * &lt;br&gt;
	 * @return Cardinal in use in this.
	 */
	@Override
	public Cardinal getCardinal() {
<span class="fc" id="L350">		return card;</span>
	}

	/**
	 * This method imitates one from V1.0 and should be rarely used. For old code
	 * needing to handle coefficients directly, this is how to get at them. The
	 * smarter approach, though, is to call the parent class method values() and
	 * receive a Collection of coefficients instead of an array. Do it that way and
	 * they are already of a known ProtoN child class.
	 * &lt;br&gt;
	 * Since the internal map can accept any of the CladosF numbers as values, there
	 * is a cast to a 'generic' type within this method. This would normally cause
	 * warnings by the compiler since the generic named in the internal map IS a
	 * ProtoN child AND casting an unchecked type could fail at runtime.
	 * &lt;br&gt;
	 * That won't happen here when CladosF builders are used. They can't build
	 * anything that is NOT a ProtoN child. They can't even build a
	 * ProtoN instance directly. Therefore, only children can arrive as the
	 * value parameter of the 'put' function. Thus, there is no danger of a failed
	 * cast operation... until someone creates a new ProtoN child class and
	 * fails to update all builders.
	 * &lt;br&gt;
	 * @return an array of ProtoN children.
	 */
	public D[] getNumbers() {
<span class="pc bpc" id="L375" title="1 of 5 branches missed.">		switch (mode) {</span>
<span class="fc" id="L376">			case REALF : return (D[]) map.values().toArray(RealF[]::new);</span>
<span class="fc" id="L377">			case REALD : return (D[]) map.values().toArray(RealD[]::new);</span>
<span class="fc" id="L378">			case COMPLEXF : return (D[]) map.values().toArray(ComplexF[]::new);</span>
<span class="fc" id="L379">			case COMPLEXD : return (D[]) map.values().toArray(ComplexD[]::new);</span>
<span class="nc" id="L380">			default : return null;</span>
		}
	}

	/**
	 * Simple gettor method reporting the Scale's internal mode.
	 * &lt;br&gt;
	 * @return CladosField element reporting which ProtoN child is expected in
	 *         the list of this Scale.
	 */
	@Override
	public CladosField getMode() {
<span class="fc" id="L392">		return mode;</span>
	}

	/**
	 * This method imitates the 'get()' method in a map, but specializes in the
	 * pscalar blade key.
	 * &lt;br&gt;
	 * Since the internal map can accept any of the CladosF numbers as values, there
	 * is a cast to a 'generic' type within this method. This would normally cause
	 * warnings by the compiler since the generic named in the internal map IS a
	 * ProtoN child AND casting an unchecked type could fail at runtime.
	 * &lt;br&gt;
	 * That won't happen here when CladosF builders are used. They can't build
	 * anything that is NOT a ProtoN child. They can't even build a
	 * ProtoN instance directly. Therefore, only children can arrive as the
	 * value parameter of the 'put' function. Thus, there is no danger of a failed
	 * cast operation... until someone creates a new ProtoN child class and
	 * fails to update all builders.
	 * &lt;br&gt;
	 * @return A ProtoN child related to the pscalar blade
	 */
	public D getPScalar() {
<span class="fc" id="L414">		return map.get(gBasis.getPScalarBlade());</span>
	}

	/**
	 * This method imitates the 'get()' method in a map, but specializes in the
	 * scalar blade key.
	 * &lt;br&gt;
	 * Since the internal map can accept any of the CladosF numbers as values, there
	 * is a cast to a 'generic' type within this method. This would normally cause
	 * warnings by the compiler since the generic named in the internal map IS a
	 * ProtoN child AND casting an unchecked type could fail at runtime.
	 * &lt;br&gt;
	 * That won't happen here when CladosF builders are used. They can't build
	 * anything that is NOT a ProtoN child. They can't even build a
	 * ProtoN instance directly. Therefore, only children can arrive as the
	 * value parameter of the 'put' function. Thus, there is no danger of a failed
	 * cast operation... until someone creates a new ProtoN child class and
	 * fails to update all builders.
	 * &lt;br&gt;
	 * @return A ProtoN child related to the scalar blade
	 */
	public D getScalar() {
<span class="fc" id="L436">		return map.get(gBasis.getScalarBlade());</span>
	}

	/**
	 * This is a short hand method to reduce checking in other classes to simply
	 * asking the question regarding the value rather than handle all the various
	 * ProtoN children separately.
	 * &lt;br&gt;
	 * NOTE this tends to get used in filters in streams to minimize the number of
	 * coefficients processed in arithmetic operations. Non-zero ones contribute
	 * non-zero results to products, so this especially matters in O(N^2)
	 * calculations.
	 * &lt;br&gt;
	 * @param pB Blade to use as key to discover if related value is non-zero.
	 * @return boolean False if the related value evaluates as ZERO in whatever
	 *         number style it is.
	 */
	public boolean isNotZeroAt(Blade pB) {
<span class="pc bpc" id="L454" title="1 of 5 branches missed.">		switch (mode) {</span>
<span class="fc bfc" id="L455" title="All 2 branches covered.">			case COMPLEXD :	return !ComplexD.isZero((ComplexD) map.get(pB));</span>
<span class="fc bfc" id="L456" title="All 2 branches covered.">			case COMPLEXF : return !ComplexF.isZero((ComplexF) map.get(pB));</span>
<span class="fc bfc" id="L457" title="All 2 branches covered.">			case REALD : return !RealD.isZero((RealD) map.get(pB));</span>
<span class="fc bfc" id="L458" title="All 2 branches covered.">			case REALF : return !RealF.isZero((RealF) map.get(pB));</span>
<span class="nc" id="L459">			default : return true;</span>
		}
	}

	/**
	 * This is a short hand method to reduce checking in other classes to simply
	 * asking this one rather than handle all the various ProtoN children
	 * separately.
	 * &lt;br&gt;
	 * @return boolean True if the pscalar value evaluates as ZERO in whatever
	 *         number style it is.
	 */
	public boolean isPScalarZero() {
<span class="pc bpc" id="L472" title="1 of 5 branches missed.">		switch (mode) {</span>
<span class="fc" id="L473">			case COMPLEXD : return ComplexD.isZero((ComplexD) getPScalar());</span>
<span class="fc" id="L474">			case COMPLEXF :	return ComplexF.isZero((ComplexF) getPScalar());</span>
<span class="fc" id="L475">			case REALD : return RealD.isZero((RealD) getPScalar());</span>
<span class="fc" id="L476">			case REALF : return RealF.isZero((RealF) getPScalar());</span>
<span class="nc" id="L477">			default : return false;</span>
		}
	}

	/**
	 * This is a short hand method to reduce checking in other classes to simply
	 * asking this one rather than handle all the various ProtoN children
	 * separately.
	 * &lt;br&gt;
	 * @return boolean True if the scalar value evaluates as ZERO in whatever number
	 *         style it is.
	 */
	public boolean isScalarZero() {
<span class="pc bpc" id="L490" title="1 of 5 branches missed.">		switch (mode) {</span>
<span class="fc" id="L491">			case COMPLEXD : return ComplexD.isZero((ComplexD) getScalar());</span>
<span class="fc" id="L492">			case COMPLEXF : return ComplexF.isZero((ComplexF) getScalar());</span>
<span class="fc" id="L493">			case REALD : return RealD.isZero((RealD) getScalar());</span>
<span class="fc" id="L494">			case REALF : return RealF.isZero((RealF) getScalar());</span>
<span class="nc" id="L495">			default : return false;</span>
		}
	}

	/**
	 * This method takes all values in the map and returns one ProtoN child
	 * that has a real value that is equal to the square root of the sum of the
	 * SQModulus of each value.
	 * &lt;br&gt;
	 * NOTE about suppressed type cast warnings | This method switches through the
	 * possible classes known as descendents of ProtoN. If the object to be
	 * copied is one of them, the method uses a constructor appropriate to it, but
	 * then casts the result back to the generic T before returning it.
	 * &lt;br&gt;
	 * There is no danger to this with respect to the implementation of this method.
	 * The danger comes from mis-use of the method. If one passes a different kind
	 * of object that passes as a descendent of ProtoN implementing Field and
	 * Normalizable, this method might not detect it and return null. The type
	 * casting operation itself cannot fail, but unrecognized child classes do NOT
	 * get copied.
	 * &lt;br&gt;
	 * This can happen if one extends ProtoN creating a new CladosF number.
	 * This method will not be aware of the new class until its implementation is
	 * updated.
	 * &lt;br&gt;
	 * Because these are real numbers, though, we get away with simply summing the
	 * moduli instead. It does not perform a cardinal safety check and will throw
	 * the exception if that test fails.
	 * &lt;br&gt;
	 * @return D ProtoN child that implements all the number interfaces too.
	 */
	public D modulusSQSum() {
		D tR;
<span class="pc bpc" id="L528" title="1 of 5 branches missed.">		switch (mode) {</span>
			case REALF -&gt; {
<span class="fc" id="L530">				tR = FBuilder.REALF.createZERO(this.getCardinal());</span>
<span class="fc" id="L531">				weightsStream().forEach(div -&gt; {</span>
					try {
<span class="fc" id="L533">						tR.add(RealF.newONE(this.getCardinal()).scale(div.sqModulus()));</span>
<span class="nc" id="L534">					} catch (FieldBinaryException e) {</span>
<span class="nc" id="L535">						throw new IllegalArgumentException(&quot;Cardinal mismatch when forming modulus sum.&quot;);</span>
<span class="fc" id="L536">					}</span>
<span class="fc" id="L537">				});</span>
<span class="fc" id="L538">				return tR;</span>
			}
			case REALD -&gt; {
<span class="fc" id="L541">				tR = FBuilder.REALD.createZERO(this.getCardinal());</span>
<span class="fc" id="L542">				weightsStream().forEach(div -&gt; {</span>
					try {
<span class="fc" id="L544">						tR.add(RealD.newONE(this.getCardinal()).scale(div.sqModulus()));</span>
<span class="nc" id="L545">					} catch (FieldBinaryException e) {</span>
<span class="nc" id="L546">						throw new IllegalArgumentException(&quot;Cardinal mismatch when forming modulus sum.&quot;);</span>
<span class="fc" id="L547">					}</span>
<span class="fc" id="L548">				});</span>
<span class="fc" id="L549">				return tR;</span>
			}
			case COMPLEXF -&gt; {
<span class="fc" id="L552">				tR = FBuilder.COMPLEXF.createZERO(this.getCardinal());</span>
<span class="fc" id="L553">				weightsStream().forEach(div -&gt; {</span>
					try {
<span class="fc" id="L555">						tR.add(ComplexF.newONE(this.getCardinal()).scale(div.sqModulus()));</span>
<span class="nc" id="L556">					} catch (FieldBinaryException e) {</span>
<span class="nc" id="L557">						throw new IllegalArgumentException(&quot;Cardinal mismatch when forming modulus sum.&quot;);</span>
<span class="fc" id="L558">					}</span>
<span class="fc" id="L559">				});</span>
<span class="fc" id="L560">				return tR;</span>
			}
			case COMPLEXD -&gt; {
<span class="fc" id="L563">				tR = FBuilder.COMPLEXD.createZERO(this.getCardinal());</span>
<span class="fc" id="L564">				weightsStream().forEach(div -&gt; {</span>
					try {
<span class="fc" id="L566">						tR.add(ComplexD.newONE(this.getCardinal()).scale(div.sqModulus()));</span>
<span class="nc" id="L567">					} catch (FieldBinaryException e) {</span>
<span class="nc" id="L568">						throw new IllegalArgumentException(&quot;Cardinal mismatch when forming modulus sum.&quot;);</span>
<span class="fc" id="L569">					}</span>
<span class="fc" id="L570">				});</span>
<span class="fc" id="L571">				return tR;</span>
			}
			default -&gt; {
<span class="nc" id="L574">				return (D) new ProtoN(this.getCardinal());</span>
			}
		}
	}

	/**
	 * This method takes all values in the map and returns one ProtoN child
	 * that has a real value that is equal to the square root of the sum of the
	 * SQModulus of each value.
	 * &lt;br&gt;&lt;br&gt;
	 * Because these are real numbers, though, we get away with simply summing the
	 * moduli instead. It does not perform a cardinal safety check and will throw
	 * the exception if that test fails.
	 * &lt;br&gt;&lt;br&gt;
	 * NOTE about suppressed type cast warnings | This method switches through the
	 * possible classes known as descendents of ProtoN. If the object to be
	 * copied is one of them, the method uses a constructor appropriate to it, but
	 * then casts the result back to the generic T before returning it.
	 * &lt;br&gt;&lt;br&gt;
	 * There is no danger to this with respect to the implementation of this method.
	 * The danger comes from mis-use of the method. If one passes a different kind
	 * of object that passes as a descendent of ProtoN implementing Field and
	 * Normalizable, this method might not detect it and return null. The type
	 * casting operation itself cannot fail, but unrecognized child classes do NOT
	 * get copied.
	 * &lt;br&gt;&lt;br&gt;
	 * This can happen if one extends ProtoN creating a new CladosF number.
	 * This method will not be aware of the new class until its implementation is
	 * updated.
	 * &lt;br&gt;&lt;br&gt;
	 * @return D ProtoN child that implements all the number interfaces too.
	 */
	public D modulusSum() {
		D tR;
<span class="pc bpc" id="L608" title="1 of 5 branches missed.">		switch (mode) {</span>
		case REALF -&gt; {
<span class="fc" id="L610">			tR = FBuilder.REALF.createZERO(this.getCardinal());</span>
<span class="fc" id="L611">			weightsStream().forEach(div -&gt; {  //Do not go parallel in this stream</span>
				try {
<span class="fc" id="L613">					tR.add(RealF.newONE(this.getCardinal()).scale(div.modulus()));</span>
<span class="nc" id="L614">				} catch (FieldBinaryException e) {</span>
<span class="nc" id="L615">					throw new IllegalArgumentException(&quot;Cardinal mismatch in addition while forming modulus sum.&quot;);</span>
<span class="fc" id="L616">				}</span>
<span class="fc" id="L617">			});</span>
<span class="fc" id="L618">			return (D) tR;</span>
		}
		case REALD -&gt; {
<span class="fc" id="L621">			tR = FBuilder.REALD.createZERO(this.getCardinal());</span>
<span class="fc" id="L622">			weightsStream().forEach(div -&gt; {  //Do not go parallel in this stream</span>
				try {
<span class="fc" id="L624">					tR.add(RealD.newONE(this.getCardinal()).scale(div.modulus()));</span>
<span class="nc" id="L625">				} catch (FieldBinaryException e) {</span>
<span class="nc" id="L626">					throw new IllegalArgumentException(&quot;Cardinal mismatch in addition while forming modulus sum.&quot;);</span>
<span class="fc" id="L627">				}</span>
<span class="fc" id="L628">			});</span>
<span class="fc" id="L629">			return (D) tR;</span>
		}
		case COMPLEXF -&gt; {
<span class="fc" id="L632">			tR = FBuilder.COMPLEXF.createZERO(this.getCardinal());</span>
<span class="fc" id="L633">			weightsStream().forEach(div -&gt; {  //Do not go parallel in this stream</span>
				try {
<span class="fc" id="L635">					tR.add(ComplexF.newONE(this.getCardinal()).scale(div.modulus()));	 //Conjugate built in</span>
<span class="nc" id="L636">				} catch (FieldBinaryException e) {</span>
<span class="nc" id="L637">					throw new IllegalArgumentException(&quot;Cardinal mismatch in addition while forming modulus sum.&quot;);</span>
<span class="fc" id="L638">				}</span>
<span class="fc" id="L639">			});</span>
<span class="fc" id="L640">			return (D) tR;</span>
		}
		case COMPLEXD -&gt; {
<span class="fc" id="L643">			tR = FBuilder.COMPLEXD.createZERO(this.getCardinal());</span>
<span class="fc" id="L644">			weightsStream().forEach(div -&gt; {  //Do not go parallel in this stream</span>
				try {
<span class="fc" id="L646">					tR.add(ComplexD.newONE(this.getCardinal()).scale(div.modulus()));	 //Conjugate built in</span>
<span class="nc" id="L647">				} catch (FieldBinaryException e) {</span>
<span class="nc" id="L648">					throw new IllegalArgumentException(&quot;Cardinal mismatch in addition while forming modulus sum.&quot;);</span>
<span class="fc" id="L649">				}</span>
<span class="fc" id="L650">			});</span>
<span class="fc" id="L651">			return (D) tR;</span>
		}
		default -&gt; {
<span class="nc" id="L654">			return (D) new ProtoN(this.getCardinal());</span>
		}
		}
	}

	/**
	 * This method normalizes the coefficients as if they were a vector in 2^N vector space described by the 
	 * implied basis from the monad. It's pretty simple, though. Just add up the squares of the numbers and 
	 * then take the square root to determine the magnitude and then invert that to scale the original numbers.
	 * &lt;br&gt;&lt;br&gt;
	 * Since the internal map can accept any of the CladosF numbers as values, there is a cast to a 'generic' 
	 * type within this method. This would normally cause warnings by the compiler since the generic named in
	 *  the internal map IS a ProtoN child AND casting an unchecked type could fail at runtime.
	 * &lt;br&gt;&lt;br&gt;
	 * That won't happen here when CladosF builders are used. They can't build anything that is NOT a ProtoN 
	 * child. They can't even build a ProtoN instance directly. Therefore, only children can arrive as the 
	 * value parameter of the 'put' function. Thus, there is no danger of a failed cast operation... until 
	 * someone creates a new ProtoN child class and fails to update all builders.
	 * &lt;br&gt;&lt;br&gt;
	 * @throws FieldException 	This happens when normalizing something that has a zero magnitude. 
	 * 							The exception is thrown by the number's invert() and passed along.
	 */
	public void normalize() throws FieldException {
<span class="fc" id="L677">		this.scale((D) modulusSum().invert());</span>
<span class="fc" id="L678">	}</span>

	/**
	 * Put a key/value pair into the internal map of coefficients. A Blade acts as key. A ProtoN child acts as coefficient.
	 * &lt;br&gt;&lt;br&gt;
	 * The offered number IS USED DIRECTLY. NO COPY IS CREATED!
	 * &lt;br&gt;&lt;br&gt;
	 * @param pB  Blade acting as key in the internal map
	 * @param pD  ProtoN child acting as the coefficient.
	 * @return Scale of Unit Abstract objects. Just this object after modification if it occurs.
	 */
	public Scale&lt;D&gt; put(Blade pB, D pD) {
<span class="fc" id="L690">		map.put(pB, pD);</span>
<span class="fc" id="L691">		return this;</span>
	}

	/**
	 * This method scales all values in the internal map by the value offered provided there is no typeMatch failure. 
	 * When there IS a type mismatch the number simply does not get scaled.
	 * &lt;br&gt;
	 * The first stream filters for weights that pass the match test.
	 * The second stream scales them.
	 * That means the embedded IllegalARgumentException will never be thrown.
	 * &lt;br&gt;
	 * @param pIn ProtoN child to use as a scaling element. 
	 * 				Mode and cardinal MUST match values in map.
	 * @param &lt;T&gt; ProtoN child generic type support. Must also implement Field.
	 * @return Scale object. Just this object after modification.
	 */
	public &lt;T extends ProtoN &amp; Field &amp; Normalizable&gt; Scale&lt;D&gt; scale(T pIn) {
<span class="fc bfc" id="L708" title="All 4 branches covered.">		if (	!(pIn instanceof RealF &amp; getMode() == REALF)</span>
<span class="fc bfc" id="L709" title="All 4 branches covered.">			&amp; 	!(pIn instanceof RealD &amp; getMode() == REALD)</span>
<span class="fc bfc" id="L710" title="All 4 branches covered.">			&amp; 	!(pIn instanceof ComplexF &amp; getMode() == COMPLEXF)</span>
<span class="pc bpc" id="L711" title="1 of 6 branches missed.">			&amp; 	!(pIn instanceof ComplexD &amp; getMode() == COMPLEXD) )</span>
<span class="nc" id="L712">			throw new IllegalArgumentException(&quot;Offered scaling number MUST mode match.&quot;);</span>

<span class="pc bpc" id="L714" title="2 of 4 branches missed.">		if (pIn.getCardinal() == card &amp; weightsStream().allMatch(x -&gt; ProtoN.isTypeMatch(x, pIn))) {</span>
<span class="fc" id="L715">			weightsParallelStream()</span>
<span class="fc" id="L716">				.forEach(y -&gt; {	try {y.multiply(pIn);} </span>
<span class="nc" id="L717">								catch (FieldBinaryException e) {</span>
<span class="nc" id="L718">									throw new IllegalArgumentException(&quot;Can't scale with NaN or isInfinite.&quot;);</span>
<span class="fc" id="L719">								}	//Field binary exception is also thrown for cardinal mismatches</span>
									//but those were caught at the top of the conditional causing 
									//this method to do absolutely nothing. Anything caught down here 
									//should stop events the same way dividing by ZERO does.
<span class="fc" id="L723">			});</span>
		}
<span class="fc" id="L725">		return this;</span>
	}

	/**
	 * This is an exporter of internal details to XML. It exists to bypass certain
	 * security concerns related to Java serialization of objects.
	 * &lt;br&gt;
	 * @param pS The Scale oject to be output as XML
	 * @param indent String of 'tab' characters to get spacing right for human
	 *               readable XML output.
	 * @return String formatted as XML containing information about the Algebra
	 */
	public final static String toXMLString(Scale&lt;?&gt; pS, String indent) {

<span class="fc" id="L739">		StringBuilder rB = new StringBuilder(indent).append(&quot;&lt;Scales mode=\&quot;&quot;+pS.getMode()+&quot;\&quot; pans=\&quot;&quot;).append(pS.map.size()).append(&quot;\&quot;&gt;\n&quot;);</span>

<span class="fc" id="L741">		pS.gBasis.bladeStream().forEach(blade -&gt; {</span>
<span class="fc" id="L742">			rB.append(indent).append(&quot;\t\t\t&lt;Pair&gt;\n&quot;);</span>
<span class="fc" id="L743">			rB.append(indent).append(Blade.toXMLString(blade, &quot;\t\t\t\t&quot;));</span>
<span class="pc bpc" id="L744" title="1 of 5 branches missed.">			switch (pS.getMode()){</span>
<span class="fc" id="L745">				case COMPLEXD -&gt; {rB.append(indent + &quot;\t\t\t\t&quot;).append(ComplexD.toXMLString((ComplexD) pS.map.get(blade))).append(&quot;\n&quot;);}</span>
<span class="fc" id="L746">				case COMPLEXF -&gt; {rB.append(indent + &quot;\t\t\t\t&quot;).append(ComplexF.toXMLString((ComplexF) pS.map.get(blade))).append(&quot;\n&quot;);}</span>
<span class="fc" id="L747">				case REALD -&gt; 	{rB.append(indent + &quot;\t\t\t\t&quot;).append(RealD.toXMLString((RealD) pS.map.get(blade))).append(&quot;\n&quot;);}</span>
<span class="fc" id="L748">				case REALF -&gt; 	{rB.append(indent + &quot;\t\t\t\t&quot;).append(RealF.toXMLString((RealF) pS.map.get(blade))).append(&quot;\n&quot;);}</span>
<span class="nc" id="L749">				default -&gt; 		{rB.append(indent + &quot;\t\t\t\t&quot;).append(ProtoN.toXMLString(pS.map.get(blade))).append(&quot;\n&quot;);}</span>
			}	
<span class="fc" id="L751">			rB.append(indent).append(&quot;\t\t\t&lt;/Pair&gt;\n&quot;);</span>
<span class="fc" id="L752">		});</span>

<span class="fc" id="L754">		rB.append(indent).append(&quot;\t\t&lt;/Scales&gt;\n&quot;);</span>
<span class="fc" id="L755">		return rB.toString();</span>
	}

	/**
	 * This is a simple gettor method, but it is most likly to be used to establish
	 * a stream of blades, values, or both from the internal map of this object. The
	 * map's keys are all blades from the object's basis. The map won't contain just
	 * a few blades as keys, though. It will contain every blade as a key paired to
	 * some unique CladosF number.
	 * &lt;br&gt;
	 * Since the internal map can accept any of the CladosF numbers (and
	 * ProtoN itself though that would be useless) there is a cast to a
	 * 'generic' type before insertion into the map. This would normally cause
	 * warnings by the compiler since the generic named in the internal map IS a
	 * ProtoN child AND casting an unchecked type could fail at runtime.
	 * &lt;br&gt;
	 * That won't happen here when CladosF builders are used. They can't build
	 * anything that is NOT a ProtoN child. They can't even build a
	 * ProtoN instance directly. Therefore, only children can arrive as the
	 * value parameter of the 'put' function. Thus, there is no danger of a failed
	 * cast operation... until someone creates a new ProtoN child class and
	 * fails to update all builders.
	 * &lt;br&gt;
	 * @param &lt;T&gt; ProtoN child generic type support. Must also implement Field
	 *            AND Normalizable.
	 * @return deliver the internal coefficients as the internal map.
	 */
	protected &lt;T extends ProtoN &amp; Field &amp; Normalizable&gt; Map&lt;Blade, T&gt; getMap() {
<span class="fc" id="L783">		return (Map&lt;Blade, T&gt;) map;</span>
	}

	/**
	 * The settor method supporting Unitized interface that isn't actually in the
	 * interface. If the cardinal to be set is different from the one already present,
	 * the weights are cleared out and set to zero. If the cardinal is the same one,
	 * nothing is done and this Scale is returned.
	 * &lt;br&gt;
	 * Once a Cardinal is set, it basically can't be removed. It can be changed, but
	 * not eliminated entirely.
	 * @param pCard CladosField element to set as the mode.
	 * @return Scale object. Just this object after modification.
	 */
	protected Scale&lt;D&gt; setCardinal(Cardinal pCard) {
<span class="pc bpc" id="L798" title="1 of 6 branches missed.">		if (card != pCard &amp; pCard != null) {</span>
<span class="fc" id="L799">			weightsParallelStream().forEach(x -&gt; x.setCardinal(pCard));</span>
<span class="fc" id="L800">			card = pCard;</span>
		}
<span class="fc" id="L802">		return this;</span>
	}

	/**
	 * This method just sets the pscalar weight with a number that should satisfy type matches. If it
	 * does not get past the type match check, nothing is done to change any weights. If it fails the mode
	 * check, an IllegalArgumentException is thrown.
	 * &lt;br&gt;&lt;br&gt;
	 * The offered number IS USED DIRECTLY. NO COPY IS CREATED!
	 * &lt;br&gt;&lt;br&gt;
	 * @param &lt;T&gt; is a child of ProtoN used as the generic identity of the weights in this object.
	 * @param pIn D is a child of ProtoN to use as the pscalar weight.
	 * @return Scale of numbers for use in streaming operations if desired.
	 */
	protected &lt;T extends ProtoN &amp; Field &amp; Normalizable&gt; Scale&lt;D&gt; setPScalar(T pIn) {
<span class="fc" id="L817">		setNumber(gBasis.getPScalarBlade(), pIn);			//Defer to checks made in setNumber()</span>
<span class="fc" id="L818">		return this;</span>
	}

	/**
	 * This method just sets the scalar weight with a number that should satisfy type matches. If it
	 * does not get past the type match check, nothing is done to change any weights. If it fails the mode
	 * check, an IllegalArgumentException is thrown.
	 * &lt;br&gt;&lt;br&gt;
	 * The offered number IS USED DIRECTLY. NO COPY IS CREATED!
	 * &lt;br&gt;&lt;br&gt;
	 * @param &lt;T&gt; is a child of ProtoN used as the generic identity of the weights in this object.
	 * @param pIn D is a child of ProtoN to use as the pscalar weight.
	 * @return Scale of numbers for use in streaming operations if desired.
	 */
	protected &lt;T extends ProtoN &amp; Field &amp; Normalizable&gt; Scale&lt;D&gt; setScalar(T pIn) {
<span class="fc" id="L833">		setNumber(gBasis.getScalarBlade(), pIn);			//Defer to checks made in setNumber()</span>
<span class="fc" id="L834">		return this;</span>
	}

	/**
	 * This coefficient settor accepts a single ProtoN child and a Blade and inserts the number into the 
	 * internal map at the blade index.
	 * &lt;br&gt;&lt;br&gt;
	 * NOTE | Do NOT use this method if you intend the offered number to be disconnected from this object. 
	 * IT WON'T BE! If you really must use this method that way, copy your coefficients first.
	 * &lt;br&gt;
	 * @param &lt;T&gt; is a child of ProtoN used as the generic identity of the number object.
	 * @param pB Blade where the offered number belongs.
	 * @param pIn Array of ProtoN children
	 * @return Scale object. Just this object after modification.
	 * @throws IllegalArgumentException This happens if the offered number is null OR the blade isn't in the basis. 
	 * 									The blade must be covered. NO NULL numbers.
	 */
	protected &lt;T extends ProtoN &amp; Field &amp; Normalizable&gt; Scale&lt;D&gt; setNumber(Blade pB, T pIn) {
<span class="pc bpc" id="L852" title="1 of 2 branches missed.">		if (pIn == null)																//Nulls aren't tolerated</span>
<span class="nc" id="L853">					throw new IllegalArgumentException(&quot;Offered number MUST NOT be null.&quot;);</span>
<span class="pc bpc" id="L854" title="1 of 2 branches missed.">		if (!map.containsKey(pB))</span>
<span class="nc" id="L855">					throw new IllegalArgumentException(&quot;Offered Blade MUST be in the basis.&quot;);</span>
<span class="fc bfc" id="L856" title="All 6 branches covered.">		if  (	!(pIn instanceof RealF) &amp; (getMode() == REALF)</span>
<span class="fc bfc" id="L857" title="All 4 branches covered.">			&amp; 	!(pIn instanceof RealD) &amp; (getMode() == REALD)</span>
<span class="fc bfc" id="L858" title="All 4 branches covered.">			&amp; 	!(pIn instanceof ComplexF) &amp; (getMode() == COMPLEXF)</span>
<span class="pc bpc" id="L859" title="1 of 4 branches missed.">			&amp; 	!(pIn instanceof ComplexD) &amp; (getMode() == COMPLEXD))</span>
<span class="nc" id="L860">					throw new IllegalArgumentException(&quot;Offered number MUST mode match.&quot;);</span>
<span class="fc bfc" id="L861" title="All 2 branches covered.">		if (card != pIn.getCardinal())</span>
<span class="fc" id="L862">					throw new IllegalArgumentException(&quot;Offered number MUST match the Scale cardinal.&quot;);</span>
<span class="fc" id="L863">		map.put(pB, (D) pIn);</span>
<span class="fc" id="L864">		return this;</span>
	}
	/**
	 * This coefficient settor accepts an array of ProtoN numbers, assumes they are in basis index order, and then 
	 * inserts them into the internal map by blade at that index.
	 * &lt;br&gt;&lt;br&gt;
	 * NOTE | Do NOT use this method if you intend the offered coefficient array to be disconnected from this object. 
	 * IT WON'T BE!. If you really must use this method that way, copy your coefficients first.
	 * &lt;br&gt;&lt;br&gt;
	 * NOTE | Do NOT try to change the mode for the scale either. Once set, mode is fixed.
	 * &lt;br&gt;&lt;br&gt;
	 * @param &lt;T&gt; 	is a child of ProtoN used as the generic identity of the numbers.
	 * @param pIn 	Array of ProtoN children
	 * @return Scale after this object is modified.
	 * @throws IllegalArgumentException This happens if the offered array not suitable to cover the basis.
	 * 									All blades must be covered. NO NULL numbers.
	 */
	protected &lt;T extends ProtoN &amp; Field &amp; Normalizable&gt; Scale&lt;D&gt; setNumbers(T[] pIn) {
<span class="fc bfc" id="L882" title="All 2 branches covered.">		if (pIn == null)																//Nulls aren't tolerated</span>
<span class="fc" id="L883">					throw new IllegalArgumentException(&quot;Offered array of coefficients MUST NOT be null.&quot;);</span>
<span class="fc bfc" id="L884" title="All 2 branches covered.">		if (!Scale.validateNoNullsIncoming(pIn))										//Seriously! They aren't tolerated.</span>
<span class="fc" id="L885">					throw new IllegalArgumentException(&quot;Offered array of coefficients MUST NOT contain nulls.&quot;);</span>
<span class="fc bfc" id="L886" title="All 2 branches covered.">		if(!Scale.validateModeIncoming(getMode(), pIn))									//Mixed mode isn't tolerated either.</span>
<span class="fc" id="L887">					throw new IllegalArgumentException(&quot;Offered array of coefficients MUST mode match.&quot;);</span>
<span class="fc bfc" id="L888" title="All 2 branches covered.">		if (pIn.length != gBasis.getBladeCount())										//Offered array MUST cover the basis.</span>
<span class="fc" id="L889">					throw new IllegalArgumentException(&quot;Offered array of coefficients MUST cover every blade in the basis.&quot;);</span>

<span class="pc bpc" id="L891" title="3 of 4 branches missed.">		switch (Scale.testCardinalMatchesIncoming(card, pIn)) {</span>
<span class="nc" id="L892">			case 0  : throw new IllegalArgumentException(&quot;Coefficients passed are a jumbled mess of cardinals.&quot;);</span>
<span class="nc" id="L893">			case -1 : card = pIn[0].getCardinal();										//-1 case ALSO uses +1 action</span>
<span class="fc" id="L894">			case +1 : gBasis.bladeStream().forEach(blade -&gt; {</span>
<span class="fc" id="L895">									setNumber(blade, pIn[gBasis.find(blade) - 1]);		//nulls checked again which is okay</span>
																						//the top level check stops ALL mutation.
<span class="fc" id="L897">								});</span>
			default : ;
		}
<span class="fc" id="L900">		return this;</span>
	}

	/**
	 * This method sets the coefficients represented by this Scale. It accepts a map relating blades in the basis to ProtoN children. 
	 * It checks to see if the map is of the wrong size and throws an IllegalArgumentException if so. It does NOT check
	 * for mode consistency and nulls
	 * &lt;br&gt;
	 * NOTE this method DEEP COPIES the inbound map to disconnect the map's source ProtoN children from the ones 'put' here. 
	 * This is the safest settor for ensuring numbers are NOT reused across monads... IF ONE PAYS ATTENTION to nulls and mixed modes.
	 * &lt;br&gt;
	 * @param pInMap Inbound Map relating blades to numbers.
	 * @return Scale after modification of the map.
	 * @throws IllegalArgumentException This happens if the offered map does not have the same size as the basis. Good enough
	 *                                  to ensure all blades are covered because Map doesn't allow duplicate keys.
	 */
	protected Scale&lt;D&gt; setMap(Map&lt;Blade, D&gt; pInMap) {
<span class="pc bpc" id="L917" title="1 of 2 branches missed.">		if (pInMap.size() != gBasis.getBladeCount())</span>
<span class="nc" id="L918">					throw new IllegalArgumentException(&quot;Offered map of coefficients MUST cover every blade in the basis.&quot;);</span>

<span class="fc" id="L920">		Map&lt;Blade, D&gt; mapCopy = pInMap	.entrySet()</span>
<span class="fc" id="L921">										.parallelStream()</span>
<span class="fc" id="L922">										.collect(Collectors.toMap(	e -&gt; e.getKey(),</span>
<span class="fc" id="L923">																	e -&gt; FBuilder.copyOf(e.getValue())	)</span>
												);
<span class="fc" id="L925">		map.putAll(mapCopy);</span>
<span class="fc" id="L926">		return this;</span>
	}

	/**
	 * This settor accepts an array of ProtoN children, assumes they are in basis index order to assign a blade of the specified grade, 
	 * then inserts them into the map at that blade covering ONLY the grade suggested.
	 * &lt;br&gt;
	 * NOTE | Do NOT use this method if you intend the offered coefficient array to be disconnected from this object. IT WON'T BE! 
	 * If you really must use this method that way, copy your coefficients first.
	 * &lt;br&gt;
	 * @param pGrade byte integer naming the grade to be overwritten
	 * @param pIn    Array of ProtoN Children
	 * @return Scale object. Just this object after modification.
	 */
	protected Scale&lt;D&gt; setNumbersAtGrade(byte pGrade, D[] pIn) {
<span class="fc bfc" id="L941" title="All 2 branches covered.">		if (!gBasis.validateGradeIndex(pGrade))</span>
<span class="fc" id="L942">					throw new IllegalArgumentException(&quot;Offered grade must be in range for underlying basis.&quot;);</span>
<span class="fc bfc" id="L943" title="All 2 branches covered.">		if (pIn == null)</span>
<span class="fc" id="L944">					throw new IllegalArgumentException(&quot;Offered array of coefficients MUST NOT be null.&quot;);</span>
<span class="fc bfc" id="L945" title="All 2 branches covered.">		if (gBasis.bladeOfGradeStream(pGrade).count() != (long) pIn.length)</span>
<span class="fc" id="L946">					throw new IllegalArgumentException(&quot;Offered array of coefficients MUST cover every blade in the grade range.&quot;);</span>
		
<span class="pc bpc" id="L948" title="3 of 4 branches missed.">		switch (Scale.testCardinalMatchesIncoming(card, pIn)) {</span>
<span class="nc" id="L949">			case 0  : throw new IllegalArgumentException(&quot;Coefficients passed are a jumbled mess of cardinals.&quot;);</span>
<span class="nc" id="L950">			case -1 : throw new IllegalArgumentException(&quot;Coefficients passed MUST match the Scale cardinal.&quot;);</span>
			case +1 : {										//The only case we can accept requires perfect cardinal matches.
<span class="fc" id="L952">				int init = gBasis.getGradeStart(pGrade);	//This is where the pGrade blades start</span>
<span class="fc" id="L953">				gBasis	.bladeOfGradeStream(pGrade)			//so stream the blades, match them with pIn[] entries,</span>
<span class="fc" id="L954">						.forEach(blade -&gt; {	map.put(blade, pIn[gBasis.find(blade) - init - 1]);	} );	//and 'put' them in map.</span>
			}
			default : ;
		}
<span class="fc" id="L958">		return this;</span>
	}

    /**
	 * This is the compliment of a blade stream involving the scaling factors 'multiplied' by blades in the sense 
	 * of a linear combination in a vector space. When forming a linear combination of blades to make a 'vector', 
	 * these are the 'numbers' that scale each blade.
	 * &lt;br&gt;
	 * Since the internal map can accept any of the CladosF numbers as values, there is a cast to a 'generic' type 
	 * within this method. This would normally cause warnings by the compiler since the generic named in the internal 
	 * map IS a ProtoN child AND casting an unchecked type could fail at runtime.
	 * &lt;br&gt;
	 * That won't happen when CladosF builders are used because they dan't build anything that is NOT a ProtoN child. 
	 * Scale's internal map only accepts ProtoN child classes, so there is no danger of a failed cast operation... 
	 * until someone creates a new ProtoN child class and fails to update the builders.
	 * &lt;br&gt;
	 * @return Stream of ProtoN children that are the numbers in the internal map.
	 */
	protected Stream&lt;D&gt; weightsStream() {
<span class="fc" id="L977">		return map.values().stream();</span>
	}

	/**
	 * This method returns a parallelizable stream of the weights in this scale. 
	 * It is intended for wholesale operations on the weights that may be done
	 * in any order. It is mostly for use by the owning object of this Scale.
	 * &lt;br&gt;
	 * @return A stream of weights as children of ProtoN.
	 */
	protected Stream&lt;D&gt; weightsParallelStream() {
<span class="fc" id="L988">		return map.values().parallelStream();</span>
	}

	/**
	 * This method causes all coefficients to be set to zero using the offered
	 * cardinal.
	 * &lt;br&gt;
	 * @return This Scale instance after coefficients are zero'd out.
	 */
	protected Scale&lt;D&gt; zeroAll() {
<span class="fc" id="L998">		gBasis	.bladeStream()</span>
<span class="fc" id="L999">				.forEach(b -&gt; {</span>
<span class="fc" id="L1000">								map.put(b, FBuilder.createZERO(mode, card));</span>
<span class="fc" id="L1001">							});</span>
<span class="fc" id="L1002">		return this;</span>
	}

	/**
	 * This is a specialty method making use of setCoefficientsAtGrade for a
	 * specific purpose of grade suppression.
	 * &lt;br&gt;
	 * @param pGrade byte integer naming the grade to be preserved
	 * @return This Scale instance after coefficients are zero'd out.
	 */
	protected Scale&lt;D&gt; zeroAllButGrade(byte pGrade) {
<span class="fc bfc" id="L1013" title="All 2 branches covered.">		if (gBasis.validateGradeIndex(pGrade))</span>
<span class="fc" id="L1014">			gBasis	.bladeStream()</span>
<span class="fc bfc" id="L1015" title="All 2 branches covered.">					.filter(blade -&gt; blade.rank() != pGrade)</span>
<span class="fc" id="L1016">					.forEach(blade -&gt; {</span>
<span class="fc" id="L1017">										map.put(blade, FBuilder.createZERO(mode, card));</span>
<span class="fc" id="L1018">									});</span>
<span class="fc" id="L1019">		return this;</span>
	}

	/**
	 * Zero the value at the offered blade.
	 * &lt;br&gt;
	 * NOTE this doesn't remove the blade from the map because the basis should
	 * never change. The mapped value at that blade is zero'd.
	 * &lt;br&gt;
	 * @param pB Blade key to zero out the related coefficient
	 * @return Scale object. Just this object after modification.
	 */
	public Scale&lt;D&gt; zeroAt(Blade pB) {
<span class="fc bfc" id="L1032" title="All 4 branches covered.">		if (pB != null &amp; map.containsKey(pB))</span>
<span class="fc" id="L1033">			map.put(pB, FBuilder.createZERO(mode, map.get(pB).getCardinal()));</span>
<span class="fc" id="L1034">		return this;</span>
	}

	/**
	 * This is a specialty method making use of setCoefficientsAtGrade for a
	 * specific purpose of grade suppression.
	 * &lt;br&gt;
	 * @param pGrade byte integer naming the grade to be overwritten
	 * @return This Scale instance after coefficients are zero'd out.
	 */
	protected Scale&lt;D&gt; zeroAtGrade(byte pGrade) {
<span class="fc bfc" id="L1045" title="All 2 branches covered.">		if (gBasis.validateGradeIndex(pGrade))</span>
<span class="fc bfc" id="L1046" title="All 2 branches covered.">			gBasis.bladeStream().filter(blade -&gt; blade.rank() == pGrade).forEach(blade -&gt; {</span>
<span class="fc" id="L1047">				map.put(blade, FBuilder.createZERO(mode, card));</span>
<span class="fc" id="L1048">		});</span>
<span class="fc" id="L1049">		return this;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>